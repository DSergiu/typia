{"/docs":{"title":"Index","data":{"":"","outline#Outline":"// RUNTIME VALIDATORS\nexport function is<T>(input: unknown): input is T; // returns boolean\nexport function assert<T>(input: unknown): T; // throws TypeGuardError\nexport function validate<T>(input: unknown): IValidation<T>; // detailed\n\n// JSON FUNCTIONS\nexport namespace json {\nexport function application<T>(): IJsonApplication; // JSON schema\nexport function assertParse<T>(input: string): T; // type safe parser\nexport function assertStringify<T>(input: T): string; // safe and faster\n}\n\n// PROTOCOL BUFFER\nexport namespace protobuf {\nexport function message<T>(): string; // Protocol Buffer message\nexport function assertDecode<T>(buffer: Buffer): T; // safe decoder\nexport function assertEncode<T>(input: T): Uint8Array; // safe encoder\n}\n\n// RANDOM GENERATOR\nexport function random<T>(g?: Partial<IRandomGenerator>): T;\nTypia is a transformer library supporting below features:\nSuper-fast Runtime Validators\nEnhanced JSON functions\nProtocol Buffer encoder and decoder\nRandom data generator\n\n\n\n\n\nOnly one line required, with pure TypeScript type\n\nRuntime validator is 20,000x faster than class-validator\n\nJSON serialization is 200x faster than class-transformer","sponsors#Sponsors":"Thanks for your support.Your donation would encourage typia development."}},"/docs/json/parse":{"title":"Parse","data":{"":"","parse-functions#parse() functions":"export namespace json {\nexport function isParse<T>(input: string): Primitive<T> | null;\nexport function assertParse<T>(input: string): Primitive<T>;\nexport function validateParse<T>(\ninput: string\n): IValidation<Primitive<T>>;\n}\n\n\n\nexport class TypeGuardError extends Error {\npublic readonly method: string;\npublic readonly path: string | undefined;\npublic readonly expected: string;\npublic readonly value: any;\n}\n\n\n\nexport type IValidation<T> =\n| IValidation.ISuccess<T>\n| IValidation.IFailure;\nexport namespace IValidation {\nexport interface ISuccess<T> {\nsuccess: true;\ndata: T;\n}\nexport interface IFailure {\nsuccess: false;\nerrors: IError[];\n}\nexport interface IError {\npath: string;\nexpected: string;\nvalue: any;\n}\n}\n\n\n\n/**\n* Primitive type of JSON.\n*\n* `Primitive<T>` is a TMP (Type Meta Programming) type which converts\n* its argument as a primitive type within framework JSON.\n*\n* If the target argument is a built-in class which returns its origin primitive type\n* through the `valueOf()` method like the `String` or `Number`, its return type would\n* be the `string` or `number`. Otherwise, the built-in class does not have the\n* `valueOf()` method, the return type would be an empty object (`{}`).\n*\n* Otherwise, the target argument is a type of custom class, all of its custom method\n* would be erased and its prototype would be changed to the primitive `object`.\n* Therefore, return type of the TMP type finally be the primitive object.\n*\n* In addition, if the target argument is a type of custom class and it has a special\n* method `toJSON()`, return type of this `Primitive` would be not `Primitive<Instance>`\n* but `Primitive<ReturnType<Instance.toJSON>>`.\n*\n* Before                  | After\n* ------------------------|----------------------------------------\n* `Boolean`               | `boolean`\n* `Number`                | `number`\n* `String`                | `string`\n* `Class`                 | `object`\n* `Class` with `toJSON()` | `Primitive<ReturnType<Class.toJSON>>`\n* Native Class            | `{}`\n* Others                  | No change\n*\n* @template Instance Target argument type.\n* @author Jeongho Nam - https://github.com/samchon\n* @author Kyungsu Kang - https://github.com/kakasoo\n* @author Michael - https://github.com/8471919\n*/\nexport type Primitive<T> = Equal<T, PrimitiveMain<T>> extends true\n? T\n: PrimitiveMain<T>;\n\ntype Equal<X, Y> = X extends Y ? (Y extends X ? true : false) : false;\n\ntype PrimitiveMain<Instance> = Instance extends [never]\n? never // (special trick for jsonable | null) type\n: ValueOf<Instance> extends bigint\n? never\n: ValueOf<Instance> extends boolean | number | string\n? ValueOf<Instance>\n: Instance extends Function\n? never\n: ValueOf<Instance> extends object\n? Instance extends object\n? Instance extends NativeClass\n? {}\n: Instance extends IJsonable<infer Raw>\n? ValueOf<Raw> extends object\n? Raw extends object\n? PrimitiveObject<Raw> // object would be primitified\n: never // cannot be\n: ValueOf<Raw> // atomic value\n: PrimitiveObject<Instance> // object would be primitified\n: never // cannot be\n: ValueOf<Instance>;\n\ntype PrimitiveObject<Instance extends object> = Instance extends Array<infer T>\n? IsTuple<Instance> extends true\n? PrimitiveTuple<Instance>\n: PrimitiveMain<T>[]\n: {\n[P in keyof Instance]: PrimitiveMain<Instance[P]>;\n};\n\ntype PrimitiveTuple<T extends readonly any[]> = T extends []\n? []\n: T extends [infer F]\n? [PrimitiveMain<F>]\n: T extends [infer F, ...infer Rest extends readonly any[]]\n? [PrimitiveMain<F>, ...PrimitiveTuple<Rest>]\n: T extends [(infer F)?]\n? [PrimitiveMain<F>?]\n: T extends [(infer F)?, ...infer Rest extends readonly any[]]\n? [PrimitiveMain<F>?, ...PrimitiveTuple<Rest>]\n: [];\n\ntype ValueOf<Instance> = IsValueOf<Instance, Boolean> extends true\n? boolean\n: IsValueOf<Instance, Number> extends true\n? number\n: IsValueOf<Instance, String> extends true\n? string\n: Instance;\n\ntype NativeClass =\n| Set<any>\n| Map<any, any>\n| WeakSet<any>\n| WeakMap<any, any>\n| Uint8Array\n| Uint8ClampedArray\n| Uint16Array\n| Uint32Array\n| BigUint64Array\n| Int8Array\n| Int16Array\n| Int32Array\n| BigInt64Array\n| Float32Array\n| Float64Array\n| ArrayBuffer\n| SharedArrayBuffer\n| DataView;\n\ntype IsTuple<T extends readonly any[] | { length: number }> = [T] extends [\nnever,\n]\n? false\n: T extends readonly any[]\n? number extends T[\"length\"]\n? false\n: true\n: false;\n\ntype IsValueOf<Instance, Object extends IValueOf<any>> = Instance extends Object\n? Object extends IValueOf<infer U>\n? Instance extends U\n? false\n: true // not Primitive, but Object\n: false // cannot be\n: false;\n\ninterface IValueOf<T> {\nvalueOf(): T;\n}\n\ninterface IJsonable<T> {\ntoJSON(): T;\n}\n\n\nType safe JSON parser.Unlike native JSON.parse() function which returns any typed instance without type checking, typia.json.assertParse<T>() function validates instance type after the parsing. If the parsed value is not following the promised type T, it throws TypeGuardError with the first type error info.If you want to know every type error infos detaily, you can use typia.json.validateParse<T>() function instead. Otherwise, you just only want to know whether the parsed value is following the type T or not, just call typia.json.isParse<T>() function.\ntypia.json.isParse<T>(): JSON.parse() + typia.is<T>()\ntypia.json.assertParse<T>(): JSON.parse() + typia.assert<T>()\ntypia.json.validateParse<T>(): JSON.parse() + typia.validate<T>()\n\nLook at the below code, then you may understand how the typia.json.assertParse<T>() function works.\n\n\nimport typia, { tags } from \"typia\";\n\nconst json: string = JSON.stringify(typia.random<IMember>());\nconst parsed: IMember = typia.json.assertParse<IMember>(json);\n\nconsole.log(json === JSON.stringify(parsed)); // true\n\ninterface IMember {\nid: string & tags.Format<\"uuid\">;\nemail: string & tags.Format<\"email\">;\nage: number\n& tags.Type<\"uint32\">\n& tags.ExclusiveMinimum<19>\n& tags.Maximum<100>;\n}\n\n\n\n\"use strict\";\nvar __importDefault =\n(this && this.__importDefault) ||\nfunction (mod) {\nreturn mod && mod.__esModule ? mod : { default: mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst typia_1 = __importDefault(require(\"typia\"));\nconst json = JSON.stringify(\n((generator) => {\nconst $generator = typia_1.default.random.generator;\nconst $ro0 = (_recursive = false, _depth = 0) => ({\nid:\n(generator?.customs ?? $generator.customs)?.string?.([\n{\nname: 'Format<\"uuid\">',\nkind: \"format\",\nvalue: \"uuid\",\n},\n]) ?? (generator?.uuid ?? $generator.uuid)(),\nemail:\n(generator?.customs ?? $generator.customs)?.string?.([\n{\nname: 'Format<\"email\">',\nkind: \"format\",\nvalue: \"email\",\n},\n]) ?? (generator?.email ?? $generator.email)(),\nage:\n(generator?.customs ?? $generator.customs)?.number?.([\n{\nname: 'Type<\"uint32\">',\nkind: \"type\",\nvalue: \"uint32\",\n},\n{\nname: \"ExclusiveMinimum<19>\",\nkind: \"exclusiveMinimum\",\nvalue: 19,\n},\n{\nname: \"Maximum<100>\",\nkind: \"maximum\",\nvalue: 100,\n},\n]) ?? (generator?.integer ?? $generator.integer)(19, 100),\n});\nreturn $ro0();\n})(),\n);\nconst parsed = ((input) => {\nconst assert = (input) => {\nconst __is = (input) => {\nreturn (\n\"object\" === typeof input &&\nnull !== input &&\n\"string\" === typeof input.id &&\n/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\ninput.id,\n) &&\n\"string\" === typeof input.email &&\n/^(([^<>()[].,;:s@\"]+(.[^<>()[].,;:s@\"]+)*)|(\".+\"))@(([^<>()[].,;:s@\"]+.)+[^<>()[].,;:s@\"]{2,})$/i.test(\ninput.email,\n) &&\n\"number\" === typeof input.age &&\nMath.floor(input.age) === input.age &&\n0 <= input.age &&\ninput.age <= 4294967295 &&\n19 < input.age &&\ninput.age <= 100\n);\n};\nif (false === __is(input))\n((input, _path, _exceptionable = true) => {\nconst $guard = typia_1.default.json.assertParse.guard;\nconst $ao0 = (input, _path, _exceptionable = true) =>\n((\"string\" === typeof input.id &&\n(/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\ninput.id,\n) ||\n$guard(_exceptionable, {\npath: _path + \".id\",\nexpected: 'string & Format<\"uuid\">',\nvalue: input.id,\n}))) ||\n$guard(_exceptionable, {\npath: _path + \".id\",\nexpected: '(string & Format<\"uuid\">)',\nvalue: input.id,\n})) &&\n((\"string\" === typeof input.email &&\n(/^(([^<>()[].,;:s@\"]+(.[^<>()[].,;:s@\"]+)*)|(\".+\"))@(([^<>()[].,;:s@\"]+.)+[^<>()[].,;:s@\"]{2,})$/i.test(\ninput.email,\n) ||\n$guard(_exceptionable, {\npath: _path + \".email\",\nexpected: 'string & Format<\"email\">',\nvalue: input.email,\n}))) ||\n$guard(_exceptionable, {\npath: _path + \".email\",\nexpected: '(string & Format<\"email\">)',\nvalue: input.email,\n})) &&\n((\"number\" === typeof input.age &&\n((Math.floor(input.age) === input.age &&\n0 <= input.age &&\ninput.age <= 4294967295) ||\n$guard(_exceptionable, {\npath: _path + \".age\",\nexpected: 'number & Type<\"uint32\">',\nvalue: input.age,\n})) &&\n(19 < input.age ||\n$guard(_exceptionable, {\npath: _path + \".age\",\nexpected: \"number & ExclusiveMinimum<19>\",\nvalue: input.age,\n})) &&\n(input.age <= 100 ||\n$guard(_exceptionable, {\npath: _path + \".age\",\nexpected: \"number & Maximum<100>\",\nvalue: input.age,\n}))) ||\n$guard(_exceptionable, {\npath: _path + \".age\",\nexpected:\n'(number & Type<\"uint32\"> & ExclusiveMinimum<19> & Maximum<100>)',\nvalue: input.age,\n}));\nreturn (\n(((\"object\" === typeof input && null !== input) ||\n$guard(true, {\npath: _path + \"\",\nexpected: \"IMember\",\nvalue: input,\n})) &&\n$ao0(input, _path + \"\", true)) ||\n$guard(true, {\npath: _path + \"\",\nexpected: \"IMember\",\nvalue: input,\n})\n);\n})(input, \"$input\", true);\nreturn input;\n};\ninput = JSON.parse(input);\nreturn assert(input);\n})(json);\nconsole.log(json === JSON.stringify(parsed)); // true\n\n\n\n/**\n* Primitive type of JSON.\n*\n* `Primitive<T>` is a TMP (Type Meta Programming) type which converts\n* its argument as a primitive type within framework JSON.\n*\n* If the target argument is a built-in class which returns its origin primitive type\n* through the `valueOf()` method like the `String` or `Number`, its return type would\n* be the `string` or `number`. Otherwise, the built-in class does not have the\n* `valueOf()` method, the return type would be an empty object (`{}`).\n*\n* Otherwise, the target argument is a type of custom class, all of its custom method\n* would be erased and its prototype would be changed to the primitive `object`.\n* Therefore, return type of the TMP type finally be the primitive object.\n*\n* In addition, if the target argument is a type of custom class and it has a special\n* method `toJSON()`, return type of this `Primitive` would be not `Primitive<Instance>`\n* but `Primitive<ReturnType<Instance.toJSON>>`.\n*\n* Before                  | After\n* ------------------------|----------------------------------------\n* `Boolean`               | `boolean`\n* `Number`                | `number`\n* `String`                | `string`\n* `Class`                 | `object`\n* `Class` with `toJSON()` | `Primitive<ReturnType<Class.toJSON>>`\n* Native Class            | `{}`\n* Others                  | No change\n*\n* @template Instance Target argument type.\n* @author Jeongho Nam - https://github.com/samchon\n* @author Kyungsu Kang - https://github.com/kakasoo\n* @author Michael - https://github.com/8471919\n*/\nexport type Primitive<T> = Equal<T, PrimitiveMain<T>> extends true\n? T\n: PrimitiveMain<T>;\n\ntype Equal<X, Y> = X extends Y ? (Y extends X ? true : false) : false;\n\ntype PrimitiveMain<Instance> = Instance extends [never]\n? never // (special trick for jsonable | null) type\n: ValueOf<Instance> extends bigint\n? never\n: ValueOf<Instance> extends boolean | number | string\n? ValueOf<Instance>\n: Instance extends Function\n? never\n: ValueOf<Instance> extends object\n? Instance extends object\n? Instance extends NativeClass\n? {}\n: Instance extends IJsonable<infer Raw>\n? ValueOf<Raw> extends object\n? Raw extends object\n? PrimitiveObject<Raw> // object would be primitified\n: never // cannot be\n: ValueOf<Raw> // atomic value\n: PrimitiveObject<Instance> // object would be primitified\n: never // cannot be\n: ValueOf<Instance>;\n\ntype PrimitiveObject<Instance extends object> = Instance extends Array<infer T>\n? IsTuple<Instance> extends true\n? PrimitiveTuple<Instance>\n: PrimitiveMain<T>[]\n: {\n[P in keyof Instance]: PrimitiveMain<Instance[P]>;\n};\n\ntype PrimitiveTuple<T extends readonly any[]> = T extends []\n? []\n: T extends [infer F]\n? [PrimitiveMain<F>]\n: T extends [infer F, ...infer Rest extends readonly any[]]\n? [PrimitiveMain<F>, ...PrimitiveTuple<Rest>]\n: T extends [(infer F)?]\n? [PrimitiveMain<F>?]\n: T extends [(infer F)?, ...infer Rest extends readonly any[]]\n? [PrimitiveMain<F>?, ...PrimitiveTuple<Rest>]\n: [];\n\ntype ValueOf<Instance> = IsValueOf<Instance, Boolean> extends true\n? boolean\n: IsValueOf<Instance, Number> extends true\n? number\n: IsValueOf<Instance, String> extends true\n? string\n: Instance;\n\ntype NativeClass =\n| Set<any>\n| Map<any, any>\n| WeakSet<any>\n| WeakMap<any, any>\n| Uint8Array\n| Uint8ClampedArray\n| Uint16Array\n| Uint32Array\n| BigUint64Array\n| Int8Array\n| Int16Array\n| Int32Array\n| BigInt64Array\n| Float32Array\n| Float64Array\n| ArrayBuffer\n| SharedArrayBuffer\n| DataView;\n\ntype IsTuple<T extends readonly any[] | { length: number }> = [T] extends [\nnever,\n]\n? false\n: T extends readonly any[]\n? number extends T[\"length\"]\n? false\n: true\n: false;\n\ntype IsValueOf<Instance, Object extends IValueOf<any>> = Instance extends Object\n? Object extends IValueOf<infer U>\n? Instance extends U\n? false\n: true // not Primitive, but Object\n: false // cannot be\n: false;\n\ninterface IValueOf<T> {\nvalueOf(): T;\n}\n\ninterface IJsonable<T> {\ntoJSON(): T;\n}","reusable-functions#Reusable functions":"export namespace json {\nexport function createIsParse<T>(): (\ninput: string\n) => Primitive<T> | null;\nexport function createAssertParse<T>(): (\ninput: string\n) => Primitive<T>;\nexport function createValidateParse<T>(): (\ninput: string\n) => IValidation<Primitive<T>>;\n}\n\n\n\nexport class TypeGuardError extends Error {\npublic readonly method: string;\npublic readonly path: string | undefined;\npublic readonly expected: string;\npublic readonly value: any;\n}\n\n\n\nexport type IValidation<T> =\n| IValidation.ISuccess<T>\n| IValidation.IFailure;\nexport namespace IValidation {\nexport interface ISuccess<T> {\nsuccess: true;\ndata: T;\n}\nexport interface IFailure {\nsuccess: false;\nerrors: IError[];\n}\nexport interface IError {\npath: string;\nexpected: string;\nvalue: any;\n}\n}\n\n\nReusable typia.json.isParse<T>() function generators.If you repeat to call typia.json.isParse<T>() function on the same type, size of JavaScript files would be larger because of duplicated AOT compilation. To prevent it, you can generate reusable function through typia.createIsParse<T>() function.Just look at the code below, then you may understand how to use it.\n\n\nimport typia, { tags } from \"typia\";\n\nexport const parseMember = typia.json.createIsParse<IMember>();\n\ninterface IMember {\nid: string & tags.Format<\"uuid\">;\nemail: string & tags.Format<\"email\">;\nage: number\n& tags.Type<\"uint32\">\n& tags.ExclusiveMinimum<19>\n& tags.Maximum<100>;\n}\n\n\n\n\"use strict\";\nvar __importDefault =\n(this && this.__importDefault) ||\nfunction (mod) {\nreturn mod && mod.__esModule ? mod : { default: mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseMember = void 0;\nconst typia_1 = __importDefault(require(\"typia\"));\nconst parseMember = (input) => {\nconst is = (input) => {\nreturn (\n\"object\" === typeof input &&\nnull !== input &&\n\"string\" === typeof input.id &&\n/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\ninput.id,\n) &&\n\"string\" === typeof input.email &&\n/^(([^<>()[].,;:s@\"]+(.[^<>()[].,;:s@\"]+)*)|(\".+\"))@(([^<>()[].,;:s@\"]+.)+[^<>()[].,;:s@\"]{2,})$/i.test(\ninput.email,\n) &&\n\"number\" === typeof input.age &&\nMath.floor(input.age) === input.age &&\n0 <= input.age &&\ninput.age <= 4294967295 &&\n19 < input.age &&\ninput.age <= 100\n);\n};\ninput = JSON.parse(input);\nreturn is(input) ? input : null;\n};\nexports.parseMember = parseMember;"}},"/docs/json/schema":{"title":"Schema","data":{"":"","application-function#application() function":"export namespace json {\nexport function application<\nSchemas extends unknown[],\nPurpose extends \"ajv\" | \"swagger\",\n>(): IJsonApplication;\n}\n\n\n\nexport interface IJsonApplication {\nschemas: IJsonSchema[];\ncomponents: IJsonComponents;\npurpose: \"swagger\" | \"ajv\";\n}\n\n\n\nexport interface IJsonComponents {\nschemas: Record<string, IJsonComponents.IObject>;\n}\nexport namespace IJsonComponents {\nexport interface IObject {\n$id?: string;\n$recursiveAnchor?: boolean;\n\ntype: \"object\";\nnullable: boolean;\n\nproperties: Record<string, IJsonSchema>;\npatternProperties?: Record<string, IJsonSchema>;\nadditionalProperties?: IJsonSchema;\n\nrequired?: string[];\ndescription?: string;\n\"x-typia-jsDocTags\"?: IJsDocTagInfo[];\n\"x-typia-patternProperties\"?: Record<string, IJsonSchema>;\n\"x-typia-additionalProperties\"?: IJsonSchema;\n}\n}\n\n\n\nexport type IJsonSchema = IJsonSchema.NotUnknown | IJsonSchema.IUnknown;\nexport namespace IJsonSchema {\nexport type NotUnknown =\n| IEnumeration<\"boolean\">\n| IEnumeration<\"number\">\n| IEnumeration<\"string\">\n| IBoolean\n| IInteger\n| INumber\n| IString\n| IArray\n| ITuple\n| IOneOf\n| IReference\n| IRecursiveReference\n| INullOnly;\n\n/* -----------------------------------------------------------\nATOMICS\n----------------------------------------------------------- */\nexport interface IEnumeration<\nLiteral extends Exclude<Atomic.Literal, \"bigint\">,\n> extends IAtomic<Literal> {\nenum: Array<Atomic.Mapper[Literal]>;\n}\nexport interface IAtomic<Literal extends Exclude<Atomic.Literal, \"bigint\">>\nextends ISignificant<Literal> {\ndefault?: Atomic.Mapper[Literal];\n}\nexport interface IString extends IAtomic<\"string\"> {\n/**\n* @type uint\n*/\nminLength?: number;\n/**\n* @type uint\n*/\nmaxLength?: number;\npattern?: string;\nformat?: string;\n}\nexport interface INumber extends IAtomic<\"number\"> {\nminimum?: number;\nmaximum?: number;\nexclusiveMinimum?: boolean;\nexclusiveMaximum?: boolean;\nmultipleOf?: number;\n}\nexport interface IInteger extends IAtomic<\"integer\"> {\n/**\n* @type int\n*/\nminimum?: number;\n/**\n* @type int\n*/\nmaximum?: number;\nexclusiveMinimum?: boolean;\nexclusiveMaximum?: boolean;\n/**\n* @type int\n*/\nmultipleOf?: number;\n}\nexport interface IBoolean extends IAtomic<\"boolean\"> {}\n\n/* -----------------------------------------------------------\nOBJECTS\n----------------------------------------------------------- */\nexport interface IArray extends ISignificant<\"array\"> {\nitems: IJsonSchema;\n/**\n* @type uint\n*/\nminItems?: number;\n/**\n* @type uint\n*/\nmaxItems?: number;\n\"x-typia-tuple\"?: ITuple;\n}\nexport interface ITuple extends ISignificant<\"array\"> {\nitems: IJsonSchema[];\n}\nexport interface IReference extends IAttribute {\n$ref: string;\n}\nexport interface IRecursiveReference extends IAttribute {\n$recursiveRef: string;\n}\nexport interface INullOnly extends IAttribute {\ntype: \"null\";\n}\n\n/* -----------------------------------------------------------\nMISCELLANEOUS\n----------------------------------------------------------- */\nexport interface IOneOf extends IAttribute {\noneOf: IJsonSchema[];\n}\nexport interface IUnknown {\ntype: undefined;\n}\n\nexport interface ISignificant<Literal extends string> extends IAttribute {\ntype: Literal;\nnullable: boolean;\n}\nexport interface IAttribute {\ndeprecated?: boolean;\ntitle?: string;\ndescription?: string;\n\"x-typia-jsDocTags\"?: IJsDocTagInfo[];\n\"x-typia-required\"?: boolean;\n\"x-typia-rest\"?: boolean;\n}\n}\n\n\nJSON schema generator.\nDefinitions:\nIJsonApplication\nIJsonComponents\nIJsonSchema\n\n\n\nWhen you need JSON schema, do not write it by yourself, but just call typia.application() function.If you call the typia.application() with specialization of target Schemas, typia will analyze your Schemas and generate JSON schema definition in the compilation level. However, note that, JSON schema definitions of AJV and Swagger are a little bit different. Therefore, you have to consider which value to assign in the Purpose argument.\nSwagger can't express tuple type\nSwagger can't express pattern property\n\n\n\n\nimport typia, { tags } from \"typia\";\n\nexport const MemberSchema = typia.application<[IMember], \"ajv\">();\n\ninterface IMember {\n/**\n* Unique user ID generated by server.\n*/\nid: string & tags.Format<\"uuid\">;\n\n/**\n* Email address of the member.\n*/\nemail: string & tags.Format<\"email\">;\n\n/**\n* Age of the member.\n*\n* For reference, only adult can be a member.\n*/\nage: number\n& tags.Type<\"uint32\">\n& tags.ExclusiveMinimum<19>\n& tags.Maximum<100>;\n}\n\n\n\n\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\nreturn (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MemberSchema = void 0;\nconst typia_1 = __importDefault(require(\"typia\"));\nexports.MemberSchema = {\nschemas: [\n{\n$ref: \"#/components/schemas/IMember\"\n}\n],\ncomponents: {\nschemas: {\nIMember: {\n$id: \"#/components/schemas/IMember\",\ntype: \"object\",\nproperties: {\nid: {\ndescription: \"Unique user ID generated by server.\",\n\"x-typia-required\": true,\n\"x-typia-optional\": false\n},\nemail: {\ndescription: \"Email address of the member.\",\n\"x-typia-required\": true,\n\"x-typia-optional\": false\n},\nage: {\ndescription: \"Age of the member.\\n\\nFor reference, only adult can be a member.\",\n\"x-typia-required\": true,\n\"x-typia-optional\": false\n}\n},\nrequired: [\n\"id\",\n\"email\",\n\"age\"\n],\n\"x-typia-jsDocTags\": []\n}\n}\n},\npurpose: \"ajv\"\n};","specialization#Specialization":"You can utilize type tags (or validator's comment tags) to constructing special fields of JSON schema.If you write any comment on a property, it would fill the IJsonSchema.description value. Also, there're special comment tags only for JSON schema definition that are different with validator's comment tags like below.\n@deprecated\n@hidden\n@internal\n@title {string}\n@default {value}\n\nLet's see how those type tags, comment tags and description comments are working with example code.\n\n\nimport typia, { tags } from \"typia\";\n\nexport const SpecialTagSchema = typia.json.application<[Special], \"swagger\">();\n\ninterface Special {\n/**\n* Deprecated tags are just used for marking.\n*\n* @title Unsigned integer\n* @deprecated\n*/\ntype: number & tags.Type<\"int32\">;\n\n/**\n* Internal tagged property never be shown in JSON schema.\n*\n* It even doesn't be shown in other `typia` functions like `assert<T>()`.\n*\n* @internal\n*/\ninternal: number[];\n\n/**\n* Hidden tagged property never be shown in JSON schema.\n*\n* However, it would be shown in other `typia` functions like `stringify<T>()`.\n*\n* @hidden\n*/\nhidden: boolean;\n\n/**\n* You can limit the range of number.\n*\n* @exclusiveMinimum 19\n* @maximum 100\n* @default 30\n*/\nnumber?: number;\n\n/**\n* You can limit the length of string.\n*\n* Also, multiple range conditions are also possible.\n*/\nstring: string & (\n| (tags.MinLength<3> & tags.MaxLength<24>)\n| (tags.MinLength<40> & tags.MaxLength<100>)\n);\n\n/**\n* You can limit the pattern of string.\n*\n* @pattern ^[a-z]+$\n*/\npattern: string;\n\n/**\n* You can limit the format of string.\n*\n* @format date-time\n*/\nformat: string | null;\n\n/**\n* In the Array case, possible to restrict its elements.\n*/\narray: Array<string & tags.Format<\"uuid\">> & tags.MinItems<3>;\n}\n\n\n\n\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\nreturn (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SpecialTagSchema = void 0;\nconst typia_1 = __importDefault(require(\"typia\"));\nexports.SpecialTagSchema = {\nschemas: [\n{\n$ref: \"#/components/schemas/Special\"\n}\n],\ncomponents: {\nschemas: {\nSpecial: {\ntype: \"object\",\nproperties: {\ntype: {\ndeprecated: true,\ntitle: \"Unsigned integer\",\ndescription: \"Deprecated tags are just used for marking.\",\n\"x-typia-jsDocTags\": [\n{\nname: \"title\",\ntext: [\n{\ntext: \"Unsigned integer\",\nkind: \"text\"\n}\n]\n},\n{\nname: \"deprecated\"\n}\n],\n\"x-typia-required\": true,\n\"x-typia-optional\": false,\ntype: \"integer\"\n},\nnumber: {\ndescription: \"You can limit the range of number.\",\n\"x-typia-jsDocTags\": [\n{\nname: \"exclusiveMinimum\",\ntext: [\n{\ntext: \"19\",\nkind: \"text\"\n}\n]\n},\n{\nname: \"maximum\",\ntext: [\n{\ntext: \"100\",\nkind: \"text\"\n}\n]\n},\n{\nname: \"default\",\ntext: [\n{\ntext: \"30\",\nkind: \"text\"\n}\n]\n}\n],\n\"x-typia-required\": false,\n\"x-typia-optional\": true,\ntype: \"number\",\nminimum: 19,\nexclusiveMinimum: true,\nmaximum: 100,\n\"default\": 30\n},\nstring: {\noneOf: [\n{\ndescription: \"You can limit the length of string.\\n\\nAlso, multiple range conditions are also possible.\",\n\"x-typia-required\": true,\n\"x-typia-optional\": false,\ntype: \"string\",\nmaxLength: 24,\nminLength: 3\n},\n{\ndescription: \"You can limit the length of string.\\n\\nAlso, multiple range conditions are also possible.\",\n\"x-typia-required\": true,\n\"x-typia-optional\": false,\ntype: \"string\",\nmaxLength: 100,\nminLength: 40\n}\n],\ndescription: \"You can limit the length of string.\\n\\nAlso, multiple range conditions are also possible.\",\n\"x-typia-required\": true,\n\"x-typia-optional\": false\n},\npattern: {\ndescription: \"You can limit the pattern of string.\",\n\"x-typia-jsDocTags\": [\n{\nname: \"pattern\",\ntext: [\n{\ntext: \"^[a-z]+$\",\nkind: \"text\"\n}\n]\n}\n],\n\"x-typia-required\": true,\n\"x-typia-optional\": false,\ntype: \"string\",\npattern: \"^[a-z]+$\"\n},\nformat: {\ndescription: \"You can limit the format of string.\",\n\"x-typia-jsDocTags\": [\n{\nname: \"format\",\ntext: [\n{\ntext: \"date-time\",\nkind: \"text\"\n}\n]\n}\n],\n\"x-typia-required\": true,\n\"x-typia-optional\": false,\ntype: \"string\",\nformat: \"date-time\",\nnullable: true\n},\narray: {\ndescription: \"In the Array case, possible to restrict its elements.\",\n\"x-typia-required\": true,\n\"x-typia-optional\": false,\ntype: \"array\",\nitems: {\ndescription: \"In the Array case, possible to restrict its elements.\",\n\"x-typia-required\": true,\n\"x-typia-optional\": false,\ntype: \"string\",\nformat: \"uuid\"\n},\nminItems: 3\n}\n},\nnullable: false,\nrequired: [\n\"type\",\n\"string\",\n\"pattern\",\n\"format\",\n\"array\"\n],\n\"x-typia-jsDocTags\": []\n}\n}\n},\npurpose: \"swagger\"\n};","restrictions#Restrictions":"JSON schema does not support bigint type.So if you use bigint type in one of your onetarget schemas, typia will make compile error like below.\n\n\nimport typia, { tags } from \"typia\";\n\ninterface Something {\nbigint: bigint;\narray: bigint[];\nnested: Nested;\n}\ninterface Nested {\nuint64: bigint & tags.Type<\"uint64\">;\n}\n\ntypia.json.application<[Something], \"ajv\">();\n\n\n\nmain.ts:12:1 - error TS(typia.json.application): unsupported type detected\n\n- Something.bigint: bigint\n- JSON does not support bigint type.\n\n- Something.array: bigint\n- JSON does not support bigint type.\n\n- Nested.uint64: (bigint & Type<\"uint64\">)\n- JSON does not support bigint type.\n\n\nAlso, if you put any type of native classes like Map or Uint8Array, it would be considered as an empty object. By the way, only Date class is exceptional, and it would be considered as string & Format<\"date-time\"> type like below.\n\n\nimport typia from \"typia\";\n\ninterface Native {\ndate: Date;\nbytes: Uint8Array;\nmap: Map<string, number>;\n}\ntypia.json.application<[Native], \"ajv\">();\n\n\n\n\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\nreturn (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst typia_1 = __importDefault(require(\"typia\"));\n({\nschemas: [\n{\n$ref: \"#/components/schemas/Native\"\n}\n],\ncomponents: {\nschemas: {\nNative: {\n$id: \"#/components/schemas/Native\",\ntype: \"object\",\nproperties: {\ndate: {\n\"x-typia-required\": true,\n\"x-typia-optional\": false,\ntype: \"string\",\nformat: \"date-time\"\n},\nbytes: {\n\"x-typia-required\": true,\n\"x-typia-optional\": false,\n$ref: \"#/components/objects/Uint8Array\"\n},\nmap: {\n\"x-typia-required\": true,\n\"x-typia-optional\": false,\n$ref: \"#/components/objects/Map\"\n}\n},\nrequired: [\n\"date\",\n\"bytes\",\n\"map\"\n],\n\"x-typia-jsDocTags\": []\n},\nUint8Array: {\ntype: \"object\",\n$id: \"#/components/objects/Uint8Array\",\nproperties: {}\n},\nMap: {\ntype: \"object\",\n$id: \"#/components/objects/Map\",\nproperties: {}\n}\n}\n},\npurpose: \"ajv\"\n});"}},"/docs/json/stringify":{"title":"Stringify","data":{"":"","stringify-functions#stringify() functions":"export namespace json {\nexport function stringify<T>(input: T): string;\nexport function isStringify<T>(input: unknown | T): string | null;\nexport function assertStringify<T>(input: unknown | T): string;\nexport function validateStringify<T>(input: unknown | T): IValidation<string>;\n}\n\n\n\nexport class TypeGuardError extends Error {\npublic readonly method: string;\npublic readonly path: string | undefined;\npublic readonly expected: string;\npublic readonly value: any;\n}\n\n\n\nexport type IValidation<T> =\n| IValidation.ISuccess<T>\n| IValidation.IFailure;\nexport namespace IValidation {\nexport interface ISuccess<T> {\nsuccess: true;\ndata: T;\n}\nexport interface IFailure {\nsuccess: false;\nerrors: IError[];\n}\nexport interface IError {\npath: string;\nexpected: string;\nvalue: any;\n}\n}\n\n\nYou can boost up JSON serialization speed just by calling typia.json.stringify<T>() function. Also, you even can ensure type safety of JSON serialization by calling other functions like typia.json.isStringify() and typia.json.assertStringify() functions.As typia.json.stringify<T>() function writes dedicated JSON serialization code only for the target type T, its performance is much faster than native JSON.stringify() function. However, because of the dedicated optimal JSON serialization code, when wrong typed data comes, unexpected error be occured.Instead, typia supports type safe JSON serialization functions like typia.json.isStringify(). The typia.json.isStringify() is a combination function of typia.is<T>() and typia.json.stringify<T>() function. It checks whether the input value is valid for the target type T or not first, and operate JSON serialization later. If the input value is not matched with the type T, it returns null value.\ntypia.json.isStringify(): typia.is<T>() + typia.json.stringify<T>()\ntypia.json.assertStringify(): typia.assert<T>() + typia.json.stringify<T>()\ntypia.json.validateStringify(): typia.validate<T>() + typia.json.stringify<T>()\n\n\n\n\n\nAOT compliation\ntypia.json.isStringify() and other similar functions are still much faster than native JSON.stringify() function, even though they include type checking process. This is the power of AOT compilation, writing optimal dedicated code by analyzing TypeScript type, in the compilation level.\n\n\n\nimport typia, { tags } from \"typia\";\n\nconst department: IDepartment = typia.random<IDepartment>();\nconst json: string | null = typia.json.isStringify(department);\n\nconsole.log(json); // not null, but string\n\ninterface IDepartment {\nid: string & tags.Format<\"uuid\">;\nname: string & tags.MinLength<3>;\nlimit: number & tags.Type<\"int32\">;\nclerks: IClerk[];\n}\ninterface IClerk {\nname: string;\nage: number\n& tags.Type<\"uint32\">\n& tags.ExclusiveMinimum<19>\n& tags.Maximum<100>;\nauthority: number;\njoined_at: string & tags.Format<\"date\">;\n}\n\n\n\n\"use strict\";\nvar __importDefault =\n(this && this.__importDefault) ||\nfunction (mod) {\nreturn mod && mod.__esModule ? mod : { default: mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst typia_1 = __importDefault(require(\"typia\"));\nconst department = ((generator) => {\nconst $generator = typia_1.default.random.generator;\nconst $ro0 = (_recursive = false, _depth = 0) => ({\nid:\n(generator?.customs ?? $generator.customs)?.string?.([\n{\nname: 'Format<\"uuid\">',\nkind: \"format\",\nvalue: \"uuid\",\n},\n]) ?? (generator?.uuid ?? $generator.uuid)(),\nname:\n(generator?.customs ?? $generator.customs)?.string?.([\n{\nname: \"MinLength<3>\",\nkind: \"minLength\",\nvalue: 3,\n},\n]) ??\n(generator?.string ?? $generator.string)(\n(generator?.integer ?? $generator.integer)(3, 25),\n),\nlimit:\n(generator?.customs ?? $generator.customs)?.number?.([\n{\nname: 'Type<\"int32\">',\nkind: \"type\",\nvalue: \"int32\",\n},\n]) ?? (generator?.integer ?? $generator.integer)(0, 100),\nclerks: (generator?.array ?? $generator.array)(() =>\n$ro1(_recursive, _recursive ? 1 + _depth : _depth),\n),\n});\nconst $ro1 = (_recursive = false, _depth = 0) => ({\nname:\n(generator?.customs ?? $generator.customs)?.string?.([]) ??\n(generator?.string ?? $generator.string)(),\nage:\n(generator?.customs ?? $generator.customs)?.number?.([\n{\nname: 'Type<\"uint32\">',\nkind: \"type\",\nvalue: \"uint32\",\n},\n{\nname: \"ExclusiveMinimum<19>\",\nkind: \"exclusiveMinimum\",\nvalue: 19,\n},\n{\nname: \"Maximum<100>\",\nkind: \"maximum\",\nvalue: 100,\n},\n]) ?? (generator?.integer ?? $generator.integer)(19, 100),\nauthority:\n(generator?.customs ?? $generator.customs)?.number?.([]) ??\n(generator?.number ?? $generator.number)(0, 100),\njoined_at:\n(generator?.customs ?? $generator.customs)?.string?.([\n{\nname: 'Format<\"date\">',\nkind: \"format\",\nvalue: \"date\",\n},\n]) ?? (generator?.date ?? $generator.date)(),\n});\nreturn $ro0();\n})();\nconst json = ((input) => {\nconst is = (input) => {\nconst $io0 = (input) =>\n\"string\" === typeof input.id &&\n/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\ninput.id,\n) &&\n\"string\" === typeof input.name &&\n3 <= input.name.length &&\n\"number\" === typeof input.limit &&\nMath.floor(input.limit) === input.limit &&\n-2147483648 <= input.limit &&\ninput.limit <= 2147483647 &&\nArray.isArray(input.clerks) &&\ninput.clerks.every(\n(elem) =>\n\"object\" === typeof elem && null !== elem && $io1(elem),\n);\nconst $io1 = (input) =>\n\"string\" === typeof input.name &&\n\"number\" === typeof input.age &&\nMath.floor(input.age) === input.age &&\n0 <= input.age &&\ninput.age <= 4294967295 &&\n19 < input.age &&\ninput.age <= 100 &&\n\"number\" === typeof input.authority &&\n!Number.isNaN(input.authority) &&\n\"string\" === typeof input.joined_at &&\n/^(d{4})-(d{2})-(d{2})$/.test(input.joined_at);\nreturn \"object\" === typeof input && null !== input && $io0(input);\n};\nconst stringify = (input) => {\nconst $io1 = (input) =>\n\"string\" === typeof input.name &&\n\"number\" === typeof input.age &&\nMath.floor(input.age) === input.age &&\n0 <= input.age &&\ninput.age <= 4294967295 &&\n19 < input.age &&\ninput.age <= 100 &&\n\"number\" === typeof input.authority &&\n\"string\" === typeof input.joined_at &&\n/^(d{4})-(d{2})-(d{2})$/.test(input.joined_at);\nconst $string = typia_1.default.json.isStringify.string;\nconst $so0 = (input) =>\n`{\"id\":${$string(input.id)},\"name\":${$string(input.name)},\"limit\":${\ninput.limit\n},\"clerks\":${`[${input.clerks\n.map(\n(elem) =>\n`{\"name\":${$string(elem.name)},\"age\":${\nelem.age\n},\"authority\":${elem.authority},\"joined_at\":${$string(\nelem.joined_at,\n)}}`,\n)\n.join(\",\")}]`}}`;\nreturn $so0(input);\n};\nreturn is(input) ? stringify(input) : null;\n})(department);\nconsole.log(json); // not null, but string","reusable-functions#Reusable functions":"export namespace json {\nexport function createStringify<T>: (input: T) => string;\nexport function createIsStringify<T>: (\ninput: unknown | T\n) => string | null;\nexport function createAssertStringify<T>: (\ninput: unknown | T\n) => string;\nexport function createValidateStringify<T>: (\ninput: unknown | T\n) => IValidation<string>;\n}\n\n\n\nexport class TypeGuardError extends Error {\npublic readonly method: string;\npublic readonly path: string | undefined;\npublic readonly expected: string;\npublic readonly value: any;\n}\n\n\n\nexport type IValidation<T> =\n| IValidation.ISuccess<T>\n| IValidation.IFailure;\nexport namespace IValidation {\nexport interface ISuccess<T> {\nsuccess: true;\ndata: T;\n}\nexport interface IFailure {\nsuccess: false;\nerrors: IError[];\n}\nexport interface IError {\npath: string;\nexpected: string;\nvalue: any;\n}\n}\n\n\nReusable typia.json.stringify<T>() function generators.If you repeat to call typia.json.stringify<T>() function on the same type, size of JavaScript files would be larger because of duplicated AOT compilation. To prevent it, you can generate reusable function through typia.json.createStringify<T>() function.Just look at the code below, then you may understand how to use it.\n\n\nimport typia, { tags } from \"typia\";\n\nexport const assertDepartment = typia.json.createAssertStringify<IDepartment>();\n\ninterface IDepartment {\nid: string & tags.Format<\"uuid\">;\nname: string & tags.MinLength<3>;\nlimit: number & tags.Type<\"int32\">;\nclerks: IClerk[];\n}\ninterface IClerk {\nname: string;\nage: number\n& tags.Type<\"uint32\">\n& tags.ExclusiveMinimum<19>\n& tags.Maximum<100>;\nauthority: number;\njoined_at: string & tags.Format<\"date\">;\n}\n\n\n\n\"use strict\";\nvar __importDefault =\n(this && this.__importDefault) ||\nfunction (mod) {\nreturn mod && mod.__esModule ? mod : { default: mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.assertDepartment = void 0;\nconst typia_1 = __importDefault(require(\"typia\"));\nconst assertDepartment = (input) => {\nconst assert = (input) => {\nconst __is = (input) => {\nconst $io0 = (input) =>\n\"string\" === typeof input.id &&\n/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\ninput.id,\n) &&\n\"string\" === typeof input.name &&\n3 <= input.name.length &&\n\"number\" === typeof input.limit &&\nMath.floor(input.limit) === input.limit &&\n-2147483648 <= input.limit &&\ninput.limit <= 2147483647 &&\nArray.isArray(input.clerks) &&\ninput.clerks.every(\n(elem) =>\n\"object\" === typeof elem && null !== elem && $io1(elem),\n);\nconst $io1 = (input) =>\n\"string\" === typeof input.name &&\n\"number\" === typeof input.age &&\nMath.floor(input.age) === input.age &&\n0 <= input.age &&\ninput.age <= 4294967295 &&\n19 < input.age &&\ninput.age <= 100 &&\n\"number\" === typeof input.authority &&\n!Number.isNaN(input.authority) &&\n\"string\" === typeof input.joined_at &&\n/^(d{4})-(d{2})-(d{2})$/.test(input.joined_at);\nreturn \"object\" === typeof input && null !== input && $io0(input);\n};\nif (false === __is(input))\n((input, _path, _exceptionable = true) => {\nconst $guard = typia_1.default.json.createAssertStringify.guard;\nconst $ao0 = (input, _path, _exceptionable = true) =>\n((\"string\" === typeof input.id &&\n(/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\ninput.id,\n) ||\n$guard(_exceptionable, {\npath: _path + \".id\",\nexpected: 'string & Format<\"uuid\">',\nvalue: input.id,\n}))) ||\n$guard(_exceptionable, {\npath: _path + \".id\",\nexpected: '(string & Format<\"uuid\">)',\nvalue: input.id,\n})) &&\n((\"string\" === typeof input.name &&\n(3 <= input.name.length ||\n$guard(_exceptionable, {\npath: _path + \".name\",\nexpected: \"string & MinLength<3>\",\nvalue: input.name,\n}))) ||\n$guard(_exceptionable, {\npath: _path + \".name\",\nexpected: \"(string & MinLength<3>)\",\nvalue: input.name,\n})) &&\n((\"number\" === typeof input.limit &&\n((Math.floor(input.limit) === input.limit &&\n-2147483648 <= input.limit &&\ninput.limit <= 2147483647) ||\n$guard(_exceptionable, {\npath: _path + \".limit\",\nexpected: 'number & Type<\"int32\">',\nvalue: input.limit,\n}))) ||\n$guard(_exceptionable, {\npath: _path + \".limit\",\nexpected: '(number & Type<\"int32\">)',\nvalue: input.limit,\n})) &&\n(((Array.isArray(input.clerks) ||\n$guard(_exceptionable, {\npath: _path + \".clerks\",\nexpected: \"Array<IClerk>\",\nvalue: input.clerks,\n})) &&\ninput.clerks.every(\n(elem, _index1) =>\n(((\"object\" === typeof elem && null !== elem) ||\n$guard(_exceptionable, {\npath:\n_path + \".clerks[\" + _index1 + \"]\",\nexpected: \"IClerk\",\nvalue: elem,\n})) &&\n$ao1(\nelem,\n_path + \".clerks[\" + _index1 + \"]\",\ntrue && _exceptionable,\n)) ||\n$guard(_exceptionable, {\npath: _path + \".clerks[\" + _index1 + \"]\",\nexpected: \"IClerk\",\nvalue: elem,\n}),\n)) ||\n$guard(_exceptionable, {\npath: _path + \".clerks\",\nexpected: \"Array<IClerk>\",\nvalue: input.clerks,\n}));\nconst $ao1 = (input, _path, _exceptionable = true) =>\n(\"string\" === typeof input.name ||\n$guard(_exceptionable, {\npath: _path + \".name\",\nexpected: \"string\",\nvalue: input.name,\n})) &&\n((\"number\" === typeof input.age &&\n((Math.floor(input.age) === input.age &&\n0 <= input.age &&\ninput.age <= 4294967295) ||\n$guard(_exceptionable, {\npath: _path + \".age\",\nexpected: 'number & Type<\"uint32\">',\nvalue: input.age,\n})) &&\n(19 < input.age ||\n$guard(_exceptionable, {\npath: _path + \".age\",\nexpected: \"number & ExclusiveMinimum<19>\",\nvalue: input.age,\n})) &&\n(input.age <= 100 ||\n$guard(_exceptionable, {\npath: _path + \".age\",\nexpected: \"number & Maximum<100>\",\nvalue: input.age,\n}))) ||\n$guard(_exceptionable, {\npath: _path + \".age\",\nexpected:\n'(number & Type<\"uint32\"> & ExclusiveMinimum<19> & Maximum<100>)',\nvalue: input.age,\n})) &&\n((\"number\" === typeof input.authority &&\n!Number.isNaN(input.authority)) ||\n$guard(_exceptionable, {\npath: _path + \".authority\",\nexpected: \"number\",\nvalue: input.authority,\n})) &&\n((\"string\" === typeof input.joined_at &&\n(/^(d{4})-(d{2})-(d{2})$/.test(input.joined_at) ||\n$guard(_exceptionable, {\npath: _path + \".joined_at\",\nexpected: 'string & Format<\"date\">',\nvalue: input.joined_at,\n}))) ||\n$guard(_exceptionable, {\npath: _path + \".joined_at\",\nexpected: '(string & Format<\"date\">)',\nvalue: input.joined_at,\n}));\nreturn (\n(((\"object\" === typeof input && null !== input) ||\n$guard(true, {\npath: _path + \"\",\nexpected: \"IDepartment\",\nvalue: input,\n})) &&\n$ao0(input, _path + \"\", true)) ||\n$guard(true, {\npath: _path + \"\",\nexpected: \"IDepartment\",\nvalue: input,\n})\n);\n})(input, \"$input\", true);\nreturn input;\n};\nconst stringify = (input) => {\nconst $io1 = (input) =>\n\"string\" === typeof input.name &&\n\"number\" === typeof input.age &&\nMath.floor(input.age) === input.age &&\n0 <= input.age &&\ninput.age <= 4294967295 &&\n19 < input.age &&\ninput.age <= 100 &&\n\"number\" === typeof input.authority &&\n\"string\" === typeof input.joined_at &&\n/^(d{4})-(d{2})-(d{2})$/.test(input.joined_at);\nconst $string = typia_1.default.json.createAssertStringify.string;\nconst $so0 = (input) =>\n`{\"id\":${$string(input.id)},\"name\":${$string(input.name)},\"limit\":${\ninput.limit\n},\"clerks\":${`[${input.clerks\n.map(\n(elem) =>\n`{\"name\":${$string(elem.name)},\"age\":${\nelem.age\n},\"authority\":${elem.authority},\"joined_at\":${$string(\nelem.joined_at,\n)}}`,\n)\n.join(\",\")}]`}}`;\nreturn $so0(input);\n};\nreturn stringify(assert(input));\n};\nexports.assertDepartment = assertDepartment;","performance#Performance":"Comparing JSON serialization speed with others, it is maximum 200x faster than class-transformer.For reference, class-transformer is the most famous library used in NestJS with class-validator. Also, fast-json-stringify is another famous one used in fastify. However, whether they are fast or slow, both of them require extra schema definition, that is different with TypeScript type. If you see the code below without experience of them, you may get shocked: how complicate and inefficient they are:\nfast-json-stringify requires JSON schema definition.\nclass-validator requires DTO class with decorator function calls.\n\n\nMeasured on Intel i5-1135g7, Surface Pro 8","server-performance#Server Performance":"Someone may ask:\nJSON serialization speed affects on the server performance?I think that the JSON serialization is just a tiny thing in the server side, isn't it?\nMy answer is, \"Yes, it affects on the server performance\".Most operations in NodeJS server are asynchronously executed in background thread, what are called \"event based non-blocking I/O model\". However, JSON serialization is a synchronous operation running on the main thread. Therefore, if the JSON serialization speed is slow, it makes the entire server program slow.I'll show you the benchmark result that, how JSON serizliation speed affects on the server performance.\nMeasured on Intel i5-1135g7, Surface Pro 8"}},"/docs/protobuf/encode":{"title":"Encode","data":{"":"","encode-functions#encode() functions":"export namespace protobuf {\nexport function encode<T>(buffer: Uint8Array): T;\nexport function isEncode<T>(buffer: Uint8Array): T | null;\nexport function assertEncode<T>(buffer: Uint8Array): T;\nexport function validateEncode<T>(buffer: Uint8Array): IValidation<T>;\n}\n\n\n\nexport class TypeGuardError extends Error {\npublic readonly method: string;\npublic readonly path: string | undefined;\npublic readonly expected: string;\npublic readonly value: any;\n}\n\n\n\nexport type IValidation<T> =\n| IValidation.ISuccess<T>\n| IValidation.IFailure;\nexport namespace IValidation {\nexport interface ISuccess<T> {\nsuccess: true;\ndata: T;\n}\nexport interface IFailure {\nsuccess: false;\nerrors: IError[];\n}\nexport interface IError {\npath: string;\nexpected: string;\nvalue: any;\n}\n}\n\n\nProtocol Buffer Encoder.You can easily convert a JavaScript object to a binary data of Protocol Buffer, without any extra Protocol Buffer Message Schema definition. typia.protobuf.encode<T>() function analyzes your type T, and generates a Protocol Buffer Message Schema internally. And then, it converts the input instance to the binary data of Protocol Buffer format.By the way, typia.protobuf.encode<T>() function does not validate the input value. It just believes user and input value, and converts to the Protocol Buffer binary data directly without any validation. By the way, if the input value was not validate, the encoded binary data never can be decoded. So, if you can't sure the input value type, you should use below functions instead.\ntypia.protobuf.isEncode<T>(): typia.is<T>() + typia.protobuf.encode<T>()\ntypia.protobuf.assertEncode<T>(): typia.assert<T>() + typia.protobuf.encode<T>()\ntypia.protobuf.validateEncode<T>(): typia.validate<T>() + typia.protobuf.encode<T>()\n\n\n\n\n\nAOT compliation\ntypia.protobuf.encode<T>() and other similar functions are still much faster than any other competitive libraries, even though they include type checking process. This is the power of AOT compilation, writing optimal dedicated code by analyzing TypeScript type, in the compilation level.\n\n\n\nimport typia, { tags } from \"typia\";\n\ninterface ICustomer {\nid: number & tags.Type<\"int32\">;\nemail: string & tags.Format<\"email\">;\nname: string;\npet: null | ICat | IDog;\nmemo: null | Map<string, string>;\nlogins: Array<ICustomerLogin>;\n}\ninterface ICat {\ntype: \"cat\";\nname: string;\nribbon: boolean;\n}\ninterface IDog {\ntype: \"dog\";\nname: string;\nhunt: boolean;\n}\ninterface ICustomerLogin {\nsuccess: boolean;\nhref: string & tags.Format<\"url\">;\nreferrer: string & tags.Format<\"url\">;\nip: string & (tags.Format<\"ipv4\"> | tags.Format<\"ipv6\">);\ntime: string & tags.Format<\"date-time\">;\n}\n\nconst customer: ICustomer = typia.random<ICustomer>();\ntypia.protobuf.encode<ICustomer>(customer);\n\n\n\n\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\nreturn (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst typia_1 = __importDefault(require(\"typia\"));\nconst customer = (generator => {\nconst $generator = typia_1.default.random.generator;\nconst $pick = typia_1.default.random.pick;\nconst $ro0 = (_recursive = false, _depth = 0) => ({\nid: (generator?.customs ?? $generator.customs)?.number?.([\n{\nname: \"Type<\\\"int32\\\">\",\nkind: \"type\",\nvalue: \"int32\",\n}\n]) ?? (generator?.integer ?? $generator.integer)(0, 100),\nemail: (generator?.customs ?? $generator.customs)?.string?.([\n{\nname: \"Format<\\\"email\\\">\",\nkind: \"format\",\nvalue: \"email\",\n}\n]) ?? (generator?.email ?? $generator.email)(),\nname: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),\npet: $pick([\n() => null,\n() => $ro1(_recursive, _recursive ? 1 + _depth : _depth),\n() => $ro2(_recursive, _recursive ? 1 + _depth : _depth)\n])(),\nmemo: $pick([\n() => null,\n() => new Map((generator?.array ?? $generator.array)(() => [\n(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),\n(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()\n]))\n])(),\nlogins: (generator?.array ?? $generator.array)(() => $ro3(_recursive, _recursive ? 1 + _depth : _depth))\n});\nconst $ro1 = (_recursive = false, _depth = 0) => ({\ntype: \"cat\",\nname: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),\nribbon: (generator?.boolean ?? $generator.boolean)()\n});\nconst $ro2 = (_recursive = false, _depth = 0) => ({\ntype: \"dog\",\nname: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),\nhunt: (generator?.boolean ?? $generator.boolean)()\n});\nconst $ro3 = (_recursive = false, _depth = 0) => ({\nsuccess: (generator?.boolean ?? $generator.boolean)(),\nhref: (generator?.customs ?? $generator.customs)?.string?.([\n{\nname: \"Format<\\\"url\\\">\",\nkind: \"format\",\nvalue: \"url\",\n}\n]) ?? (generator?.url ?? $generator.url)(),\nreferrer: (generator?.customs ?? $generator.customs)?.string?.([\n{\nname: \"Format<\\\"url\\\">\",\nkind: \"format\",\nvalue: \"url\",\n}\n]) ?? (generator?.url ?? $generator.url)(),\nip: $pick([\n() => (generator?.customs ?? $generator.customs)?.string?.([\n{\nname: \"Format<\\\"ipv4\\\">\",\nkind: \"format\",\nvalue: \"ipv4\",\n}\n]) ?? (generator?.ipv4 ?? $generator.ipv4)(),\n() => (generator?.customs ?? $generator.customs)?.string?.([\n{\nname: \"Format<\\\"ipv6\\\">\",\nkind: \"format\",\nvalue: \"ipv6\",\n}\n]) ?? (generator?.ipv6 ?? $generator.ipv6)()\n])(),\ntime: (generator?.customs ?? $generator.customs)?.string?.([\n{\nname: \"Format<\\\"date-time\\\">\",\nkind: \"format\",\nvalue: \"date-time\",\n}\n]) ?? (generator?.datetime ?? $generator.datetime)()\n});\nreturn $ro0();\n})();\n(input => {\nconst $throws = typia_1.default.protobuf.encode.throws;\nconst $Sizer = typia_1.default.protobuf.encode.Sizer;\nconst $Writer = typia_1.default.protobuf.encode.Writer;\nconst encoder = writer => {\nconst $peo0 = input => {\n// property \"id\";\nwriter.uint32(8);\nwriter.int32(input.id);\n// property \"email\";\nwriter.uint32(18);\nwriter.string(input.email);\n// property \"name\";\nwriter.uint32(26);\nwriter.string(input.name);\n// property \"pet\";\nif (null !== input.pet) {\nif (\"cat\" === input.pet.type)\nreturn (() => {\n// 4 -> ICat;\nwriter.uint32(34);\nwriter.fork();\n$peo1(input.pet);\nwriter.ldelim();\n})();\nelse if (\"dog\" === input.pet.type)\nreturn (() => {\n// 5 -> IDog;\nwriter.uint32(42);\nwriter.fork();\n$peo2(input.pet);\nwriter.ldelim();\n})();\nelse\n$throws({\nexpected: \"(ICat | IDog)\",\nvalue: input.pet\n});\n}\n// property \"memo\";\nif (null !== input.memo) {\nfor (const [key, value] of input.memo) {\nwriter.uint32(50);\nwriter.fork();\nwriter.uint32(10);\nwriter.string(key);\nwriter.uint32(18);\nwriter.string(value);\nwriter.ldelim();\n}\n}\n// property \"logins\";\nif (0 !== input.logins.length) {\nfor (const elem of input.logins) {\n// 7 -> ICustomerLogin;\nwriter.uint32(58);\nwriter.fork();\n$peo3(elem);\nwriter.ldelim();\n}\n}\n};\nconst $peo1 = input => {\n// property \"type\";\nwriter.uint32(10);\nwriter.string(input.type);\n// property \"name\";\nwriter.uint32(18);\nwriter.string(input.name);\n// property \"ribbon\";\nwriter.uint32(24);\nwriter.bool(input.ribbon);\n};\nconst $peo2 = input => {\n// property \"type\";\nwriter.uint32(10);\nwriter.string(input.type);\n// property \"name\";\nwriter.uint32(18);\nwriter.string(input.name);\n// property \"hunt\";\nwriter.uint32(24);\nwriter.bool(input.hunt);\n};\nconst $peo3 = input => {\n// property \"success\";\nwriter.uint32(8);\nwriter.bool(input.success);\n// property \"href\";\nwriter.uint32(18);\nwriter.string(input.href);\n// property \"referrer\";\nwriter.uint32(26);\nwriter.string(input.referrer);\n// property \"ip\";\nwriter.uint32(34);\nwriter.string(input.ip);\n// property \"time\";\nwriter.uint32(42);\nwriter.string(input.time);\n};\nconst $io1 = input => \"cat\" === input.type && \"string\" === typeof input.name && \"boolean\" === typeof input.ribbon;\nconst $io2 = input => \"dog\" === input.type && \"string\" === typeof input.name && \"boolean\" === typeof input.hunt;\nconst $io3 = input => \"boolean\" === typeof input.success && (\"string\" === typeof input.href && (/^[a-zA-Z0-9]+:/ / ( ?  : www.) ? [-a - zA - Z0 - 9, (),  % ._ + ~#] : )) && (\"string\" === typeof input.referrer && (/^[a-zA-Z0-9]+:/ / ( ?  : www.) ? [-a - zA - Z0 - 9, (),  % ._ + ~#] : )) && (\"string\" === typeof input.ip && (/^(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(input.ip) || /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/.test(input.ip))) && (\"string\" === typeof input.time && !isNaN(new Date(input.time).getTime()));\nconst $iu0 = input => (() => {\nif (\"cat\" === input.type)\nreturn $io1(input);\nelse if (\"dog\" === input.type)\nreturn $io2(input);\nelse\nreturn false;\n})();\n//ICustomer;\n$peo0(input);\nreturn writer;\n};\nconst sizer = encoder(new $Sizer());\nconst writer = encoder(new $Writer(sizer));\nreturn writer.buffer();\n})(customer);","reusable-functions#Reusable Functions":"export namespace protobuf {\nexport function encode<T>(): (buffer: Uint8Array) => T;\nexport function isEncode<T>(): (buffer: Uint8Array) => T | null;\nexport function assertEncode<T>(): (buffer: Uint8Array) => T;\nexport function validateEncode<T>(): (\nbuffer: Uint8Array\n) => IValidation<T>;\n}\n\n\n\nexport class TypeGuardError extends Error {\npublic readonly method: string;\npublic readonly path: string | undefined;\npublic readonly expected: string;\npublic readonly value: any;\n}\n\n\n\nexport type IValidation<T> =\n| IValidation.ISuccess<T>\n| IValidation.IFailure;\nexport namespace IValidation {\nexport interface ISuccess<T> {\nsuccess: true;\ndata: T;\n}\nexport interface IFailure {\nsuccess: false;\nerrors: IError[];\n}\nexport interface IError {\npath: string;\nexpected: string;\nvalue: any;\n}\n}\n\n\nReusable typia.protobuf.encode<T>() function generators.If you repeat to call typia.protobuf.encode<T>() function on the same type, size of JavaScript files would be larger because of duplicated AOT compilation. To prevent it, you can generate reusable function through typia.protobuf.createEncode<T>() function.Just look at the code below, then you may understand how to use it.\n\n\nimport typia, { tags } from \"typia\";\n\nexport const encode = typia.protobuf.createEncode<ICustomer>();\n\ninterface ICustomer {\nid: number & tags.Type<\"int32\">;\nemail: string & tags.Format<\"email\">;\nname: string;\npet: null | ICat | IDog;\nmemo: null | Map<string, string>;\nlogins: Array<ICustomerLogin>;\n}\ninterface ICat {\ntype: \"cat\";\nname: string;\nribbon: boolean;\n}\ninterface IDog {\ntype: \"dog\";\nname: string;\nhunt: boolean;\n}\ninterface ICustomerLogin {\nsuccess: boolean;\nhref: string & tags.Format<\"url\">;\nreferrer: string & tags.Format<\"url\">;\nip: string & (tags.Format<\"ipv4\"> | tags.Format<\"ipv6\">);\ntime: string & tags.Format<\"date-time\">;\n}\n\n\n\n\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\nreturn (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.encode = void 0;\nconst typia_1 = __importDefault(require(\"typia\"));\nconst encode = input => {\nconst $throws = typia_1.default.protobuf.createEncode.throws;\nconst $Sizer = typia_1.default.protobuf.createEncode.Sizer;\nconst $Writer = typia_1.default.protobuf.createEncode.Writer;\nconst encoder = writer => {\nconst $peo0 = input => {\n// property \"id\";\nwriter.uint32(8);\nwriter.int32(input.id);\n// property \"email\";\nwriter.uint32(18);\nwriter.string(input.email);\n// property \"name\";\nwriter.uint32(26);\nwriter.string(input.name);\n// property \"pet\";\nif (null !== input.pet) {\nif (\"cat\" === input.pet.type)\nreturn (() => {\n// 4 -> ICat;\nwriter.uint32(34);\nwriter.fork();\n$peo1(input.pet);\nwriter.ldelim();\n})();\nelse if (\"dog\" === input.pet.type)\nreturn (() => {\n// 5 -> IDog;\nwriter.uint32(42);\nwriter.fork();\n$peo2(input.pet);\nwriter.ldelim();\n})();\nelse\n$throws({\nexpected: \"(ICat | IDog)\",\nvalue: input.pet\n});\n}\n// property \"memo\";\nif (null !== input.memo) {\nfor (const [key, value] of input.memo) {\nwriter.uint32(50);\nwriter.fork();\nwriter.uint32(10);\nwriter.string(key);\nwriter.uint32(18);\nwriter.string(value);\nwriter.ldelim();\n}\n}\n// property \"logins\";\nif (0 !== input.logins.length) {\nfor (const elem of input.logins) {\n// 7 -> ICustomerLogin;\nwriter.uint32(58);\nwriter.fork();\n$peo3(elem);\nwriter.ldelim();\n}\n}\n};\nconst $peo1 = input => {\n// property \"type\";\nwriter.uint32(10);\nwriter.string(input.type);\n// property \"name\";\nwriter.uint32(18);\nwriter.string(input.name);\n// property \"ribbon\";\nwriter.uint32(24);\nwriter.bool(input.ribbon);\n};\nconst $peo2 = input => {\n// property \"type\";\nwriter.uint32(10);\nwriter.string(input.type);\n// property \"name\";\nwriter.uint32(18);\nwriter.string(input.name);\n// property \"hunt\";\nwriter.uint32(24);\nwriter.bool(input.hunt);\n};\nconst $peo3 = input => {\n// property \"success\";\nwriter.uint32(8);\nwriter.bool(input.success);\n// property \"href\";\nwriter.uint32(18);\nwriter.string(input.href);\n// property \"referrer\";\nwriter.uint32(26);\nwriter.string(input.referrer);\n// property \"ip\";\nwriter.uint32(34);\nwriter.string(input.ip);\n// property \"time\";\nwriter.uint32(42);\nwriter.string(input.time);\n};\nconst $io1 = input => \"cat\" === input.type && \"string\" === typeof input.name && \"boolean\" === typeof input.ribbon;\nconst $io2 = input => \"dog\" === input.type && \"string\" === typeof input.name && \"boolean\" === typeof input.hunt;\nconst $io3 = input => \"boolean\" === typeof input.success && (\"string\" === typeof input.href && (/^[a-zA-Z0-9]+:/ / ( ?  : www.) ? [-a - zA - Z0 - 9, (),  % ._ + ~#] : )) && (\"string\" === typeof input.referrer && (/^[a-zA-Z0-9]+:/ / ( ?  : www.) ? [-a - zA - Z0 - 9, (),  % ._ + ~#] : )) && (\"string\" === typeof input.ip && (/^(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(input.ip) || /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/.test(input.ip))) && (\"string\" === typeof input.time && !isNaN(new Date(input.time).getTime()));\nconst $iu0 = input => (() => {\nif (\"cat\" === input.type)\nreturn $io1(input);\nelse if (\"dog\" === input.type)\nreturn $io2(input);\nelse\nreturn false;\n})();\n//ICustomer;\n$peo0(input);\nreturn writer;\n};\nconst sizer = encoder(new $Sizer());\nconst writer = encoder(new $Writer(sizer));\nreturn writer.buffer();\n};\nexports.encode = encode;","references#References":"Protocol Buffer supports special numeric types like int32 or uint64 that are not supported in TypeScript. Also, types of Protocol Buffer cannot fully meet TypeScript type specs either, as expression power of TypeScript types are much stronger than Protocol Buffer.To know how to define special numeric types like uint64, and to understand which TypeScript types are not supported in Protocol Buffer specs, it would better to read below documents. I recommend you to read them before using typia.protobuf.encode<T>() related functions.\nTypia Guide Documents > Protocol Buffer > Message Schema\nmessage() function\nType Tags\nComment Tags\nRestrictions"}},"/docs/misc":{"title":"Misc","data":{"":"","clone-functions#clone() functions":"export namespace misc {\nexport function clone<T>(input: T): T;\nexport function isClone<T>(input: unknown): T | null;\nexport function assertClone<T>(input: unknown): T;\nexport function validateClone<T>(input: unknown): IValidation<T>;\n\nexport function createClone<T>(): (input: T) => T;\nexport function createIsClone<T>(): (input: unknown) => T | null;\nexport function createAssertClone<T>(): (input: unknown) => T;\nexport function createValidateClone<T>(): (input: unknown) => IValidation<T>;\n}\n\n\n\nexport class TypeGuardError extends Error {\npublic readonly method: string;\npublic readonly path: string | undefined;\npublic readonly expected: string;\npublic readonly value: any;\n}\n\n\n\nexport type IValidation<T> =\n| IValidation.ISuccess<T>\n| IValidation.IFailure;\nexport namespace IValidation {\nexport interface ISuccess<T> {\nsuccess: true;\ndata: T;\n}\nexport interface IFailure {\nsuccess: false;\nerrors: IError[];\n}\nexport interface IError {\npath: string;\nexpected: string;\nvalue: any;\n}\n}\n\n\nDeep copy function.When you want to copy an instance, just call typia.misc.clone() function. It would perform deep copy including nested objects, so you can get a new instance with same values. Also, if you want type safe deep copy function, you can use typia.misc.isClone(), typia.misc.assertClone() or typia.misc.validateClone() functions instead.\ntypia.misc.isClone(): typia.misc.is<T>() + typia.misc.clone<T>()\ntypia.misc.assertClone(): typia.misc.assert<T>() + typia.misc.clone<T>()\ntypia.misc.validateClone(): typia.misc.validate<T>() + typia.misc.clone<T>()\n\n\n\n\nimport typia from \"typia\";\n\nconst department: IDepartment = typia.misc.random<IDepartment>();\nconst cloned: IDepartment = typia.misc.assertClone(department);\n\nconsole.log(cloned);\n\ninterface IDepartment {\n/**\n* @format uuid\n*/\nid: string;\n\n/**\n* @minLength 3\n*/\nname: string;\n\n/**\n* @type int\n*/\nlimit: number;\n\nclerks: IClerk[];\n}\ninterface IClerk {\nname: string;\n\n/**\n* @exclusiveMinimum 19\n* @maximum 100\n*/\nage: number;\n\nauthority: number;\n\n/**\n* @format date\n*/\njoined_at: string;\n}\n\n\n\n\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\nreturn (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst typia_1 = __importDefault(require(\"typia\"));\nconst department = (generator => {\nconst $generator = typia_1.default.random.generator;\nconst $ro0 = (_recursive = false, _depth = 0) => { var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s; return ({\nid: (_d = (_c = (_b = ((_a = generator === null || generator === void 0 ? void 0 : generator.customs) !== null && _a !== void 0 ? _a : $generator.customs)) === null || _b === void 0 ? void 0 : _b.string) === null || _c === void 0 ? void 0 : _c.call(_b, [\n{\nname: \"format\",\nvalue: \"uuid\"\n}\n])) !== null && _d !== void 0 ? _d : ((_e = generator === null || generator === void 0 ? void 0 : generator.uuid) !== null && _e !== void 0 ? _e : $generator.uuid)(),\nname: (_j = (_h = (_g = ((_f = generator === null || generator === void 0 ? void 0 : generator.customs) !== null && _f !== void 0 ? _f : $generator.customs)) === null || _g === void 0 ? void 0 : _g.string) === null || _h === void 0 ? void 0 : _h.call(_g, [\n{\nname: \"minLength\",\nvalue: \"3\"\n}\n])) !== null && _j !== void 0 ? _j : ((_k = generator === null || generator === void 0 ? void 0 : generator.string) !== null && _k !== void 0 ? _k : $generator.string)(((_l = generator === null || generator === void 0 ? void 0 : generator.integer) !== null && _l !== void 0 ? _l : $generator.integer)(3, 25)),\nlimit: (_q = (_p = (_o = ((_m = generator === null || generator === void 0 ? void 0 : generator.customs) !== null && _m !== void 0 ? _m : $generator.customs)) === null || _o === void 0 ? void 0 : _o.number) === null || _p === void 0 ? void 0 : _p.call(_o, [\n{\nname: \"type\",\nvalue: \"int\"\n}\n])) !== null && _q !== void 0 ? _q : ((_r = generator === null || generator === void 0 ? void 0 : generator.integer) !== null && _r !== void 0 ? _r : $generator.integer)(0, 100),\nclerks: ((_s = generator === null || generator === void 0 ? void 0 : generator.array) !== null && _s !== void 0 ? _s : $generator.array)(() => $ro1(_recursive, _recursive ? 1 + _depth : _depth))\n}); };\nconst $ro1 = (_recursive = false, _depth = 0) => { var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v; return ({\nname: (_d = (_c = (_b = ((_a = generator === null || generator === void 0 ? void 0 : generator.customs) !== null && _a !== void 0 ? _a : $generator.customs)) === null || _b === void 0 ? void 0 : _b.string) === null || _c === void 0 ? void 0 : _c.call(_b, [])) !== null && _d !== void 0 ? _d : ((_e = generator === null || generator === void 0 ? void 0 : generator.string) !== null && _e !== void 0 ? _e : $generator.string)(),\nage: (_j = (_h = (_g = ((_f = generator === null || generator === void 0 ? void 0 : generator.customs) !== null && _f !== void 0 ? _f : $generator.customs)) === null || _g === void 0 ? void 0 : _g.number) === null || _h === void 0 ? void 0 : _h.call(_g, [\n{\nname: \"exclusiveMinimum\",\nvalue: \"19\"\n},\n{\nname: \"maximum\",\nvalue: \"100\"\n}\n])) !== null && _j !== void 0 ? _j : ((_k = generator === null || generator === void 0 ? void 0 : generator.number) !== null && _k !== void 0 ? _k : $generator.number)(19, 100),\nauthority: (_p = (_o = (_m = ((_l = generator === null || generator === void 0 ? void 0 : generator.customs) !== null && _l !== void 0 ? _l : $generator.customs)) === null || _m === void 0 ? void 0 : _m.number) === null || _o === void 0 ? void 0 : _o.call(_m, [])) !== null && _p !== void 0 ? _p : ((_q = generator === null || generator === void 0 ? void 0 : generator.number) !== null && _q !== void 0 ? _q : $generator.number)(0, 100),\njoined_at: (_u = (_t = (_s = ((_r = generator === null || generator === void 0 ? void 0 : generator.customs) !== null && _r !== void 0 ? _r : $generator.customs)) === null || _s === void 0 ? void 0 : _s.string) === null || _t === void 0 ? void 0 : _t.call(_s, [\n{\nname: \"format\",\nvalue: \"date\"\n}\n])) !== null && _u !== void 0 ? _u : ((_v = generator === null || generator === void 0 ? void 0 : generator.date) !== null && _v !== void 0 ? _v : $generator.date)()\n}); };\nreturn $ro0();\n})();\nconst cloned = (input => { const assert = input => {\nconst __is = input => {\nconst $is_uuid = typia_1.default.assertClone.is_uuid;\nconst $is_date = typia_1.default.assertClone.is_date;\nconst $io0 = input => \"string\" === typeof input.id && $is_uuid(input.id) && (\"string\" === typeof input.name && 3 <= input.name.length) && (\"number\" === typeof input.limit && parseInt(input.limit) === input.limit) && (Array.isArray(input.clerks) && input.clerks.every(elem => \"object\" === typeof elem && null !== elem && $io1(elem)));\nconst $io1 = input => \"string\" === typeof input.name && (\"number\" === typeof input.age && 19 < input.age && 100 >= input.age) && \"number\" === typeof input.authority && (\"string\" === typeof input.joined_at && $is_date(input.joined_at));\nreturn \"object\" === typeof input && null !== input && $io0(input);\n};\nif (false === __is(input))\n((input, _path, _exceptionable = true) => {\nconst $guard = typia_1.default.assertClone.guard;\nconst $is_uuid = typia_1.default.assertClone.is_uuid;\nconst $is_date = typia_1.default.assertClone.is_date;\nconst $ao0 = (input, _path, _exceptionable = true) => (\"string\" === typeof input.id && ($is_uuid(input.id) || $guard(_exceptionable, {\npath: _path + \".id\",\nexpected: \"string (@format uuid)\",\nvalue: input.id\n})) || $guard(_exceptionable, {\npath: _path + \".id\",\nexpected: \"string\",\nvalue: input.id\n})) && (\"string\" === typeof input.name && (3 <= input.name.length || $guard(_exceptionable, {\npath: _path + \".name\",\nexpected: \"string (@minLength 3)\",\nvalue: input.name\n})) || $guard(_exceptionable, {\npath: _path + \".name\",\nexpected: \"string\",\nvalue: input.name\n})) && (\"number\" === typeof input.limit && (parseInt(input.limit) === input.limit || $guard(_exceptionable, {\npath: _path + \".limit\",\nexpected: \"number (@type int)\",\nvalue: input.limit\n})) || $guard(_exceptionable, {\npath: _path + \".limit\",\nexpected: \"number\",\nvalue: input.limit\n})) && ((Array.isArray(input.clerks) || $guard(_exceptionable, {\npath: _path + \".clerks\",\nexpected: \"Array<IClerk>\",\nvalue: input.clerks\n})) && input.clerks.every((elem, _index1) => (\"object\" === typeof elem && null !== elem || $guard(_exceptionable, {\npath: _path + \".clerks[\" + _index1 + \"]\",\nexpected: \"IClerk\",\nvalue: elem\n})) && $ao1(elem, _path + \".clerks[\" + _index1 + \"]\", true && _exceptionable) || $guard(_exceptionable, {\npath: _path + \".clerks[\" + _index1 + \"]\",\nexpected: \"IClerk\",\nvalue: elem\n})) || $guard(_exceptionable, {\npath: _path + \".clerks\",\nexpected: \"Array<IClerk>\",\nvalue: input.clerks\n}));\nconst $ao1 = (input, _path, _exceptionable = true) => (\"string\" === typeof input.name || $guard(_exceptionable, {\npath: _path + \".name\",\nexpected: \"string\",\nvalue: input.name\n})) && (\"number\" === typeof input.age && (19 < input.age || $guard(_exceptionable, {\npath: _path + \".age\",\nexpected: \"number (@exclusiveMinimum 19)\",\nvalue: input.age\n})) && (100 >= input.age || $guard(_exceptionable, {\npath: _path + \".age\",\nexpected: \"number (@maximum 100)\",\nvalue: input.age\n})) || $guard(_exceptionable, {\npath: _path + \".age\",\nexpected: \"number\",\nvalue: input.age\n})) && (\"number\" === typeof input.authority || $guard(_exceptionable, {\npath: _path + \".authority\",\nexpected: \"number\",\nvalue: input.authority\n})) && (\"string\" === typeof input.joined_at && ($is_date(input.joined_at) || $guard(_exceptionable, {\npath: _path + \".joined_at\",\nexpected: \"string (@format date)\",\nvalue: input.joined_at\n})) || $guard(_exceptionable, {\npath: _path + \".joined_at\",\nexpected: \"string\",\nvalue: input.joined_at\n}));\nreturn (\"object\" === typeof input && null !== input || $guard(true, {\npath: _path + \"\",\nexpected: \"IDepartment\",\nvalue: input\n})) && $ao0(input, _path + \"\", true) || $guard(true, {\npath: _path + \"\",\nexpected: \"IDepartment\",\nvalue: input\n});\n})(input, \"$input\", true);\nreturn input;\n}; const clone = input => {\nconst $io1 = input => \"string\" === typeof input.name && (\"number\" === typeof input.age && 19 < input.age && 100 >= input.age) && \"number\" === typeof input.authority && (\"string\" === typeof input.joined_at && $is_date(input.joined_at));\nconst $is_uuid = typia_1.default.assertClone.is_uuid;\nconst $is_date = typia_1.default.assertClone.is_date;\nconst $cp0 = input => input.map(elem => \"object\" === typeof elem && null !== elem ? $co1(elem) : elem);\nconst $co0 = input => ({\nid: input.id,\nname: input.name,\nlimit: input.limit,\nclerks: Array.isArray(input.clerks) ? $cp0(input.clerks) : input.clerks\n});\nconst $co1 = input => ({\nname: input.name,\nage: input.age,\nauthority: input.authority,\njoined_at: input.joined_at\n});\nreturn \"object\" === typeof input && null !== input ? $co0(input) : input;\n}; assert(input); const output = clone(input); return output; })(department);\nconsole.log(cloned);","prune-functions#prune() functions":"export function prune<T>(input: T): T;\nexport function isPrune<T>(input: unknown): T | null;\nexport function assertPrune<T>(input: unknown): T;\nexport function validatePrune<T>(input: unknown): IValidation<T>;\n\nexport function createPrune<T>(): (input: T) => T;\nexport function createIsPrune<T>(): (input: unknown) => T | null;\nexport function createAssertPrune<T>(): (input: unknown) => T;\nexport function createValidatePrune<T>(): (input: unknown) => IValidation<T>;\n\n\n\nexport class TypeGuardError extends Error {\npublic readonly method: string;\npublic readonly path: string | undefined;\npublic readonly expected: string;\npublic readonly value: any;\n}\n\n\n\nexport type IValidation<T> =\n| IValidation.ISuccess<T>\n| IValidation.IFailure;\nexport namespace IValidation {\nexport interface ISuccess<T> {\nsuccess: true;\ndata: T;\n}\nexport interface IFailure {\nsuccess: false;\nerrors: IError[];\n}\nexport interface IError {\npath: string;\nexpected: string;\nvalue: any;\n}\n}\n\n\nDeep prune functions.When you want to remove every extra properties that are not defined in the type including nested objects, you can use typia.misc.prune<T>() function. Also, if you want to perform type safe pruning, you can use typia.misc.isPrune<T>(), typia.misc.assertPrune<T>() or typia.misc.validatePrune<T>() functions instead.\ntypia.misc.isPrune(): typia.misc.is<T>() + typia.misc.prune<T>()\ntypia.misc.assertPrune(): typia.misc.assert<T>() + typia.misc.prune<T>()\ntypia.misc.validatePrune(): typia.misc.validate<T>() + typia.misc.prune<T>()\n\n\n\n\nimport typia from \"typia\";\n\nconst department: IDepartment = typia.misc.random<IDepartment>();\nconst pruned: IDepartment = typia.misc.assertPrune(department);\nconsole.log(pruned);\n\ninterface IDepartment {\n/**\n* @format uuid\n*/\nid: string;\n\n/**\n* @minLength 3\n*/\nname: string;\n\n/**\n* @type int\n*/\nlimit: number;\n\nclerks: IClerk[];\n}\ninterface IClerk {\nname: string;\n\n/**\n* @exclusiveMinimum 19\n* @maximum 100\n*/\nage: number;\n\nauthority: number;\n\n/**\n* @format date\n*/\njoined_at: string;\n}\n\n\n\n\n\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\nreturn (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst typia_1 = __importDefault(require(\"typia\"));\nconst department = (generator => {\nconst $generator = typia_1.default.random.generator;\nconst $ro0 = (_recursive = false, _depth = 0) => { var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s; return ({\nid: (_d = (_c = (_b = ((_a = generator === null || generator === void 0 ? void 0 : generator.customs) !== null && _a !== void 0 ? _a : $generator.customs)) === null || _b === void 0 ? void 0 : _b.string) === null || _c === void 0 ? void 0 : _c.call(_b, [\n{\nname: \"format\",\nvalue: \"uuid\"\n}\n])) !== null && _d !== void 0 ? _d : ((_e = generator === null || generator === void 0 ? void 0 : generator.uuid) !== null && _e !== void 0 ? _e : $generator.uuid)(),\nname: (_j = (_h = (_g = ((_f = generator === null || generator === void 0 ? void 0 : generator.customs) !== null && _f !== void 0 ? _f : $generator.customs)) === null || _g === void 0 ? void 0 : _g.string) === null || _h === void 0 ? void 0 : _h.call(_g, [\n{\nname: \"minLength\",\nvalue: \"3\"\n}\n])) !== null && _j !== void 0 ? _j : ((_k = generator === null || generator === void 0 ? void 0 : generator.string) !== null && _k !== void 0 ? _k : $generator.string)(((_l = generator === null || generator === void 0 ? void 0 : generator.integer) !== null && _l !== void 0 ? _l : $generator.integer)(3, 25)),\nlimit: (_q = (_p = (_o = ((_m = generator === null || generator === void 0 ? void 0 : generator.customs) !== null && _m !== void 0 ? _m : $generator.customs)) === null || _o === void 0 ? void 0 : _o.number) === null || _p === void 0 ? void 0 : _p.call(_o, [\n{\nname: \"type\",\nvalue: \"int\"\n}\n])) !== null && _q !== void 0 ? _q : ((_r = generator === null || generator === void 0 ? void 0 : generator.integer) !== null && _r !== void 0 ? _r : $generator.integer)(0, 100),\nclerks: ((_s = generator === null || generator === void 0 ? void 0 : generator.array) !== null && _s !== void 0 ? _s : $generator.array)(() => $ro1(_recursive, _recursive ? 1 + _depth : _depth))\n}); };\nconst $ro1 = (_recursive = false, _depth = 0) => { var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v; return ({\nname: (_d = (_c = (_b = ((_a = generator === null || generator === void 0 ? void 0 : generator.customs) !== null && _a !== void 0 ? _a : $generator.customs)) === null || _b === void 0 ? void 0 : _b.string) === null || _c === void 0 ? void 0 : _c.call(_b, [])) !== null && _d !== void 0 ? _d : ((_e = generator === null || generator === void 0 ? void 0 : generator.string) !== null && _e !== void 0 ? _e : $generator.string)(),\nage: (_j = (_h = (_g = ((_f = generator === null || generator === void 0 ? void 0 : generator.customs) !== null && _f !== void 0 ? _f : $generator.customs)) === null || _g === void 0 ? void 0 : _g.number) === null || _h === void 0 ? void 0 : _h.call(_g, [\n{\nname: \"exclusiveMinimum\",\nvalue: \"19\"\n},\n{\nname: \"maximum\",\nvalue: \"100\"\n}\n])) !== null && _j !== void 0 ? _j : ((_k = generator === null || generator === void 0 ? void 0 : generator.number) !== null && _k !== void 0 ? _k : $generator.number)(19, 100),\nauthority: (_p = (_o = (_m = ((_l = generator === null || generator === void 0 ? void 0 : generator.customs) !== null && _l !== void 0 ? _l : $generator.customs)) === null || _m === void 0 ? void 0 : _m.number) === null || _o === void 0 ? void 0 : _o.call(_m, [])) !== null && _p !== void 0 ? _p : ((_q = generator === null || generator === void 0 ? void 0 : generator.number) !== null && _q !== void 0 ? _q : $generator.number)(0, 100),\njoined_at: (_u = (_t = (_s = ((_r = generator === null || generator === void 0 ? void 0 : generator.customs) !== null && _r !== void 0 ? _r : $generator.customs)) === null || _s === void 0 ? void 0 : _s.string) === null || _t === void 0 ? void 0 : _t.call(_s, [\n{\nname: \"format\",\nvalue: \"date\"\n}\n])) !== null && _u !== void 0 ? _u : ((_v = generator === null || generator === void 0 ? void 0 : generator.date) !== null && _v !== void 0 ? _v : $generator.date)()\n}); };\nreturn $ro0();\n})();\nconst pruned = (input => { const assert = input => {\nconst __is = input => {\nconst $is_uuid = typia_1.default.assertPrune.is_uuid;\nconst $is_date = typia_1.default.assertPrune.is_date;\nconst $io0 = input => \"string\" === typeof input.id && $is_uuid(input.id) && (\"string\" === typeof input.name && 3 <= input.name.length) && (\"number\" === typeof input.limit && parseInt(input.limit) === input.limit) && (Array.isArray(input.clerks) && input.clerks.every(elem => \"object\" === typeof elem && null !== elem && $io1(elem)));\nconst $io1 = input => \"string\" === typeof input.name && (\"number\" === typeof input.age && 19 < input.age && 100 >= input.age) && \"number\" === typeof input.authority && (\"string\" === typeof input.joined_at && $is_date(input.joined_at));\nreturn \"object\" === typeof input && null !== input && $io0(input);\n};\nif (false === __is(input))\n((input, _path, _exceptionable = true) => {\nconst $guard = typia_1.default.assertPrune.guard;\nconst $is_uuid = typia_1.default.assertPrune.is_uuid;\nconst $is_date = typia_1.default.assertPrune.is_date;\nconst $ao0 = (input, _path, _exceptionable = true) => (\"string\" === typeof input.id && ($is_uuid(input.id) || $guard(_exceptionable, {\npath: _path + \".id\",\nexpected: \"string (@format uuid)\",\nvalue: input.id\n})) || $guard(_exceptionable, {\npath: _path + \".id\",\nexpected: \"string\",\nvalue: input.id\n})) && (\"string\" === typeof input.name && (3 <= input.name.length || $guard(_exceptionable, {\npath: _path + \".name\",\nexpected: \"string (@minLength 3)\",\nvalue: input.name\n})) || $guard(_exceptionable, {\npath: _path + \".name\",\nexpected: \"string\",\nvalue: input.name\n})) && (\"number\" === typeof input.limit && (parseInt(input.limit) === input.limit || $guard(_exceptionable, {\npath: _path + \".limit\",\nexpected: \"number (@type int)\",\nvalue: input.limit\n})) || $guard(_exceptionable, {\npath: _path + \".limit\",\nexpected: \"number\",\nvalue: input.limit\n})) && ((Array.isArray(input.clerks) || $guard(_exceptionable, {\npath: _path + \".clerks\",\nexpected: \"Array<IClerk>\",\nvalue: input.clerks\n})) && input.clerks.every((elem, _index1) => (\"object\" === typeof elem && null !== elem || $guard(_exceptionable, {\npath: _path + \".clerks[\" + _index1 + \"]\",\nexpected: \"IClerk\",\nvalue: elem\n})) && $ao1(elem, _path + \".clerks[\" + _index1 + \"]\", true && _exceptionable) || $guard(_exceptionable, {\npath: _path + \".clerks[\" + _index1 + \"]\",\nexpected: \"IClerk\",\nvalue: elem\n})) || $guard(_exceptionable, {\npath: _path + \".clerks\",\nexpected: \"Array<IClerk>\",\nvalue: input.clerks\n}));\nconst $ao1 = (input, _path, _exceptionable = true) => (\"string\" === typeof input.name || $guard(_exceptionable, {\npath: _path + \".name\",\nexpected: \"string\",\nvalue: input.name\n})) && (\"number\" === typeof input.age && (19 < input.age || $guard(_exceptionable, {\npath: _path + \".age\",\nexpected: \"number (@exclusiveMinimum 19)\",\nvalue: input.age\n})) && (100 >= input.age || $guard(_exceptionable, {\npath: _path + \".age\",\nexpected: \"number (@maximum 100)\",\nvalue: input.age\n})) || $guard(_exceptionable, {\npath: _path + \".age\",\nexpected: \"number\",\nvalue: input.age\n})) && (\"number\" === typeof input.authority || $guard(_exceptionable, {\npath: _path + \".authority\",\nexpected: \"number\",\nvalue: input.authority\n})) && (\"string\" === typeof input.joined_at && ($is_date(input.joined_at) || $guard(_exceptionable, {\npath: _path + \".joined_at\",\nexpected: \"string (@format date)\",\nvalue: input.joined_at\n})) || $guard(_exceptionable, {\npath: _path + \".joined_at\",\nexpected: \"string\",\nvalue: input.joined_at\n}));\nreturn (\"object\" === typeof input && null !== input || $guard(true, {\npath: _path + \"\",\nexpected: \"IDepartment\",\nvalue: input\n})) && $ao0(input, _path + \"\", true) || $guard(true, {\npath: _path + \"\",\nexpected: \"IDepartment\",\nvalue: input\n});\n})(input, \"$input\", true);\nreturn input;\n}; const prune = input => {\nconst $io1 = input => \"string\" === typeof input.name && (\"number\" === typeof input.age && 19 < input.age && 100 >= input.age) && \"number\" === typeof input.authority && (\"string\" === typeof input.joined_at && $is_date(input.joined_at));\nconst $is_uuid = typia_1.default.assertPrune.is_uuid;\nconst $is_date = typia_1.default.assertPrune.is_date;\nconst $pp0 = input => input.forEach(elem => {\nif (\"object\" === typeof elem && null !== elem)\n$po1(elem);\n});\nconst $po0 = input => {\nif (Array.isArray(input.clerks))\n$pp0(input.clerks);\nfor (const key of Object.keys(input)) {\nif (\"id\" === key || \"name\" === key || \"limit\" === key || \"clerks\" === key)\ncontinue;\ndelete input[key];\n}\n};\nconst $po1 = input => {\nfor (const key of Object.keys(input)) {\nif (\"name\" === key || \"age\" === key || \"authority\" === key || \"joined_at\" === key)\ncontinue;\ndelete input[key];\n}\n};\nif (\"object\" === typeof input && null !== input)\n$po0(input);\n}; assert(input); prune(input); return input; })(department);\nconsole.log(pruned);"}},"/docs/protobuf/decode":{"title":"Decode","data":{"":"","decode-functions#decode() functions":"export namespace protobuf {\nexport function decode<T>(buffer: Uint8Array): Resolved<T>;\nexport function isDecode<T>(buffer: Uint8Array): Resolved<T> | null;\nexport function assertDecode<T>(buffer: Uint8Array): Resolved<T>;\nexport function validateDecode<T>(\nbuffer: Uint8Array\n): IValidation<Resolved<T>>;\n}\n\n\n\nexport class TypeGuardError extends Error {\npublic readonly method: string;\npublic readonly path: string | undefined;\npublic readonly expected: string;\npublic readonly value: any;\n}\n\n\n\nexport type IValidation<T> =\n| IValidation.ISuccess<T>\n| IValidation.IFailure;\nexport namespace IValidation {\nexport interface ISuccess<T> {\nsuccess: true;\ndata: T;\n}\nexport interface IFailure {\nsuccess: false;\nerrors: IError[];\n}\nexport interface IError {\npath: string;\nexpected: string;\nvalue: any;\n}\n}\n\n\n\n/**\n* Resolved type erased every methods.\n*\n* `Resolved` is a type of TMP (Type Meta Programming) type which converts\n* its argument as a resolved type that erased every method properties.\n*\n* If the target argument is a built-in class which returns its origin primitive type\n* through the `valueOf()` method like the `String` or `Number`, its return type would\n* be the `string` or `number`. Otherwise, the built-in class does not have the\n* `valueOf()` method, the return type would be same with the target argument.\n*\n* Otherwise, the target argument is a type of custom class, all of its custom methods\n* would be erased and its prototype would be changed to the primitive `object`.\n* Therefore, return type of the TMP type finally be the resolved object.\n*\n* Before                  | After\n* ------------------------|----------------------------------------\n* `Boolean`               | `boolean`\n* `Number`                | `number`\n* `BigInt`                | `bigint`\n* `String`                | `string`\n* `Class`                 | `interface`\n* Native Class or Others  | No change\n*\n* @template Instance Target argument type.\n* @author Jeongho Nam - https://github.com/samchon\n* @author Kyungsu Kang - https://github.com/kakasoo\n*/\nexport type Resolved<T> = Equal<T, ResolvedMain<T>> extends true\n? T\n: ResolvedMain<T>;\n\ntype Equal<X, Y> = X extends Y ? (Y extends X ? true : false) : false;\n\ntype ResolvedMain<Instance> = Instance extends [never]\n? never // (special trick for jsonable | null) type\n: ValueOf<Instance> extends boolean | number | bigint | string\n? ValueOf<Instance>\n: Instance extends Function\n? never\n: Instance extends object\n? ResolvedObject<Instance>\n: ValueOf<Instance>;\n\ntype ResolvedObject<Instance extends object> = Instance extends Array<infer T>\n? IsTuple<Instance> extends true\n? ResolvedTuple<Instance>\n: ResolvedMain<T>[]\n: Instance extends Set<infer U>\n? Set<ResolvedMain<U>>\n: Instance extends Map<infer K, infer V>\n? Map<ResolvedMain<K>, ResolvedMain<V>>\n: Instance extends WeakSet<any> | WeakMap<any, any>\n? never\n: Instance extends\n| Date\n| Uint8Array\n| Uint8ClampedArray\n| Uint16Array\n| Uint32Array\n| BigUint64Array\n| Int8Array\n| Int16Array\n| Int32Array\n| BigInt64Array\n| Float32Array\n| Float64Array\n| ArrayBuffer\n| SharedArrayBuffer\n| DataView\n? Instance\n: {\n[P in keyof Instance]: ResolvedMain<Instance[P]>;\n};\n\ntype ResolvedTuple<T extends readonly any[]> = T extends []\n? []\n: T extends [infer F]\n? [ResolvedMain<F>]\n: T extends [infer F, ...infer Rest extends readonly any[]]\n? [ResolvedMain<F>, ...ResolvedTuple<Rest>]\n: T extends [(infer F)?]\n? [ResolvedMain<F>?]\n: T extends [(infer F)?, ...infer Rest extends readonly any[]]\n? [ResolvedMain<F>?, ...ResolvedTuple<Rest>]\n: [];\n\ntype ValueOf<Instance> = IsValueOf<Instance, Boolean> extends true\n? boolean\n: IsValueOf<Instance, Number> extends true\n? number\n: IsValueOf<Instance, String> extends true\n? string\n: Instance;\n\ntype IsTuple<T extends readonly any[] | { length: number }> = [T] extends [\nnever,\n]\n? false\n: T extends readonly any[]\n? number extends T[\"length\"]\n? false\n: true\n: false;\n\ntype IsValueOf<Instance, Object extends IValueOf<any>> = Instance extends Object\n? Object extends IValueOf<infer Primitive>\n? Instance extends Primitive\n? false\n: true // not Primitive, but Object\n: false // cannot be\n: false;\n\ninterface IValueOf<T> {\nvalueOf(): T;\n}\n\n\nProtocol Buffer Decoder.You can easily convert a Protocol Buffer's binary data to a JavaScript object, without any extra Protocol Buffer Message Schema definition. typia.protobuf.decode<T>() function analyzes your type T, and generates a Protocol Buffer Message Schema internally.And then, it converts the binary data to a JavaScript object.By the way, as Protocol Buffer handles binary data directly, there's no way when input binary data was not encoded from the T typed value. In that case, unexpected behavior or internal error would be occured. Therefore, I recommend you to encode binary data of Protocol Buffer from type safe encode functions like below, Use typia.protobuf.encode<T>() function only when you can trust it.\ntypia.protobuf.isEncode<T>()\ntypia.protobuf.assertEncode<T>()\ntypia.protobuf.validateEncode<T>()\n\nFor reference, typia provides type safe decorators like below, but they are just for additional type validation like number & Minimum<7> or string & Format<\"uuid\"> cases, that are represented by Special Tags. Thus, I repeat that, you've to ensure type safety when using decoder function.\ntypia.protobuf.isDecode<T>(): typia.is<T>() + typia.protobuf.decode<T>()\ntypia.protobuf.assertDecode<T>(): typia.assert<T>() + typia.protobuf.decode<T>()\ntypia.protobuf.validateDecode<T>(): typia.validate<T>() + typia.protobuf.decode<T>()\n\n\n\n\n\nAOT compliation\ntypia.protobuf.decode<T>() and other similar functions are still much faster than any other competitive libraries, even though they include type checking process. This is the power of AOT compilation, writing optimal dedicated code by analyzing TypeScript type, in the compilation level.\n\n\n\nimport typia, { tags } from \"typia\";\n\ninterface ICustomer {\nid: number & tags.Type<\"int32\">;\nemail: string & tags.Format<\"email\">;\nname: string;\npet: null | ICat | IDog;\nmemo: null | Map<string, string>;\nlogins: Array<ICustomerLogin>;\n}\ninterface ICat {\ntype: \"cat\";\nname: string;\nribbon: boolean;\n}\ninterface IDog {\ntype: \"dog\";\nname: string;\nhunt: boolean;\n}\ninterface ICustomerLogin {\nsuccess: boolean;\nhref: string & tags.Format<\"url\">;\nreferrer: string & tags.Format<\"url\">;\nip: string & (tags.Format<\"ipv4\"> | tags.Format<\"ipv6\">);\ntime: string & tags.Format<\"date-time\">;\n}\n\nconst data: ICustomer = typia.random<ICustomer>();\nconst encoded: Uint8Array = typia.protobuf.encode(data);\ntypia.protobuf.decode<ICustomer>(encoded);\n\n\n\n\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\nreturn (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst typia_1 = __importDefault(require(\"typia\"));\nconst data = (generator => {\nconst $generator = typia_1.default.random.generator;\nconst $pick = typia_1.default.random.pick;\nconst $ro0 = (_recursive = false, _depth = 0) => ({\nid: (generator?.customs ?? $generator.customs)?.number?.([\n{\nname: \"Type<\\\"int32\\\">\",\nkind: \"type\",\nvalue: \"int32\",\n}\n]) ?? (generator?.integer ?? $generator.integer)(0, 100),\nemail: (generator?.customs ?? $generator.customs)?.string?.([\n{\nname: \"Format<\\\"email\\\">\",\nkind: \"format\",\nvalue: \"email\",\n}\n]) ?? (generator?.email ?? $generator.email)(),\nname: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),\npet: $pick([\n() => null,\n() => $ro1(_recursive, _recursive ? 1 + _depth : _depth),\n() => $ro2(_recursive, _recursive ? 1 + _depth : _depth)\n])(),\nmemo: $pick([\n() => null,\n() => new Map((generator?.array ?? $generator.array)(() => [\n(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),\n(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()\n]))\n])(),\nlogins: (generator?.array ?? $generator.array)(() => $ro3(_recursive, _recursive ? 1 + _depth : _depth))\n});\nconst $ro1 = (_recursive = false, _depth = 0) => ({\ntype: \"cat\",\nname: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),\nribbon: (generator?.boolean ?? $generator.boolean)()\n});\nconst $ro2 = (_recursive = false, _depth = 0) => ({\ntype: \"dog\",\nname: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),\nhunt: (generator?.boolean ?? $generator.boolean)()\n});\nconst $ro3 = (_recursive = false, _depth = 0) => ({\nsuccess: (generator?.boolean ?? $generator.boolean)(),\nhref: (generator?.customs ?? $generator.customs)?.string?.([\n{\nname: \"Format<\\\"url\\\">\",\nkind: \"format\",\nvalue: \"url\",\n}\n]) ?? (generator?.url ?? $generator.url)(),\nreferrer: (generator?.customs ?? $generator.customs)?.string?.([\n{\nname: \"Format<\\\"url\\\">\",\nkind: \"format\",\nvalue: \"url\",\n}\n]) ?? (generator?.url ?? $generator.url)(),\nip: $pick([\n() => (generator?.customs ?? $generator.customs)?.string?.([\n{\nname: \"Format<\\\"ipv4\\\">\",\nkind: \"format\",\nvalue: \"ipv4\",\n}\n]) ?? (generator?.ipv4 ?? $generator.ipv4)(),\n() => (generator?.customs ?? $generator.customs)?.string?.([\n{\nname: \"Format<\\\"ipv6\\\">\",\nkind: \"format\",\nvalue: \"ipv6\",\n}\n]) ?? (generator?.ipv6 ?? $generator.ipv6)()\n])(),\ntime: (generator?.customs ?? $generator.customs)?.string?.([\n{\nname: \"Format<\\\"date-time\\\">\",\nkind: \"format\",\nvalue: \"date-time\",\n}\n]) ?? (generator?.datetime ?? $generator.datetime)()\n});\nreturn $ro0();\n})();\nconst encoded = (input => {\nconst $throws = typia_1.default.protobuf.encode.throws;\nconst $Sizer = typia_1.default.protobuf.encode.Sizer;\nconst $Writer = typia_1.default.protobuf.encode.Writer;\nconst encoder = writer => {\nconst $peo0 = input => {\n// property \"id\";\nwriter.uint32(8);\nwriter.int32(input.id);\n// property \"email\";\nwriter.uint32(18);\nwriter.string(input.email);\n// property \"name\";\nwriter.uint32(26);\nwriter.string(input.name);\n// property \"pet\";\nif (null !== input.pet) {\nif (\"cat\" === input.pet.type)\nreturn (() => {\n// 4 -> ICat;\nwriter.uint32(34);\nwriter.fork();\n$peo1(input.pet);\nwriter.ldelim();\n})();\nelse if (\"dog\" === input.pet.type)\nreturn (() => {\n// 5 -> IDog;\nwriter.uint32(42);\nwriter.fork();\n$peo2(input.pet);\nwriter.ldelim();\n})();\nelse\n$throws({\nexpected: \"(ICat | IDog)\",\nvalue: input.pet\n});\n}\n// property \"memo\";\nif (null !== input.memo) {\nfor (const [key, value] of input.memo) {\nwriter.uint32(50);\nwriter.fork();\nwriter.uint32(10);\nwriter.string(key);\nwriter.uint32(18);\nwriter.string(value);\nwriter.ldelim();\n}\n}\n// property \"logins\";\nif (0 !== input.logins.length) {\nfor (const elem of input.logins) {\n// 7 -> ICustomerLogin;\nwriter.uint32(58);\nwriter.fork();\n$peo3(elem);\nwriter.ldelim();\n}\n}\n};\nconst $peo1 = input => {\n// property \"type\";\nwriter.uint32(10);\nwriter.string(input.type);\n// property \"name\";\nwriter.uint32(18);\nwriter.string(input.name);\n// property \"ribbon\";\nwriter.uint32(24);\nwriter.bool(input.ribbon);\n};\nconst $peo2 = input => {\n// property \"type\";\nwriter.uint32(10);\nwriter.string(input.type);\n// property \"name\";\nwriter.uint32(18);\nwriter.string(input.name);\n// property \"hunt\";\nwriter.uint32(24);\nwriter.bool(input.hunt);\n};\nconst $peo3 = input => {\n// property \"success\";\nwriter.uint32(8);\nwriter.bool(input.success);\n// property \"href\";\nwriter.uint32(18);\nwriter.string(input.href);\n// property \"referrer\";\nwriter.uint32(26);\nwriter.string(input.referrer);\n// property \"ip\";\nwriter.uint32(34);\nwriter.string(input.ip);\n// property \"time\";\nwriter.uint32(42);\nwriter.string(input.time);\n};\nconst $io1 = input => \"cat\" === input.type && \"string\" === typeof input.name && \"boolean\" === typeof input.ribbon;\nconst $io2 = input => \"dog\" === input.type && \"string\" === typeof input.name && \"boolean\" === typeof input.hunt;\nconst $io3 = input => \"boolean\" === typeof input.success && (\"string\" === typeof input.href && (/^[a-zA-Z0-9]+:/ / ( ?  : www.) ? [-a - zA - Z0 - 9, (),  % ._ + ~#] : )) && (\"string\" === typeof input.referrer && (/^[a-zA-Z0-9]+:/ / ( ?  : www.) ? [-a - zA - Z0 - 9, (),  % ._ + ~#] : )) && (\"string\" === typeof input.ip && (/^(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(input.ip) || /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/.test(input.ip))) && (\"string\" === typeof input.time && !isNaN(new Date(input.time).getTime()));\nconst $iu0 = input => (() => {\nif (\"cat\" === input.type)\nreturn $io1(input);\nelse if (\"dog\" === input.type)\nreturn $io2(input);\nelse\nreturn false;\n})();\n//ICustomer;\n$peo0(input);\nreturn writer;\n};\nconst sizer = encoder(new $Sizer());\nconst writer = encoder(new $Writer(sizer));\nreturn writer.buffer();\n})(data);\n(input => {\nconst $Reader = typia_1.default.protobuf.decode.Reader;\nconst $pdo0 = (reader, length = -1) => {\nlength = length < 0 ? reader.size() : reader.index() + length;\nconst output = {\nid: undefined,\nemail: \"\",\nname: \"\",\npet: null,\nmemo: null,\nlogins: []\n};\nwhile (reader.index() < length) {\nconst tag = reader.uint32();\nswitch (tag >>> 3) {\ncase 1:\n// int32;\noutput.id = reader.int32();\nbreak;\ncase 2:\n// string;\noutput.email = reader.string();\nbreak;\ncase 3:\n// string;\noutput.name = reader.string();\nbreak;\ncase 4:\n// ICat;\noutput.pet = $pdo1(reader, reader.uint32());\nbreak;\ncase 5:\n// IDog;\noutput.pet = $pdo2(reader, reader.uint32());\nbreak;\ncase 6:\n// type: Map<string, string>;\n(() => {\noutput.memo ??= new Map();\nconst piece = reader.uint32() + reader.index();\nconst entry = {\nkey: \"\",\nvalue: \"\"\n};\nwhile (reader.index() < piece) {\nconst kind = reader.uint32();\nswitch (kind >>> 3) {\ncase 1:\n// string;\nentry.key = reader.string();\nbreak;\ncase 2:\n// string;\nentry.value = reader.string();\nbreak;\ndefault:\nreader.skipType(kind & 7);\nbreak;\n}\n}\noutput.memo.set(entry.key, entry.value);\n})();\nbreak;\ncase 7:\n// type: Array<ICustomerLogin>;\noutput.logins.push($pdo3(reader, reader.uint32()));\nbreak;\ndefault:\nreader.skipType(tag & 7);\nbreak;\n}\n}\nreturn output;\n};\nconst $pdo1 = (reader, length = -1) => {\nlength = length < 0 ? reader.size() : reader.index() + length;\nconst output = {\ntype: undefined,\nname: \"\",\nribbon: undefined\n};\nwhile (reader.index() < length) {\nconst tag = reader.uint32();\nswitch (tag >>> 3) {\ncase 1:\n// string;\noutput.type = reader.string();\nbreak;\ncase 2:\n// string;\noutput.name = reader.string();\nbreak;\ncase 3:\n// bool;\noutput.ribbon = reader.bool();\nbreak;\ndefault:\nreader.skipType(tag & 7);\nbreak;\n}\n}\nreturn output;\n};\nconst $pdo2 = (reader, length = -1) => {\nlength = length < 0 ? reader.size() : reader.index() + length;\nconst output = {\ntype: undefined,\nname: \"\",\nhunt: undefined\n};\nwhile (reader.index() < length) {\nconst tag = reader.uint32();\nswitch (tag >>> 3) {\ncase 1:\n// string;\noutput.type = reader.string();\nbreak;\ncase 2:\n// string;\noutput.name = reader.string();\nbreak;\ncase 3:\n// bool;\noutput.hunt = reader.bool();\nbreak;\ndefault:\nreader.skipType(tag & 7);\nbreak;\n}\n}\nreturn output;\n};\nconst $pdo3 = (reader, length = -1) => {\nlength = length < 0 ? reader.size() : reader.index() + length;\nconst output = {\nsuccess: undefined,\nhref: \"\",\nreferrer: \"\",\nip: \"\",\ntime: \"\"\n};\nwhile (reader.index() < length) {\nconst tag = reader.uint32();\nswitch (tag >>> 3) {\ncase 1:\n// bool;\noutput.success = reader.bool();\nbreak;\ncase 2:\n// string;\noutput.href = reader.string();\nbreak;\ncase 3:\n// string;\noutput.referrer = reader.string();\nbreak;\ncase 4:\n// string;\noutput.ip = reader.string();\nbreak;\ncase 5:\n// string;\noutput.time = reader.string();\nbreak;\ndefault:\nreader.skipType(tag & 7);\nbreak;\n}\n}\nreturn output;\n};\nconst reader = new $Reader(input);\nreturn $pdo0(reader);\n})(encoded);","reusable-functions#Reusable functions":"export namespace protobuf {\nexport function createDecode<T>(): (buffer: Uint8Array) => Resolved<T>;\nexport function createIsDecode<T>: (buffer: Uint8Array) => Resolved<T> | null;\nexport function createAssertDecode<T>(): (buffer: Uint8Array) => Resolved<T>;\nexport function createValidateDecode<T>(): (\nbuffer: Uint8Array\n) => IValidation<Resolved<T>>;\n}\n\n\n\nexport class TypeGuardError extends Error {\npublic readonly method: string;\npublic readonly path: string | undefined;\npublic readonly expected: string;\npublic readonly value: any;\n}\n\n\n\nexport type IValidation<T> =\n| IValidation.ISuccess<T>\n| IValidation.IFailure;\nexport namespace IValidation {\nexport interface ISuccess<T> {\nsuccess: true;\ndata: T;\n}\nexport interface IFailure {\nsuccess: false;\nerrors: IError[];\n}\nexport interface IError {\npath: string;\nexpected: string;\nvalue: any;\n}\n}\n\n\n\n/**\n* Resolved type erased every methods.\n*\n* `Resolved` is a type of TMP (Type Meta Programming) type which converts\n* its argument as a resolved type that erased every method properties.\n*\n* If the target argument is a built-in class which returns its origin primitive type\n* through the `valueOf()` method like the `String` or `Number`, its return type would\n* be the `string` or `number`. Otherwise, the built-in class does not have the\n* `valueOf()` method, the return type would be same with the target argument.\n*\n* Otherwise, the target argument is a type of custom class, all of its custom methods\n* would be erased and its prototype would be changed to the primitive `object`.\n* Therefore, return type of the TMP type finally be the resolved object.\n*\n* Before                  | After\n* ------------------------|----------------------------------------\n* `Boolean`               | `boolean`\n* `Number`                | `number`\n* `BigInt`                | `bigint`\n* `String`                | `string`\n* `Class`                 | `interface`\n* Native Class or Others  | No change\n*\n* @template Instance Target argument type.\n* @author Jeongho Nam - https://github.com/samchon\n* @author Kyungsu Kang - https://github.com/kakasoo\n*/\nexport type Resolved<T> = Equal<T, ResolvedMain<T>> extends true\n? T\n: ResolvedMain<T>;\n\ntype Equal<X, Y> = X extends Y ? (Y extends X ? true : false) : false;\n\ntype ResolvedMain<Instance> = Instance extends [never]\n? never // (special trick for jsonable | null) type\n: ValueOf<Instance> extends boolean | number | bigint | string\n? ValueOf<Instance>\n: Instance extends Function\n? never\n: Instance extends object\n? ResolvedObject<Instance>\n: ValueOf<Instance>;\n\ntype ResolvedObject<Instance extends object> = Instance extends Array<infer T>\n? IsTuple<Instance> extends true\n? ResolvedTuple<Instance>\n: ResolvedMain<T>[]\n: Instance extends Set<infer U>\n? Set<ResolvedMain<U>>\n: Instance extends Map<infer K, infer V>\n? Map<ResolvedMain<K>, ResolvedMain<V>>\n: Instance extends WeakSet<any> | WeakMap<any, any>\n? never\n: Instance extends\n| Date\n| Uint8Array\n| Uint8ClampedArray\n| Uint16Array\n| Uint32Array\n| BigUint64Array\n| Int8Array\n| Int16Array\n| Int32Array\n| BigInt64Array\n| Float32Array\n| Float64Array\n| ArrayBuffer\n| SharedArrayBuffer\n| DataView\n? Instance\n: {\n[P in keyof Instance]: ResolvedMain<Instance[P]>;\n};\n\ntype ResolvedTuple<T extends readonly any[]> = T extends []\n? []\n: T extends [infer F]\n? [ResolvedMain<F>]\n: T extends [infer F, ...infer Rest extends readonly any[]]\n? [ResolvedMain<F>, ...ResolvedTuple<Rest>]\n: T extends [(infer F)?]\n? [ResolvedMain<F>?]\n: T extends [(infer F)?, ...infer Rest extends readonly any[]]\n? [ResolvedMain<F>?, ...ResolvedTuple<Rest>]\n: [];\n\ntype ValueOf<Instance> = IsValueOf<Instance, Boolean> extends true\n? boolean\n: IsValueOf<Instance, Number> extends true\n? number\n: IsValueOf<Instance, String> extends true\n? string\n: Instance;\n\ntype IsTuple<T extends readonly any[] | { length: number }> = [T] extends [\nnever,\n]\n? false\n: T extends readonly any[]\n? number extends T[\"length\"]\n? false\n: true\n: false;\n\ntype IsValueOf<Instance, Object extends IValueOf<any>> = Instance extends Object\n? Object extends IValueOf<infer Primitive>\n? Instance extends Primitive\n? false\n: true // not Primitive, but Object\n: false // cannot be\n: false;\n\ninterface IValueOf<T> {\nvalueOf(): T;\n}\n\n\nReusable typia.protobuf.decode<T>() function generators.If you repeat to call typia.protobuf.decode<T>() function on the same type, size of JavaScript files would be larger because of duplicated AOT compilation. To prevent it, you can generate reusable function through typia.protobuf.createDecode<T>() function.Just look at the code below, then you may understand how to use it.\n\n\nimport typia, { tags } from \"typia\";\n\nexport const encode = typia.protobuf.createDecode<ICustomer>();\n\ninterface ICustomer {\nid: number & tags.Type<\"int32\">;\nemail: string & tags.Format<\"email\">;\nname: string;\npet: null | ICat | IDog;\nmemo: null | Map<string, string>;\nlogins: Array<ICustomerLogin>;\n}\ninterface ICat {\ntype: \"cat\";\nname: string;\nribbon: boolean;\n}\ninterface IDog {\ntype: \"dog\";\nname: string;\nhunt: boolean;\n}\ninterface ICustomerLogin {\nsuccess: boolean;\nhref: string & tags.Format<\"url\">;\nreferrer: string & tags.Format<\"url\">;\nip: string & (tags.Format<\"ipv4\"> | tags.Format<\"ipv6\">);\ntime: string & tags.Format<\"date-time\">;\n}\n\n\n\n\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\nreturn (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.encode = void 0;\nconst typia_1 = __importDefault(require(\"typia\"));\nconst encode = input => {\nconst $Reader = typia_1.default.protobuf.createDecode.Reader;\nconst $pdo0 = (reader, length = -1) => {\nlength = length < 0 ? reader.size() : reader.index() + length;\nconst output = {\nid: undefined,\nemail: \"\",\nname: \"\",\npet: null,\nmemo: null,\nlogins: []\n};\nwhile (reader.index() < length) {\nconst tag = reader.uint32();\nswitch (tag >>> 3) {\ncase 1:\n// int32;\noutput.id = reader.int32();\nbreak;\ncase 2:\n// string;\noutput.email = reader.string();\nbreak;\ncase 3:\n// string;\noutput.name = reader.string();\nbreak;\ncase 4:\n// ICat;\noutput.pet = $pdo1(reader, reader.uint32());\nbreak;\ncase 5:\n// IDog;\noutput.pet = $pdo2(reader, reader.uint32());\nbreak;\ncase 6:\n// type: Map<string, string>;\n(() => {\noutput.memo ??= new Map();\nconst piece = reader.uint32() + reader.index();\nconst entry = {\nkey: \"\",\nvalue: \"\"\n};\nwhile (reader.index() < piece) {\nconst kind = reader.uint32();\nswitch (kind >>> 3) {\ncase 1:\n// string;\nentry.key = reader.string();\nbreak;\ncase 2:\n// string;\nentry.value = reader.string();\nbreak;\ndefault:\nreader.skipType(kind & 7);\nbreak;\n}\n}\noutput.memo.set(entry.key, entry.value);\n})();\nbreak;\ncase 7:\n// type: Array<ICustomerLogin>;\noutput.logins.push($pdo3(reader, reader.uint32()));\nbreak;\ndefault:\nreader.skipType(tag & 7);\nbreak;\n}\n}\nreturn output;\n};\nconst $pdo1 = (reader, length = -1) => {\nlength = length < 0 ? reader.size() : reader.index() + length;\nconst output = {\ntype: undefined,\nname: \"\",\nribbon: undefined\n};\nwhile (reader.index() < length) {\nconst tag = reader.uint32();\nswitch (tag >>> 3) {\ncase 1:\n// string;\noutput.type = reader.string();\nbreak;\ncase 2:\n// string;\noutput.name = reader.string();\nbreak;\ncase 3:\n// bool;\noutput.ribbon = reader.bool();\nbreak;\ndefault:\nreader.skipType(tag & 7);\nbreak;\n}\n}\nreturn output;\n};\nconst $pdo2 = (reader, length = -1) => {\nlength = length < 0 ? reader.size() : reader.index() + length;\nconst output = {\ntype: undefined,\nname: \"\",\nhunt: undefined\n};\nwhile (reader.index() < length) {\nconst tag = reader.uint32();\nswitch (tag >>> 3) {\ncase 1:\n// string;\noutput.type = reader.string();\nbreak;\ncase 2:\n// string;\noutput.name = reader.string();\nbreak;\ncase 3:\n// bool;\noutput.hunt = reader.bool();\nbreak;\ndefault:\nreader.skipType(tag & 7);\nbreak;\n}\n}\nreturn output;\n};\nconst $pdo3 = (reader, length = -1) => {\nlength = length < 0 ? reader.size() : reader.index() + length;\nconst output = {\nsuccess: undefined,\nhref: \"\",\nreferrer: \"\",\nip: \"\",\ntime: \"\"\n};\nwhile (reader.index() < length) {\nconst tag = reader.uint32();\nswitch (tag >>> 3) {\ncase 1:\n// bool;\noutput.success = reader.bool();\nbreak;\ncase 2:\n// string;\noutput.href = reader.string();\nbreak;\ncase 3:\n// string;\noutput.referrer = reader.string();\nbreak;\ncase 4:\n// string;\noutput.ip = reader.string();\nbreak;\ncase 5:\n// string;\noutput.time = reader.string();\nbreak;\ndefault:\nreader.skipType(tag & 7);\nbreak;\n}\n}\nreturn output;\n};\nconst reader = new $Reader(input);\nreturn $pdo0(reader);\n};\nexports.encode = encode;","references#References":"Protocol Buffer supports special numeric types like int32 or uint64 that are not supported in TypeScript. Also, types of Protocol Buffer cannot fully meet TypeScript type specs either, as expression power of TypeScript types are much stronger than Protocol Buffer.To know how to define special numeric types like uint64, and to understand which TypeScript types are not supported in Protocol Buffer specs, it would better to read below documents. I recommend you to read them before using typia.protobuf.decode<T>() related functions.\nTypia Guide Documents > Protocol Buffer > Message Schema\nmessage() function\nType Tags\nComment Tags\nRestrictions"}},"/docs/utilization/nestjs":{"title":"Nestjs","data":{"":"Nestia is a set of helper libraries for NestJS, supporting below features:\n@nestia/core: superfast decorators using typia\n@nestia/sdk: evolved SDK and Swagger generators\n@nestia/migrate: Swagger to NestJS\nnestia: just CLI (command line interface) tool\n\n\nimport { Controller } from \"@nestjs/common\";\nimport { TypedBody, TypedRoute } from \"@nestia/core\";\n\nimport type { IBbsArticle } from \"@bbs-api/structures/IBbsArticle\";\n\n@Controller(\"bbs/articles\")\nexport class BbsArticlesController {\n/**\n* Store a new content.\n*\n* @param input Content to store\n* @returns Newly archived article\n*/\n@TypedRoute.Post() // 200x faster and safer JSON.stringify()\npublic async store(\n@TypedBody() input: IBbsArticle.IStore // 20,000x faster validator\n): Promise<IBbsArticle>;\n// do not need DTO class definition,\n// just fine with interface\n}\n\nLeft: NestJS server code\nRight: Client code using SDK"}},"/docs/utilization/prisma":{"title":"Prisma","data":{"":"model bbs_articles {\nid String @id @db.Uuid /// @format uuid\ncreated_at DateTime @db.Timestamptz\n\n/// @minItems 1\nsnapshots bbs_article_snapshots[]\n}\n\nmodel bbs_article_snapshots {\nid String @id @db.Uuid /// @format uuid\nbbs_article_id String @db.Uuid /// @format uuid\nformat String @db.VarChar\n\n/// @minLength 5\n/// @maxLength 80\ntitle String @db.VarChar\nbody String\ncreated_at DateTime @db.Timestamptz\n\narticle bbs_articles @relation(fields: [bbs_article_id], references: [id])\n}\n\n\n\n/**\n* Model bbs_articles\n*/\nexport type bbs_articles = {\n/**\n* @format uuid\n*/\nid: string\ncreated_at: Date\n}\n\n/**\n* Model bbs_article_snapshots\n*/\nexport type bbs_article_snapshots = {\n/**\n* @format uuid\n*/\nid: string\n/**\n* @format uuid\n*/\nbbs_article_id: string\nformat: string\n/**\n* @minLength 5\n* @maxLength 80\n*/\ntitle: string\nbody: string\ncreated_at: Date\n}\n\n\nWhen defining prisma.schema file, you can write comment tags just by using /// statement.After the definition, you utillize some validate function like typia.assert<T>(), for type safe insertion."}},"/docs/random":{"title":"Random","data":{"":"","random-function#random() function":"export function random<T>(g?: IRandomGenerator): Resolved<T>;\n\n\n\nexport interface IRandomGenerator {\nboolean(): boolean;\ninteger(minimum?: number, maximum?: number): number;\nnumber(minimum?: number, maximum?: number): number;\nbigint(minimum?: bigint, maximum?: bigint): bigint;\nstring(length?: number): string;\narray<T>(closure: (index: number) => T, count?: number): T[];\nlength(): number;\n\nuuid(): string;\nemail(): string;\nurl(): string;\nipv4(): string;\nipv6(): string;\npattern(regex: RegExp): string;\ndate(minimum?: number, maximum?: number): string;\ndatetime(minimum?: number, maximum?: number): string;\n\ncustoms?: IRandomGenerator.CustomMap;\n}\nexport namespace IRandomGenerator {\nexport type CustomMap = {\n[Type in keyof Customizable]?: (\ntags: ITypeTag[],\n) => Customizable[Type] | undefined;\n};\n\nexport interface ITypeTag {\nname: string;\nkind: string;\nvalue: any;\n}\n}\n\n\n\nexport interface Customizable {\nnumber: number;\nstring: string;\nbigint: bigint;\n}\n\n\n\n/**\n* Resolved type erased every methods.\n*\n* `Resolved` is a type of TMP (Type Meta Programming) type which converts\n* its argument as a resolved type that erased every method properties.\n*\n* If the target argument is a built-in class which returns its origin primitive type\n* through the `valueOf()` method like the `String` or `Number`, its return type would\n* be the `string` or `number`. Otherwise, the built-in class does not have the\n* `valueOf()` method, the return type would be same with the target argument.\n*\n* Otherwise, the target argument is a type of custom class, all of its custom methods\n* would be erased and its prototype would be changed to the primitive `object`.\n* Therefore, return type of the TMP type finally be the resolved object.\n*\n* Before                  | After\n* ------------------------|----------------------------------------\n* `Boolean`               | `boolean`\n* `Number`                | `number`\n* `BigInt`                | `bigint`\n* `String`                | `string`\n* `Class`                 | `interface`\n* Native Class or Others  | No change\n*\n* @template Instance Target argument type.\n* @author Jeongho Nam - https://github.com/samchon\n* @author Kyungsu Kang - https://github.com/kakasoo\n*/\nexport type Resolved<T> = Equal<T, ResolvedMain<T>> extends true\n? T\n: ResolvedMain<T>;\n\ntype Equal<X, Y> = X extends Y ? (Y extends X ? true : false) : false;\n\ntype ResolvedMain<Instance> = Instance extends [never]\n? never // (special trick for jsonable | null) type\n: ValueOf<Instance> extends boolean | number | bigint | string\n? ValueOf<Instance>\n: Instance extends Function\n? never\n: Instance extends object\n? ResolvedObject<Instance>\n: ValueOf<Instance>;\n\ntype ResolvedObject<Instance extends object> = Instance extends Array<infer T>\n? IsTuple<Instance> extends true\n? ResolvedTuple<Instance>\n: ResolvedMain<T>[]\n: Instance extends Set<infer U>\n? Set<ResolvedMain<U>>\n: Instance extends Map<infer K, infer V>\n? Map<ResolvedMain<K>, ResolvedMain<V>>\n: Instance extends WeakSet<any> | WeakMap<any, any>\n? never\n: Instance extends\n| Date\n| Uint8Array\n| Uint8ClampedArray\n| Uint16Array\n| Uint32Array\n| BigUint64Array\n| Int8Array\n| Int16Array\n| Int32Array\n| BigInt64Array\n| Float32Array\n| Float64Array\n| ArrayBuffer\n| SharedArrayBuffer\n| DataView\n? Instance\n: {\n[P in keyof Instance]: ResolvedMain<Instance[P]>;\n};\n\ntype ResolvedTuple<T extends readonly any[]> = T extends []\n? []\n: T extends [infer F]\n? [ResolvedMain<F>]\n: T extends [infer F, ...infer Rest extends readonly any[]]\n? [ResolvedMain<F>, ...ResolvedTuple<Rest>]\n: T extends [(infer F)?]\n? [ResolvedMain<F>?]\n: T extends [(infer F)?, ...infer Rest extends readonly any[]]\n? [ResolvedMain<F>?, ...ResolvedTuple<Rest>]\n: [];\n\ntype ValueOf<Instance> = IsValueOf<Instance, Boolean> extends true\n? boolean\n: IsValueOf<Instance, Number> extends true\n? number\n: IsValueOf<Instance, String> extends true\n? string\n: Instance;\n\ntype IsTuple<T extends readonly any[] | { length: number }> = [T] extends [\nnever,\n]\n? false\n: T extends readonly any[]\n? number extends T[\"length\"]\n? false\n: true\n: false;\n\ntype IsValueOf<Instance, Object extends IValueOf<any>> = Instance extends Object\n? Object extends IValueOf<infer Primitive>\n? Instance extends Primitive\n? false\n: true // not Primitive, but Object\n: false // cannot be\n: false;\n\ninterface IValueOf<T> {\nvalueOf(): T;\n}\n\n\nYou can make every random data just by calling typia.random<T>() function.When you call the typia.random<T>() function, typia will analyze your type T, and writes optimal random generation code for the type T, in the compilation level. This is called AOT (Ahead of Time) compliation, and you may understand what it is just by reading below example code.\n\n\nimport typia, { tags } from \"typia\";\n\nconst member: IMember = typia.random<IMember>();\nconsole.log(member);\n\ninterface IMember {\nid: string & tags.Format<\"uuid\">;\nemail: string & tags.Format<\"email\">;\nage: number\n& tags.Type<\"uint32\">\n& tags.ExclusiveMinimum<19>\n& tags.Maximum<100>;\n}\n\n\n\n\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\nreturn (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst typia_1 = __importDefault(require(\"typia\"));\nconst member = (generator => {\nconst $generator = typia_1.default.random.generator;\nconst $ro0 = (_recursive = false, _depth = 0) => ({\nid: (generator?.customs ?? $generator.customs)?.string?.([\n{\nname: \"Format<\\\"uuid\\\">\",\nkind: \"format\",\nvalue: \"uuid\",\n}\n]) ?? (generator?.uuid ?? $generator.uuid)(),\nemail: (generator?.customs ?? $generator.customs)?.string?.([\n{\nname: \"Format<\\\"email\\\">\",\nkind: \"format\",\nvalue: \"email\",\n}\n]) ?? (generator?.email ?? $generator.email)(),\nage: (generator?.customs ?? $generator.customs)?.number?.([\n{\nname: \"Type<\\\"uint32\\\">\",\nkind: \"type\",\nvalue: \"uint32\",\n},\n{\nname: \"ExclusiveMinimum<19>\",\nkind: \"exclusiveMinimum\",\nvalue: 19,\n},\n{\nname: \"Maximum<100>\",\nkind: \"maximum\",\nvalue: 100,\n}\n]) ?? (generator?.integer ?? $generator.integer)(19, 100)\n});\nreturn $ro0();\n})();\nconsole.log(member);","reusable-function#Reusable function":"export function createRandom<T>(): (g?: IRandomGenerator) => T;\n\n\n\nexport interface IRandomGenerator {\nboolean(): boolean;\ninteger(minimum?: number, maximum?: number): number;\nnumber(minimum?: number, maximum?: number): number;\nbigint(minimum?: bigint, maximum?: bigint): bigint;\nstring(length?: number): string;\narray<T>(closure: (index: number) => T, count?: number): T[];\n\nuuid(): string;\nemail(): string;\nurl(): string;\nipv4(): string;\nipv6(): string;\npattern(regex: RegExp): string;\ndate(minimum?: number, maximum?: number): string;\ndatetime(minimum?: number, maximum?: number): string;\n\ncustoms?: IRandomGenerator.CustomMap;\n}\nexport namespace IRandomGenerator {\nexport type CustomMap = {\n[Type in keyof Customizable]?:\n(tags: ICommentTag[]) => Customizable[Type] | undefined;\n};\n\nexport interface ICommentTag {\nname: string;\nvalue?: string;\n}\n}\n\n\n\nexport interface Customizable {\nnumber: number;\nstring: string;\nbigint: bigint;\n}\n\n\nReusable typia.random<T>() function generators.If you repeat to call typia.random<T>() function on the same type, size of JavaScript files would be larger because of duplicated AOT compilation. To prevent it, you can generate reusable function through typia.createRandom<T>() function.Just look at the code below, then you may understand how to use it.\n\n\nimport typia, { tags } from \"typia\";\n\nexport const createRandomMember = typia.createRandom<IMember>();\n\ninterface IMember {\nid: string & tags.Format<\"uuid\">;\nemail: string & tags.Format<\"email\">;\nage: number\n& tags.Type<\"uint32\">\n& tags.ExclusiveMinimum<19>\n& tags.Maximum<100>;\n}\n\n\n\n\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\nreturn (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createRandomMember = void 0;\nconst typia_1 = __importDefault(require(\"typia\"));\nconst createRandomMember = generator => {\nconst $generator = typia_1.default.createRandom.generator;\nconst $ro0 = (_recursive = false, _depth = 0) => ({\nid: (generator?.customs ?? $generator.customs)?.string?.([\n{\nname: \"Format<\\\"uuid\\\">\",\nkind: \"format\",\nvalue: \"uuid\",\n}\n]) ?? (generator?.uuid ?? $generator.uuid)(),\nemail: (generator?.customs ?? $generator.customs)?.string?.([\n{\nname: \"Format<\\\"email\\\">\",\nkind: \"format\",\nvalue: \"email\",\n}\n]) ?? (generator?.email ?? $generator.email)(),\nage: (generator?.customs ?? $generator.customs)?.number?.([\n{\nname: \"Type<\\\"uint32\\\">\",\nkind: \"type\",\nvalue: \"uint32\",\n},\n{\nname: \"ExclusiveMinimum<19>\",\nkind: \"exclusiveMinimum\",\nvalue: 19,\n},\n{\nname: \"Maximum<100>\",\nkind: \"maximum\",\nvalue: 100,\n}\n]) ?? (generator?.integer ?? $generator.integer)(19, 100)\n});\nreturn $ro0();\n};\nexports.createRandomMember = createRandomMember;","special-tags#Special Tags":"Runtime validators of typia provides additional type checking logic through Type Tags and Comment Tags. typia.random<T>() function also like that. typia.random<T>() function can utilize those tags to specialize the behavior of random data generation.For reference, whether you choose Type Tags or Comment Tags. typia.random<T>(), it is not a matter for typia.random<T>() function. Below two TypeScript codes are generating exactly same JavaScript code. Therefore, you can choose whatever you want considering your preference.\n\n\nimport typia, { tags } from \"typia\";\n\nconst data: TypeTag = typia.random<TypeTag>();\n\nconsole.log(data);\n\ninterface TypeTag {\ntype: number & tags.Type<\"int32\">;\nnumber?: number & tags.ExclusiveMinimum<19> & tags.Maximum<100>;\nstring: string & tags.MinLength<3>;\npattern: string & tags.Pattern<\"^[a-z]+$\">;\nformat: (string & tags.Format<\"date-time\">) | null;\n}\n\n\n\nimport typia from \"typia\";\n\nconst data: CommentTag = typia.random<CommentTag>();\n\nconsole.log(data);\n\ninterface CommentTag {\n/**\n* @type int\n*/\ntype: number;\n\n/**\n* @exclusiveMinimum 19\n* @maximum 100\n*/\nnumber?: number;\n\n/**\n* @minLength 3\n*/\nstring: string;\n\n/**\n* @pattern ^[a-z]+$\n*/\npattern: string;\n\n/**\n* @format date-time\n*/\nformat: string | null;\n}\n\n\n\n\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\nreturn (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst typia_1 = __importDefault(require(\"typia\"));\nconst data = (generator => {\nconst $generator = typia_1.default.random.generator;\nconst $pick = typia_1.default.random.pick;\nconst $ro0 = (_recursive = false, _depth = 0) => ({\ntype: (generator?.customs ?? $generator.customs)?.number?.([\n{\nname: \"Type<\\\"int32\\\">\",\nkind: \"type\",\nvalue: \"int32\"\n}\n]) ?? (generator?.integer ?? $generator.integer)(0, 100),\nnumber: $pick([\n() => undefined,\n() => (generator?.customs ?? $generator.customs)?.number?.([\n{\nname: \"ExclusiveMinimum<19>\",\nkind: \"exclusiveMinimum\",\nvalue: 19\n},\n{\nname: \"Maximum<100>\",\nkind: \"maximum\",\nvalue: 100\n}\n]) ?? (generator?.number ?? $generator.number)(19, 100)\n])(),\nstring: (generator?.customs ?? $generator.customs)?.string?.([\n{\nname: \"MinLength<3>\",\nkind: \"minLength\",\nvalue: 3\n}\n]) ?? (generator?.string ?? $generator.string)((generator?.integer ?? $generator.integer)(3, 25)),\npattern: (generator?.customs ?? $generator.customs)?.string?.([\n{\nname: \"Pattern<\\\"^[a-z]+$\\\">\",\nkind: \"pattern\",\nvalue: \"^[a-z]+$\"\n}\n]) ?? (generator?.pattern ?? $generator.pattern)(/^[a-z]+$/),\nformat: $pick([\n() => null,\n() => (generator?.customs ?? $generator.customs)?.string?.([\n{\nname: \"Format<\\\"date-time\\\">\",\nkind: \"format\",\nvalue: \"date-time\"\n}\n]) ?? (generator?.datetime ?? $generator.datetime)()\n])()\n});\nreturn $ro0();\n})();\nconsole.log(data);","customization#Customization":"export function random<T>(g?: IRandomGenerator): T;\nexport function createRandom<T>: (g?: IRandomGenerator) => T;\n\n\n\nexport interface IRandomGenerator {\nboolean(): boolean;\ninteger(minimum?: number, maximum?: number): number;\nnumber(minimum?: number, maximum?: number): number;\nbigint(minimum?: bigint, maximum?: bigint): bigint;\nstring(length?: number): string;\narray<T>(closure: (index: number) => T, count?: number): T[];\n\nuuid(): string;\nemail(): string;\nurl(): string;\nipv4(): string;\nipv6(): string;\npattern(regex: RegExp): string;\ndate(minimum?: number, maximum?: number): string;\ndatetime(minimum?: number, maximum?: number): string;\n\ncustoms?: IRandomGenerator.CustomMap;\n}\nexport namespace IRandomGenerator {\nexport type CustomMap = {\n[Type in keyof Customizable]?:\n(tags: ICommentTag[]) => Customizable[Type] | undefined;\n};\n\nexport interface ICommentTag {\nname: string;\nvalue?: string;\n}\n}\n\n\n\nexport interface Customizable {\nnumber: number;\nstring: string;\nbigint: bigint;\n}\n\n\nYou can add custom type tags for random data generation.As above IRandomGenerator.CustomMap has a little bit complicate type, it may hard to understand for newcomers. However, such newcomers may easily understand, how to customize the random generation, just by reading the following example.Just define custom type tags like below, then everything would be done.For reference, when defining custom type tag, typia enforces user to define validate function literal for type safety. Never forget it when you define custom type tags for random generation. Such validation logic definition may enhance your random data generator logic when combining with typia.assert<T>() function.\n\n\nimport typia from \"typia\";\nimport { RandomGenerator } from \"typia/lib/utils/RandomGenerator\";\n\nconst data: TagCustom = typia.random<TagCustom>({\ncustoms: {\nstring: (tags) => {\nif (tags.find((t) => t.kind === \"dollar\") !== undefined)\nreturn \"$\" + RandomGenerator.integer();\nconst postfix = tags.find((t) => t.kind === \"postfix\");\nif (postfix !== undefined)\nreturn RandomGenerator.string() + postfix.value;\n},\n},\n});\n\nconsole.log(data);\n\ninterface TagCustom {\nid: string & typia.tags.Format<\"uuid\">;\ndollar: string & Dolloar;\npostfix: string & Postfix<\"abcd\">;\n}\n\ntype Dolloar = typia.tags.TagBase<{\nkind: \"dollar\";\ntarget: \"string\";\nvalue: undefined;\nvalidate: `$input[0] === \"$\" && !isNaN(Number($input.substring(1).split(\",\").join(\"\")))`;\n}>;\n\ntype Postfix<Value extends string> = typia.tags.TagBase<{\nkind: \"postfix\";\ntarget: \"string\";\nvalue: Value;\nvalidate: `$input.endsWith(\"${Value}\")`;\n}>;\n\n\n\nimport typia from \"typia\";\nimport { RandomGenerator } from \"typia/lib/utils/RandomGenerator\";\n\nconst data = (generator => {\nconst $generator = typia.random.generator;\nconst $ro0 = (_recursive = false, _depth = 0) => ({\nid: (generator?.customs ?? $generator.customs)?.string?.([\n{\nname: \"format\",\nvalue: \"uuid\"\n}\n]) ?? (generator?.uuid ?? $generator.uuid)(),\ndollar: (generator?.customs ?? $generator.customs)?.string?.([\n{\nname: \"dollar\"\n}\n]) ?? (generator?.string ?? $generator.string)(),\npostfix: (generator?.customs ?? $generator.customs)?.string?.([\n{\nname: \"postfix\",\nvalue: \"abcd\"\n}\n]) ?? (generator?.string ?? $generator.string)(),\npower: (generator?.customs ?? $generator.customs)?.number?.([\n{\nname: \"powerOf\",\nvalue: \"10\"\n}\n]) ?? (generator?.number ?? $generator.number)(0, 100)\n});\nreturn $ro0();\n})({\ncustoms: {\nstring: (tags) => {\nif (tags.find((t) => t.name === \"dollar\") !== undefined)\nreturn \"$\" + RandomGenerator.integer();\nconst postfix = tags.find((t) => t.name === \"postfix\");\nif (postfix !== undefined)\nreturn RandomGenerator.string() + postfix.value;\n},\nnumber: (tags) => {\nconst powerOf = tags.find((t) => t.name === \"powerOf\");\nif (powerOf !== undefined)\nreturn Math.pow(Number(powerOf.value), RandomGenerator.integer(1, 4));\n},\n},\n});\n\nconsole.log(data);"}},"/docs/setup":{"title":"Setup","data":{"":"","summary#Summary":"npm install typia\nnpx typia setup\n\n\n\npnpm install typia\npnpm typia setup --manager pnpm\n\n\n\n# YARN BERRY IS NOT SUPPORTED\nyarn add typia\nyarn typia setup --manager yarn\n\n\nIf you're using standard TypeScript compiler, you can use transform mode.Just run npx typia setup command, then everything be prepared.\nStandard TypeScript Compiler: Microsoft/TypeScript\n\n\n\n\nnpm install typia\nnpm install --save-dev typescript\n\nnpx typia generate \\\n--input src/templates \\\n--output src/generated \\\n--project tsconfig.json\n\n\n\npnpm install typia\npnpm install --save-dev typescript\n\npnpm typia generate \\\n--input src/templates \\\n--output src/generated \\\n--project tsconfig.json\n\n\n\nyarn add typia\nyarn add -D typescript\n\nyarn typia generate \\\n--input src/templates \\\n--output src/generated \\\n--project tsconfig.json\n\n\nOtherwise you are using non-standard TypeScript compiler, then you can't use transformation mode.Instead, you can use generation mode.Run typia generate command with input directory, then transformed TypeScript files would be generated into the output directory.\nNon-standard TypeScript Compilers\nSWC\nESBuild\nBabel","transformation#Transformation":"","concepts#Concepts":"AOT (Ahead of Time) compilation mode.When you write a TypeScript code calling typia.createIs<IMember>() function and compile it through tsc command, typia will replace the typia.createIs<IMember>() statement to optimal validation code in the compiled JavaScript file, for the IMember type.This is the transform mode performing AOT (Ahead of Time) compilation.\n\n\nimport typia from \"typia\";\n\nexport const check = typia.createIs<IMember>();\n\ninterface IMember {\n/**\n* @format uuid\n*/\nid: string;\n\n/**\n* @format email\n*/\nemail: string;\n\n/**\n* @exclusiveMinimum 19\n* @maximum 100\n*/\nage: number;\n}\n\n\n\nimport typia from \"typia\";\nexport const check = input => {\nconst $is_uuid = typia.createIs.is_uuid;\nconst $is_email = typia.createIs.is_email;\nreturn \"object\" === typeof input &&\nnull !== input &&\n(\n\"string\" === typeof input.id && $is_uuid(input.id) &&\n(\"string\" === typeof input.email && $is_email(input.email)) &&\n(\"number\" === typeof input.age && 19 < input.age && 100 >= input.age)\n);\n};","setup-wizard#Setup Wizard":"npm install --save typia\nnpx typia setup\n\n\n\npnpm install --save typia\npnpm typia setup --manager pnpm\n\n\n\n# YARN BERRY IS NOT SUPPORTED\nyarn add typia\nyarn typia setup --manager yarn\n\n\nYou can turn on transformation mode just by running npx typia setup command.Setup wizard would be executed, and it will do everything for the transformation.","manual-setup#Manual Setup":"npm install --save typia\nnpm install --save-dev typescript ts-patch ts-node\n\n\n\npnpm install --save typia\npnpm install --save-dev typescript ts-patch ts-node\n\n\n\n# YARN BERRY IS NOT SUPPORTED\nyarn add typia\nyarn add -D typescript ts-patch ts-node\n\n\nIf you want to install typia manually, just follow the steps.At first, install typia as depepdency. And then, install typescript, ts-patch and ts-node as devDependencies.\n{\n\"strict\": true,\n\"strictNullChecks\": true,\n\"compilerOptions\": {\n\"plugins\": [\n{ \"transform\": \"typia/lib/transform\" }\n]\n}\n}\nAt second, open your tsconfig.json file and configure like above.As typia generates optimal operation code through transformation, you've to configure it as a plugin. Also, never forget to configure strict (or strictNullChecks) to be true. It is essential option for modern TypeScript development.\n{\n\"scripts\": {\n\"postinstall\": \"ts-patch install\"\n},\n\"dependencies\": {\n\"typia\": \"^4.1.8\"\n},\n\"devDependencies\": {\n\"ts-node\": \"^10.9.1\",\n\"ts-patch\": \"^3.0.2\",\n\"typescript\": \"^5.1.6\"\n}\n}\n\n\n\nnpm run postinstall\n\n\n\npnpm postinstall\n\n\n\n# YARN BERRY IS NOT SUPPORTED\nyarn postinstall\n\n\nAt last, open package.json file and configure npm run postinstall command like above.Of course, you've to run the npm run postinstall command after the configuration.For reference, ts-patch is an helper library of TypeScript compiler that supporting custom transformations by plugins. From now on, whenever you run tsc command, your typia function call statements would be transformed to the optimal operation codes in the compiled JavaScript files.","generation#Generation":"# INSTALL TYPIA\nnpm install --save typia\nnpm install --save-dev typescript\n\n# GENERATE TRANSFORMED TYPESCRIPT CODES\nnpx typia generate \\\n--input src/templates \\\n--output src/generated \\\n--project tsconfig.json\n\n\n\n# INSTALL TYPIA\npnpm install --save typia\npnpm install --save-dev typescript\n\n# GENERATE TRANSFORMED TYPESCRIPT CODES\npnpm typia generate \\\n--input src/templates \\\n--output src/generated \\\n--project tsconfig.json\n\n\n\n# INSTALL TYPIA\nyarn add typia\nyarn add -D typescript\n\n# GENERATE TRANSFORMED TYPESCRIPT CODES\nyarn typia generate \\\n--input src/templates \\\n--output src/generated \\\n--project tsconfig.json\n\n\nFor frontend projects.If you're using non-standard TypeScript compiler, you can't use transform mode\nNon-standard TypeScript compilers:\nSWC in Next.JS\nESBuild in Vite\nBabel in Create-React-App\n\n\n\nInstead, you should utilize the generation mode.Install typia through npm install command, and run typia generate command. Then, generator of typia reads your TypeScript codes of --input, and writes transformed TypeScript files into the --output directory, like below.If you want to specify other TypeScript project file instead of tsconfig.json, you can use --project option.\n\n\nimport typia from \"typia\";\n\nimport { IMember } from \"../structures/IMember\";\n\nexport const check = typia.createIs<IMember>();\n\n\n\nimport typia from \"typia\";\nimport { IMember } from \"../structures/IMember\";\nexport const check = (input: any): input is IMember => {\nconst $is_uuid = (typia.createIs as any).is_uuid;\nconst $is_email = (typia.createIs as any).is_email;\nreturn \"object\" === typeof input &&\nnull !== input &&\n(\n\"string\" === typeof input.id && is_uuid(input.id) &&\n(\"string\" === typeof input.email && $is_email(input.email)) &&\n(\"number\" === typeof input.age && 19 <= input.age && 100 >= input.age)\n);\n};\n\n\n\n\n\n\nWhy not support non-standard compilers?\nNon-standard TypeScript compilers are removing every type informations, and skipping type checkings for rapid compilation. By the way, without those type informations, typia can't do anything. This is the reason why typia doesn't support non-standard TypeScript compilers.By the way, SWC is preparing a new project STC keeping type informations. Therefore, typia will support it.","vite#Vite":"If you've made your frontend project through vite, you can still utilize the transformation mode.Just configure vite.config.ts file below, that's all.\nimport { defineConfig } from 'vite'\nimport react from '@vitejs/plugin-react'\nimport typescript from \"rollup-plugin-typescript2\";\n\n// https://vitejs.dev/config/\nexport default defineConfig({\nesbuild: false,\nplugins: [\nreact(),\ntypescript()\n]\n});","webpack#Webpack":"# TYPIA\nnpm install typia\nnpx typia setup\n\n# WEBPACK + TS-LOADER\nnpm install --save-dev ts-loader\nnpm install --save-dev webpack webpack-cli\n\n\n\n# TYPIA\npnpm install typia\npnpm typia setup --manager pnpm\n\n# WEBPACK + TS-LOADER\npnpm install --save-dev ts-loader\npnpm install --save-dev webpack webpack-cli\n\n\n\n##############################\n# YARN BERRY IS NOT SUPPORTED\n##############################\n# TYPIA\nyarn add typia\nyarn typia setup --manager yarn\n\n# WEBPACK + TS-LOADER\nyarn add -D ts-loader\nyarn add -D webpack webpack-cli\n\n\nWhen you're using webpack as a bundler, you can still utilize the transformation mode.Just install ts-loader as well as webpack, and configure webpack.config.js file like below, that's all.\nconst path = require(\"path\");\nconst nodeExternals = require('webpack-node-externals');\n\nmodule.exports = {\n// CUSTOMIZE HERE\nentry: ['./src/index.tsx'],\noutput: {\npath: path.join(__dirname, 'dist'),\nfilename: 'index.js',\n},\noptimization: {\nminimize: false\n},\n\n// JUST KEEP THEM\nmode: 'development',\ntarget: 'node',\nmodule: {\nrules: [\n{\ntest: /\\.ts$/,\nexclude: /node_modules/,\nloader: 'ts-loader',\n}\n]\n},\nresolve: {\nextensions: ['.tsx', '.ts', '.js'],\n},\n};"}},"/docs/utilization/trpc":{"title":"Trpc","data":{"":"import { initTRPC } from \"@trpc/server\";\nimport { v4 } from \"uuid\";\nimport typia from \"typia\";\n\nimport { IBbsArticle } from \"../structures/IBbsArticle\";\n\nconst server = initTRPC.create();\n\nexport const appRouter = server.router({\nstore: server.procedure\n.input(typia.createAssert<IBbsArticle.IStore>())\n.output(typia.createAssert<IBbsArticle>())\n.query(({ input }) => {\nreturn {\nid: v4(),\nwriter: input.writer,\ntitle: input.title,\nbody: input.body,\ncreated_at: new Date().toString(),\n};\n})\n});\nexport type AppRouter = typeof appRouter;"}},"/docs/validators/is":{"title":"Is","data":{"":"","is-function#is() function":"export function is<T>(input: T): input is T;\nexport function is<T>(input: unknown): input is T;\nTests a value type.When you need to test an instance type, just call typia.is<T>() function.If the input value is following type T, true value would be returned. Otherwise, false would be returned.\n\n\n\nAOT compliation\nIf you'd used other competitive validator libraries like ajv or class-validator, you may found that typia does not require any extra schema definition. If you have not experienced them, I can sure that you may get shocked after reading below extra schema definition files.\najv requires JSON schema definition.\nclass-validator requires DTO class with decorator function calls.\n\nYeah, typia needs only pure TypeScript type. As typia is a compiler library, it can analyze TypeScript type by itself, and possible to write the optimal validation code like below. This is the key principle of typia, which needs only one line with pure TypeScript type.\n\n\n\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\n\nconst matched: boolean = typia.is<IMember>({\nid: v4(),\nemail: \"samchon.github@gmai19l.com\",\nage: 30,\n});\n\nconsole.log(matched); // true\n\ninterface IMember {\nid: string & tags.Format<\"uuid\">;\nemail: string & tags.Format<\"email\">;\nage: number\n& tags.Type<\"uint32\">\n& tags.ExclusiveMinimum<19>\n& tags.Maximum<100>;\n}\n\n\n\n\"use strict\";\nvar __importDefault =\n(this && this.__importDefault) ||\nfunction (mod) {\nreturn mod && mod.__esModule ? mod : { default: mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst typia_1 = __importDefault(require(\"typia\"));\nconst uuid_1 = require(\"uuid\");\nconst matched = ((input) => {\nreturn (\n\"object\" === typeof input &&\nnull !== input &&\n\"string\" === typeof input.id &&\n/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\ninput.id,\n) &&\n\"string\" === typeof input.email &&\n/^(([^<>()[].,;:s@\"]+(.[^<>()[].,;:s@\"]+)*)|(\".+\"))@(([^<>()[].,;:s@\"]+.)+[^<>()[].,;:s@\"]{2,})$/i.test(\ninput.email,\n) &&\n\"number\" === typeof input.age &&\nMath.floor(input.age) === input.age &&\n0 <= input.age &&\ninput.age <= 4294967295 &&\n19 < input.age &&\ninput.age <= 100\n);\n})({\nid: (0, uuid_1.v4)(),\nemail: \"samchon.github@gmai19l.com\",\nage: 30,\n});\nconsole.log(matched); // true","equals-function#equals() function":"export function equals<T>(input: T): input is T;\nexport function equals<T>(input: unknown): input is T;\nMore strict checker prohibiting superfluous properties.typia.is<T>() can test instance type, but it allows superfluous properties.If you want to prohibit those superfluous properties, you can use typia.equals<T>() function instead.\n\n\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\n\nconst input: unknown = {\nid: v4(),\nemail: \"samchon.github@gmail.com\",\nage: 30,\nextra: \"superfluous property\", // extra\n};\nconst is: boolean = typia.is<IMember>(input);\nconst equals: boolean = typia.equals<IMember>(input);\n\nconsole.log(is, equals); // true, false\n\ninterface IMember {\nid: string & tags.Format<\"uuid\">;\nemail: string & tags.Format<\"email\">;\nage: number\n& tags.Type<\"uint32\">\n& tags.ExclusiveMinimum<19>\n& tags.Maximum<100>;\n}\n\n\n\n\"use strict\";\nvar __importDefault =\n(this && this.__importDefault) ||\nfunction (mod) {\nreturn mod && mod.__esModule ? mod : { default: mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst typia_1 = __importDefault(require(\"typia\"));\nconst uuid_1 = require(\"uuid\");\nconst input = {\nid: (0, uuid_1.v4)(),\nemail: \"samchon.github@gmail.com\",\nage: 30,\nextra: \"superfluous property\", // extra\n};\nconst is = ((input) => {\nreturn (\n\"object\" === typeof input &&\nnull !== input &&\n\"string\" === typeof input.id &&\n/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\ninput.id,\n) &&\n\"string\" === typeof input.email &&\n/^(([^<>()[].,;:s@\"]+(.[^<>()[].,;:s@\"]+)*)|(\".+\"))@(([^<>()[].,;:s@\"]+.)+[^<>()[].,;:s@\"]{2,})$/i.test(\ninput.email,\n) &&\n\"number\" === typeof input.age &&\nMath.floor(input.age) === input.age &&\n0 <= input.age &&\ninput.age <= 4294967295 &&\n19 < input.age &&\ninput.age <= 100\n);\n})(input);\nconst equals = ((input, _exceptionable = true) => {\nconst $io0 = (input, _exceptionable = true) =>\n\"string\" === typeof input.id &&\n/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\ninput.id,\n) &&\n\"string\" === typeof input.email &&\n/^(([^<>()[].,;:s@\"]+(.[^<>()[].,;:s@\"]+)*)|(\".+\"))@(([^<>()[].,;:s@\"]+.)+[^<>()[].,;:s@\"]{2,})$/i.test(\ninput.email,\n) &&\n\"number\" === typeof input.age &&\nMath.floor(input.age) === input.age &&\n0 <= input.age &&\ninput.age <= 4294967295 &&\n19 < input.age &&\ninput.age <= 100 &&\n(3 === Object.keys(input).length ||\nObject.keys(input).every((key) => {\nif ([\"id\", \"email\", \"age\"].some((prop) => key === prop))\nreturn true;\nconst value = input[key];\nif (undefined === value) return true;\nreturn false;\n}));\nreturn \"object\" === typeof input && null !== input && $io0(input, true);\n})(input);\nconsole.log(is, equals); // true, false","reusable-functions#Reusable functions":"export function createIs<T>(): (input: unknown) => input is T;\nexport function createEquals<T>(): (input: unknown) => input is T;\nReusable typia.is<T>() function generators.If you repeat to call typia.is<T>() function on the same type, size of JavaScript files would be larger because of duplicated AOT compilation. To prevent it, you can generate reusable function through typia.createIs<T>() function.Just look at the code below, then you may understand how to use it.\n\n\nimport typia, { tags } from \"typia\";\n\nexport const check = typia.createIs<IMember>();\n\ninterface IMember {\nid: string & tags.Format<\"uuid\">;\nemail: string & tags.Format<\"email\">;\nage: number\n& tags.Type<\"uint32\">\n& tags.ExclusiveMinimum<19>\n& tags.Maximum<100>;\n}\n\n\n\n\"use strict\";\nvar __importDefault =\n(this && this.__importDefault) ||\nfunction (mod) {\nreturn mod && mod.__esModule ? mod : { default: mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.check = void 0;\nconst typia_1 = __importDefault(require(\"typia\"));\nconst check = (input) => {\nreturn (\n\"object\" === typeof input &&\nnull !== input &&\n\"string\" === typeof input.id &&\n/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\ninput.id,\n) &&\n\"string\" === typeof input.email &&\n/^(([^<>()[].,;:s@\"]+(.[^<>()[].,;:s@\"]+)*)|(\".+\"))@(([^<>()[].,;:s@\"]+.)+[^<>()[].,;:s@\"]{2,})$/i.test(\ninput.email,\n) &&\n\"number\" === typeof input.age &&\nMath.floor(input.age) === input.age &&\n0 <= input.age &&\ninput.age <= 4294967295 &&\n19 < input.age &&\ninput.age <= 100\n);\n};\nexports.check = check;","auto-type-casting#Auto Type Casting":"export function is<T>(input: unknown): input is T;\nexport function equals<T>(input: unknown): input is T;\nexport function createIs<T>(): (input: unknown) => input is T;\nexport function createEquals<T>(): (input: unknown) => input is T;\ntypia.is<T>() function can be used for type casting.When target input value is following the type T, therefore true value be returned, typia.is<T>() function automatically casts the input value to the type T. Therefore, you can utilize the typia.is<T>() function for safe type casting tool like below:\nconst input: unknown = {\nid: v4(),\nemail: \"samchon.github@gmail.com\",\nage: 30,\n} as any;\nif (typia.is<IMember>(input)) // auto type casting\nconsole.log(input.id, input.email, input.age);","customization#Customization":"You can enhance validation logic by special tags.Also, with those tags, you can add your custom validation logic, too.If you want to know about such special tags detaily, read below article:\nSpecial Tags\nOutline\nType Tags\nComment Tags\nCustomization\n\n\n\n\n\n\nimport typia, { tags } from \"typia\";\n\nexport const checkSomething = typia.createIs<Something>();\n\n//----\n// DEFINE CUSTOM TYPE TAGS\n//----\ntype Dollar = tags.TagBase<{\nkind: \"dollar\";\ntarget: \"string\";\nvalue: undefined;\nvalidate: `$input[0] === \"$\" && !isNaN(Number($input.substring(1).split(\",\").join(\"\")))`;\n}>;\n\ntype Postfix<Value extends string> = tags.TagBase<{\nkind: \"postfix\";\ntarget: \"string\";\nvalue: Value;\nvalidate: `$input.endsWith(\"${Value}\")`;\n}>;\n\ntype IsEven<Value extends number | bigint> = tags.TagBase<{\nkind: \"isEven\";\ntarget: Value extends number ? \"number\" : \"bigint\";\nvalue: undefined;\nvalidate: `$input % ${Numeric<2>} === ${Numeric<0>}`;\n}>;\n\ntype Numeric<Value extends number | bigint> = Value extends number\n? Value\n: `BigInt(${Value})`;\n\n//----\n// VALIDATION\n//----\ninterface Something {\ndollar: string & Dollar;\npostfix: string & Postfix<\"!!!\">;\nisEven: number & IsEven<number>;\n}\n\n\n\n\"use strict\";\nvar __importDefault =\n(this && this.__importDefault) ||\nfunction (mod) {\nreturn mod && mod.__esModule ? mod : { default: mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.checkSomething = void 0;\nconst typia_1 = __importDefault(require(\"typia\"));\nconst checkSomething = (input) => {\nreturn (\n\"object\" === typeof input &&\nnull !== input &&\n\"string\" === typeof input.dollar &&\ninput.dollar[0] === \"$\" &&\n!isNaN(Number(input.dollar.substring(1).split(\",\").join(\"\"))) &&\n\"string\" === typeof input.postfix &&\ninput.postfix.endsWith(\"!!!\") &&\n\"number\" === typeof input.isEven &&\ninput.isEven % 2 === 0\n);\n};\nexports.checkSomething = checkSomething;","performance#Performance":"Super-fast and super-safe.Comparing typia.is<T>() function with other competitive libraries, maximum 20,000x faster.Furthermore, only typia can validate complicate union types.\nMeasured on Intel i5-1135g7, Surface Pro 8\n\nComponents\ttypia\tTypeBox\tajv\tio-ts\tzod\tC.V.\tEasy to use\t✅\t❌\t❌\t❌\t❌\t❌\tObject (simple)\t✔\t✔\t✔\t✔\t✔\t✔\tObject (hierarchical)\t✔\t✔\t✔\t✔\t✔\t✔\tObject (recursive)\t✔\t❌\t✔\t✔\t✔\t✔\t✔\tObject (union, implicit)\t✅\t❌\t❌\t❌\t❌\t❌\tObject (union, explicit)\t✔\t✔\t✔\t✔\t✔\t❌\tObject (additional tags)\t✔\t✔\t✔\t✔\t✔\t✔\tObject (template literal types)\t✔\t✔\t✔\t❌\t❌\t❌\tObject (dynamic properties)\t✔\t✔\t✔\t❌\t❌\t❌\tArray (rest tuple)\t✅\t❌\t❌\t❌\t❌\t❌\tArray (hierarchical)\t✔\t✔\t✔\t✔\t✔\t✔\tArray (recursive)\t✔\t✔\t✔\t✔\t✔\t❌\tArray (recursive, union)\t✔\t✔\t❌\t✔\t✔\t❌\tArray (R+U, implicit)\t✅\t❌\t❌\t❌\t❌\t❌\tArray (repeated)\t✅\t❌\t❌\t❌\t❌\t❌\tArray (repeated, union)\t✅\t❌\t❌\t❌\t❌\t❌\tUltimate Union Type\t✅\t❌\t❌\t❌\t❌\t❌\n\nC.V. means class-validator"}},"/":{"title":"Index","data":{"":"","outline#Outline":"// RUNTIME VALIDATORS\nexport function is<T>(input: unknown): input is T; // returns boolean\nexport function assert<T>(input: unknown): T; // throws TypeGuardError\nexport function validate<T>(input: unknown): IValidation<T>; // detailed\n\n// JSON FUNCTIONS\nexport namespace json {\nexport function application<T>(): IJsonApplication; // JSON schema\nexport function assertParse<T>(input: string): T; // type safe parser\nexport function assertStringify<T>(input: T): string; // safe and faster\n}\n\n// PROTOCOL BUFFER\nexport namespace protobuf {\nexport function message<T>(): string; // Protocol Buffer message\nexport function assertDecode<T>(buffer: Buffer): T; // safe decoder\nexport function assertEncode<T>(input: T): Uint8Array; // safe encoder\n}\n\n// RANDOM GENERATOR\nexport function random<T>(g?: Partial<IRandomGenerator>): T;\nTypia is a transformer library supporting below features:\nSuper-fast Runtime Validators\nEnhanced JSON functions\nProtocol Buffer encoder and decoder\nRandom data generator\n\n\n\n\n\nOnly one line required, with pure TypeScript type\n\nRuntime validator is 20,000x faster than class-validator\n\nJSON serialization is 200x faster than class-transformer","sponsors#Sponsors":"Thanks for your support.Your donation would encourage typia development."}},"/docs/validators/assert":{"title":"Assert","data":{"":"","assert-function#assert() function":"export function assert<T>(input: T): T;\nexport function assert<T>(input: unknown): T;\n\n\n\nexport class TypeGuardError extends Error {\npublic readonly method: string;\npublic readonly path: string | undefined;\npublic readonly expected: string;\npublic readonly value: any;\n}\n\n\nAsserts a value type.typia.assert<T>() function throws a TypeGuardError when wrong type comes.The TypeGuardError instance has only the first type error info, with access path and expected type. In the below example case, as the age property is wrong with its definition (@exclusiveMinimum), such TypeGuardError would be thrown:\nmethod: typia.assert()\npath: input.age\nvalue: 18,\nexpected: number & ExclusiveMinimum<19>\n\n\n\n\n\nAOT compliation\nIf you'd used other competitive validator libraries like ajv or class-validator, you may found that typia does not require any extra schema definition. If you have not experienced them, I can sure that you may get shocked after reading below extra schema definition files.\najv requires JSON schema definition.\nclass-validator requires DTO class with decorator function calls.\n\nYeah, typia needs only pure TypeScript type. As typia is a compiler library, it can analyze TypeScript type by itself, and possible to write the optimal validation code like below. This is the key principle of typia, which needs only one line with pure TypeScript type.\n\n\n\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\n\ntypia.assert<IMember>({\nid: v4(),\nemail: \"samchon.github@gmail.com\",\nage: 18, // wrong, must be greater than 19\n});\n\ninterface IMember {\nid: string & tags.Format<\"uuid\">;\nemail: string & tags.Format<\"email\">;\nage: number\n& tags.Type<\"uint32\">\n& tags.ExclusiveMinimum<19>\n& tags.Maximum<100>;\n}\n\n\n\n\"use strict\";\nvar __importDefault =\n(this && this.__importDefault) ||\nfunction (mod) {\nreturn mod && mod.__esModule ? mod : { default: mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst typia_1 = __importDefault(require(\"typia\"));\nconst uuid_1 = require(\"uuid\");\n((input) => {\nconst __is = (input) => {\nreturn (\n\"object\" === typeof input &&\nnull !== input &&\n\"string\" === typeof input.id &&\n/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\ninput.id,\n) &&\n\"string\" === typeof input.email &&\n/^(([^<>()[].,;:s@\"]+(.[^<>()[].,;:s@\"]+)*)|(\".+\"))@(([^<>()[].,;:s@\"]+.)+[^<>()[].,;:s@\"]{2,})$/i.test(\ninput.email,\n) &&\n\"number\" === typeof input.age &&\nMath.floor(input.age) === input.age &&\n0 <= input.age &&\ninput.age <= 4294967295 &&\n19 < input.age &&\ninput.age <= 100\n);\n};\nif (false === __is(input))\n((input, _path, _exceptionable = true) => {\nconst $guard = typia_1.default.assert.guard;\nconst $ao0 = (input, _path, _exceptionable = true) =>\n((\"string\" === typeof input.id &&\n(/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\ninput.id,\n) ||\n$guard(_exceptionable, {\npath: _path + \".id\",\nexpected: 'string & Format<\"uuid\">',\nvalue: input.id,\n}))) ||\n$guard(_exceptionable, {\npath: _path + \".id\",\nexpected: '(string & Format<\"uuid\">)',\nvalue: input.id,\n})) &&\n((\"string\" === typeof input.email &&\n(/^(([^<>()[].,;:s@\"]+(.[^<>()[].,;:s@\"]+)*)|(\".+\"))@(([^<>()[].,;:s@\"]+.)+[^<>()[].,;:s@\"]{2,})$/i.test(\ninput.email,\n) ||\n$guard(_exceptionable, {\npath: _path + \".email\",\nexpected: 'string & Format<\"email\">',\nvalue: input.email,\n}))) ||\n$guard(_exceptionable, {\npath: _path + \".email\",\nexpected: '(string & Format<\"email\">)',\nvalue: input.email,\n})) &&\n((\"number\" === typeof input.age &&\n((Math.floor(input.age) === input.age &&\n0 <= input.age &&\ninput.age <= 4294967295) ||\n$guard(_exceptionable, {\npath: _path + \".age\",\nexpected: 'number & Type<\"uint32\">',\nvalue: input.age,\n})) &&\n(19 < input.age ||\n$guard(_exceptionable, {\npath: _path + \".age\",\nexpected: \"number & ExclusiveMinimum<19>\",\nvalue: input.age,\n})) &&\n(input.age <= 100 ||\n$guard(_exceptionable, {\npath: _path + \".age\",\nexpected: \"number & Maximum<100>\",\nvalue: input.age,\n}))) ||\n$guard(_exceptionable, {\npath: _path + \".age\",\nexpected:\n'(number & Type<\"uint32\"> & ExclusiveMinimum<19> & Maximum<100>)',\nvalue: input.age,\n}));\nreturn (\n(((\"object\" === typeof input && null !== input) ||\n$guard(true, {\npath: _path + \"\",\nexpected: \"IMember\",\nvalue: input,\n})) &&\n$ao0(input, _path + \"\", true)) ||\n$guard(true, {\npath: _path + \"\",\nexpected: \"IMember\",\nvalue: input,\n})\n);\n})(input, \"$input\", true);\nreturn input;\n})({\nid: (0, uuid_1.v4)(),\nemail: \"samchon.github@gmail.com\",\nage: 18, // wrong, must be greater than 19\n});","assertequals-function#assertEquals() function":"export function assertEquals<T>(input: T): T;\nexport function assertEquals<T>(input: unknown): T;\n\n\n\nexport class TypeGuardError extends Error {\npublic readonly method: string;\npublic readonly path: string | undefined;\npublic readonly expected: string;\npublic readonly value: any;\n}\n\n\nMore strict assert function prohibiting superfluous properties.typia.assert<T>() function inspects input value type and throws TypeGuardError when mismatched, however, it can't detect superfluous properties. If you want to prohibit those superfluous properties, therefore throws an TypeGuardError when superfluous property exists, use typia.assertEquals<T()> function instead.In the below example case, as sex property is not defined in the IMember type, such TypeGuardError would be thrown:\nmethod: typia.assertEquals()\npath: input.sex\nvalue: 1,\nexpected: undefined\n\n\n\n\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\n\ntypia.assert<IMember>({\nid: v4(),\nemail: \"samchon.github@gmail.com\",\nage: 30,\nsex: 1, // extra\n});\n\ninterface IMember {\nid: string & tags.Format<\"uuid\">;\nemail: string & tags.Format<\"email\">;\nage: number\n& tags.Type<\"uint32\">\n& tags.ExclusiveMinimum<19>\n& tags.Maximum<100>;\n}\n\n\n\n\"use strict\";\nvar __importDefault =\n(this && this.__importDefault) ||\nfunction (mod) {\nreturn mod && mod.__esModule ? mod : { default: mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst typia_1 = __importDefault(require(\"typia\"));\nconst uuid_1 = require(\"uuid\");\n((input) => {\nconst __is = (input) => {\nreturn (\n\"object\" === typeof input &&\nnull !== input &&\n\"string\" === typeof input.id &&\n/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\ninput.id,\n) &&\n\"string\" === typeof input.email &&\n/^(([^<>()[].,;:s@\"]+(.[^<>()[].,;:s@\"]+)*)|(\".+\"))@(([^<>()[].,;:s@\"]+.)+[^<>()[].,;:s@\"]{2,})$/i.test(\ninput.email,\n) &&\n\"number\" === typeof input.age &&\nMath.floor(input.age) === input.age &&\n0 <= input.age &&\ninput.age <= 4294967295 &&\n19 < input.age &&\ninput.age <= 100\n);\n};\nif (false === __is(input))\n((input, _path, _exceptionable = true) => {\nconst $guard = typia_1.default.assert.guard;\nconst $ao0 = (input, _path, _exceptionable = true) =>\n((\"string\" === typeof input.id &&\n(/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\ninput.id,\n) ||\n$guard(_exceptionable, {\npath: _path + \".id\",\nexpected: 'string & Format<\"uuid\">',\nvalue: input.id,\n}))) ||\n$guard(_exceptionable, {\npath: _path + \".id\",\nexpected: '(string & Format<\"uuid\">)',\nvalue: input.id,\n})) &&\n((\"string\" === typeof input.email &&\n(/^(([^<>()[].,;:s@\"]+(.[^<>()[].,;:s@\"]+)*)|(\".+\"))@(([^<>()[].,;:s@\"]+.)+[^<>()[].,;:s@\"]{2,})$/i.test(\ninput.email,\n) ||\n$guard(_exceptionable, {\npath: _path + \".email\",\nexpected: 'string & Format<\"email\">',\nvalue: input.email,\n}))) ||\n$guard(_exceptionable, {\npath: _path + \".email\",\nexpected: '(string & Format<\"email\">)',\nvalue: input.email,\n})) &&\n((\"number\" === typeof input.age &&\n((Math.floor(input.age) === input.age &&\n0 <= input.age &&\ninput.age <= 4294967295) ||\n$guard(_exceptionable, {\npath: _path + \".age\",\nexpected: 'number & Type<\"uint32\">',\nvalue: input.age,\n})) &&\n(19 < input.age ||\n$guard(_exceptionable, {\npath: _path + \".age\",\nexpected: \"number & ExclusiveMinimum<19>\",\nvalue: input.age,\n})) &&\n(input.age <= 100 ||\n$guard(_exceptionable, {\npath: _path + \".age\",\nexpected: \"number & Maximum<100>\",\nvalue: input.age,\n}))) ||\n$guard(_exceptionable, {\npath: _path + \".age\",\nexpected:\n'(number & Type<\"uint32\"> & ExclusiveMinimum<19> & Maximum<100>)',\nvalue: input.age,\n}));\nreturn (\n(((\"object\" === typeof input && null !== input) ||\n$guard(true, {\npath: _path + \"\",\nexpected: \"IMember\",\nvalue: input,\n})) &&\n$ao0(input, _path + \"\", true)) ||\n$guard(true, {\npath: _path + \"\",\nexpected: \"IMember\",\nvalue: input,\n})\n);\n})(input, \"$input\", true);\nreturn input;\n})({\nid: (0, uuid_1.v4)(),\nemail: \"samchon.github@gmail.com\",\nage: 30,\nsex: 1, // extra\n});","reusable-functions#Reusable functions":"export function createAssert<T>(): (input: unknown) => T;\nexport function createAssertEquals<T>(): (input: unknown) => T;\n\n\n\nexport class TypeGuardError extends Error {\npublic readonly method: string;\npublic readonly path: string | undefined;\npublic readonly expected: string;\npublic readonly value: any;\n}\n\n\nReusable typia.assert<T>() function generators.If you repeat to call typia.assert<T>() function on the same type, size of JavaScript files would be larger because of duplicated AOT compilation. To prevent it, you can generate reusable function through typia.createAssert<T>() function.Just look at the code below, then you may understand how to use it.\n\n\nimport typia, { tags } from \"typia\";\n\nexport const assertMember = typia.createAssert<IMember>();\n\ninterface IMember {\nid: string & tags.Format<\"uuid\">;\nemail: string & tags.Format<\"email\">;\nage: number\n& tags.Type<\"uint32\">\n& tags.ExclusiveMinimum<19>\n& tags.Maximum<100>;\n}\n\n\n\n\"use strict\";\nvar __importDefault =\n(this && this.__importDefault) ||\nfunction (mod) {\nreturn mod && mod.__esModule ? mod : { default: mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.assertMember = void 0;\nconst typia_1 = __importDefault(require(\"typia\"));\nconst assertMember = (input) => {\nconst __is = (input) => {\nreturn (\n\"object\" === typeof input &&\nnull !== input &&\n\"string\" === typeof input.id &&\n/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\ninput.id,\n) &&\n\"string\" === typeof input.email &&\n/^(([^<>()[].,;:s@\"]+(.[^<>()[].,;:s@\"]+)*)|(\".+\"))@(([^<>()[].,;:s@\"]+.)+[^<>()[].,;:s@\"]{2,})$/i.test(\ninput.email,\n) &&\n\"number\" === typeof input.age &&\nMath.floor(input.age) === input.age &&\n0 <= input.age &&\ninput.age <= 4294967295 &&\n19 < input.age &&\ninput.age <= 100\n);\n};\nif (false === __is(input))\n((input, _path, _exceptionable = true) => {\nconst $guard = typia_1.default.createAssert.guard;\nconst $ao0 = (input, _path, _exceptionable = true) =>\n((\"string\" === typeof input.id &&\n(/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\ninput.id,\n) ||\n$guard(_exceptionable, {\npath: _path + \".id\",\nexpected: 'string & Format<\"uuid\">',\nvalue: input.id,\n}))) ||\n$guard(_exceptionable, {\npath: _path + \".id\",\nexpected: '(string & Format<\"uuid\">)',\nvalue: input.id,\n})) &&\n((\"string\" === typeof input.email &&\n(/^(([^<>()[].,;:s@\"]+(.[^<>()[].,;:s@\"]+)*)|(\".+\"))@(([^<>()[].,;:s@\"]+.)+[^<>()[].,;:s@\"]{2,})$/i.test(\ninput.email,\n) ||\n$guard(_exceptionable, {\npath: _path + \".email\",\nexpected: 'string & Format<\"email\">',\nvalue: input.email,\n}))) ||\n$guard(_exceptionable, {\npath: _path + \".email\",\nexpected: '(string & Format<\"email\">)',\nvalue: input.email,\n})) &&\n((\"number\" === typeof input.age &&\n((Math.floor(input.age) === input.age &&\n0 <= input.age &&\ninput.age <= 4294967295) ||\n$guard(_exceptionable, {\npath: _path + \".age\",\nexpected: 'number & Type<\"uint32\">',\nvalue: input.age,\n})) &&\n(19 < input.age ||\n$guard(_exceptionable, {\npath: _path + \".age\",\nexpected: \"number & ExclusiveMinimum<19>\",\nvalue: input.age,\n})) &&\n(input.age <= 100 ||\n$guard(_exceptionable, {\npath: _path + \".age\",\nexpected: \"number & Maximum<100>\",\nvalue: input.age,\n}))) ||\n$guard(_exceptionable, {\npath: _path + \".age\",\nexpected:\n'(number & Type<\"uint32\"> & ExclusiveMinimum<19> & Maximum<100>)',\nvalue: input.age,\n}));\nreturn (\n(((\"object\" === typeof input && null !== input) ||\n$guard(true, {\npath: _path + \"\",\nexpected: \"IMember\",\nvalue: input,\n})) &&\n$ao0(input, _path + \"\", true)) ||\n$guard(true, {\npath: _path + \"\",\nexpected: \"IMember\",\nvalue: input,\n})\n);\n})(input, \"$input\", true);\nreturn input;\n};\nexports.assertMember = assertMember;","customization#Customization":"You can enhance validation logic by special tags.Also, with those tags, you can add your custom validation logic, too.If you want to know about such special tags detaily, read below article:\nSpecial Tags\nOutline\nType Tags\nComment Tags\nCustomization\n\n\n\n\n\n\nimport typia, { tags } from \"typia\";\n\nexport const assertSomething = typia.createAssert<Something>();\n\n//----\n// DEFINE CUSTOM TYPE TAGS\n//----\ntype Dollar = tags.TagBase<{\nkind: \"dollar\";\ntarget: \"string\";\nvalue: undefined;\nvalidate: `$input[0] === \"$\" && !isNaN(Number($input.substring(1).split(\",\").join(\"\")))`;\n}>;\n\ntype Postfix<Value extends string> = tags.TagBase<{\nkind: \"postfix\";\ntarget: \"string\";\nvalue: Value;\nvalidate: `$input.endsWith(\"${Value}\")`;\n}>;\n\ntype IsEven<Value extends number | bigint> = tags.TagBase<{\nkind: \"isEven\";\ntarget: Value extends number ? \"number\" : \"bigint\";\nvalue: undefined;\nvalidate: `$input % ${Numeric<2>} === ${Numeric<0>}`;\n}>;\n\ntype Numeric<Value extends number | bigint> = Value extends number\n? Value\n: `BigInt(${Value})`;\n\n//----\n// VALIDATION\n//----\ninterface Something {\ndollar: string & Dollar;\npostfix: string & Postfix<\"!!!\">;\nisEven: number & IsEven<number>;\n}\n\n\n\n\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\nreturn (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.assertSomething = void 0;\nconst typia_1 = __importDefault(require(\"typia\"));\nconst assertSomething = input => {\nconst __is = input => {\nreturn \"object\" === typeof input && null !== input && (\"string\" === typeof input.dollar && (input.dollar[0] === \"$\" && !isNaN(Number(input.dollar.substring(1).split(\",\").join(\"\")))) && (\"string\" === typeof input.postfix && input.postfix.endsWith(\"!!!\")) && (\"number\" === typeof input.isEven && input.isEven % 2 === 0));\n};\nif (false === __is(input))\n((input, _path, _exceptionable = true) => {\nconst $guard = typia_1.default.createAssert.guard;\nconst $ao0 = (input, _path, _exceptionable = true) => (\"string\" === typeof input.dollar && (input.dollar[0] === \"$\" && !isNaN(Number(input.dollar.substring(1).split(\",\").join(\"\"))) || $guard(_exceptionable, {\npath: _path + \".dollar\",\nexpected: \"string & Dollar\",\nvalue: input.dollar\n})) || $guard(_exceptionable, {\npath: _path + \".dollar\",\nexpected: \"(string & Dollar)\",\nvalue: input.dollar\n})) && (\"string\" === typeof input.postfix && (input.postfix.endsWith(\"!!!\") || $guard(_exceptionable, {\npath: _path + \".postfix\",\nexpected: \"string & Postfix<\\\"!!!\\\">\",\nvalue: input.postfix\n})) || $guard(_exceptionable, {\npath: _path + \".postfix\",\nexpected: \"(string & Postfix<\\\"!!!\\\">)\",\nvalue: input.postfix\n})) && (\"number\" === typeof input.isEven && (input.isEven % 2 === 0 || $guard(_exceptionable, {\npath: _path + \".isEven\",\nexpected: \"number & IsEven<number>\",\nvalue: input.isEven\n})) || $guard(_exceptionable, {\npath: _path + \".isEven\",\nexpected: \"(number & IsEven<number>)\",\nvalue: input.isEven\n}));\nreturn (\"object\" === typeof input && null !== input || $guard(true, {\npath: _path + \"\",\nexpected: \"Something\",\nvalue: input\n})) && $ao0(input, _path + \"\", true) || $guard(true, {\npath: _path + \"\",\nexpected: \"Something\",\nvalue: input\n});\n})(input, \"$input\", true);\nreturn input;\n};\nexports.assertSomething = assertSomething;","performance#Performance":"Super-fast and super-safe.Comparing typia.assert<T>() function with other competitive libraries, maximum 20,000x faster.Furthermore, only typia can validate complicate union types.\nMeasured on Intel i5-1135g7, Surface Pro 8\n\nComponents\ttypia\tTypeBox\tajv\tio-ts\tzod\tC.V.\tEasy to use\t✅\t❌\t❌\t❌\t❌\t❌\tObject (simple)\t✔\t✔\t✔\t✔\t✔\t✔\tObject (hierarchical)\t✔\t✔\t✔\t✔\t✔\t✔\tObject (recursive)\t✔\t❌\t✔\t✔\t✔\t✔\t✔\tObject (union, implicit)\t✅\t❌\t❌\t❌\t❌\t❌\tObject (union, explicit)\t✔\t✔\t✔\t✔\t✔\t❌\tObject (additional tags)\t✔\t✔\t✔\t✔\t✔\t✔\tObject (template literal types)\t✔\t✔\t✔\t❌\t❌\t❌\tObject (dynamic properties)\t✔\t✔\t✔\t❌\t❌\t❌\tArray (rest tuple)\t✅\t❌\t❌\t❌\t❌\t❌\tArray (hierarchical)\t✔\t✔\t✔\t✔\t✔\t✔\tArray (recursive)\t✔\t✔\t✔\t✔\t✔\t❌\tArray (recursive, union)\t✔\t✔\t❌\t✔\t✔\t❌\tArray (R+U, implicit)\t✅\t❌\t❌\t❌\t❌\t❌\tArray (repeated)\t✅\t❌\t❌\t❌\t❌\t❌\tArray (repeated, union)\t✅\t❌\t❌\t❌\t❌\t❌\tUltimate Union Type\t✅\t❌\t❌\t❌\t❌\t❌\n\nC.V. means class-validator"}},"/playground":{"title":"Index","data":{"":""}},"/docs/validators/validate":{"title":"Validate","data":{"":"","validate-function#validate() function":"export function validate<T>(input: T): IValidation<T>;\nexport function validate<T>(input: unknown): IValidation<T>;\n\n\n\nexport type IValidation<T> =\n| IValidation.ISuccess<T>\n| IValidation.IFailure;\nexport namespace IValidation {\nexport interface ISuccess<T> {\nsuccess: true;\ndata: T;\n}\nexport interface IFailure {\nsuccess: false;\nerrors: IError[];\n}\nexport interface IError {\npath: string;\nexpected: string;\nvalue: any;\n}\n}\n\n\nValidates a value type.typia.validate<T>() function validates input value type, and archives every type errors detaily into IValidation.IFailure.errors array, when the input value is not following the promised type T. Of course, if the parametric input value is following the type T, IValidation.ISuccess instance would be returned.In the below example case, as id and age values are different with its definition of IMember, such errors would be archived into the IValidation.IFailure.errors array.\nerrors[0]\npath: input.id\nexpected: string & Format<\"uuid\">\nvalue: 5\n\n\nerrors[1]\npath: input.age\nexpected: number & Format<\"uint32\">\nvalue: 20.75\n\n\n\n\n\n\n\nAOT compliation\nIf you'd used other competitive validator libraries like ajv or class-validator, you may found that typia does not require any extra schema definition. If you have not experienced them, I can sure that you may get shocked after reading below extra schema definition files.\najv requires JSON schema definition.\nclass-validator requires DTO class with decorator function calls.\n\nYeah, typia needs only pure TypeScript type. As typia is a compiler library, it can analyze TypeScript type by itself, and possible to write the optimal validation code like below. This is the key principle of typia, which needs only one line with pure TypeScript type.\n\n\n\nimport typia from \"typia\";\n\nconst res: typia.IValidation<IMember> = typia.validate<IMember>({\nid: 5, // wrong, must be string (uuid)\nage: 20.75, // wrong, not integer\nemail: \"samchon.github@gmail.com\",\n});\n\nif (!res.success) console.log(res.errors);\n\ninterface IMember {\nid: string & tags.Format<\"uuid\">;\nemail: string & tags.Format<\"email\">;\nage: number\n& tags.Type<\"uint32\">\n& tags.ExclusiveMinimum<19>\n& tags.Maximum<100>;\n}\n\n\n\n\"use strict\";\nvar __importDefault =\n(this && this.__importDefault) ||\nfunction (mod) {\nreturn mod && mod.__esModule ? mod : { default: mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst typia_1 = __importDefault(require(\"typia\"));\nconst res = ((input) => {\nconst errors = [];\nconst __is = (input) => {\nreturn (\n\"object\" === typeof input &&\nnull !== input &&\n\"string\" === typeof input.id &&\n/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\ninput.id,\n) &&\n\"string\" === typeof input.email &&\n/^(([^<>()[].,;:s@\"]+(.[^<>()[].,;:s@\"]+)*)|(\".+\"))@(([^<>()[].,;:s@\"]+.)+[^<>()[].,;:s@\"]{2,})$/i.test(\ninput.email,\n) &&\n\"number\" === typeof input.age &&\nMath.floor(input.age) === input.age &&\n0 <= input.age &&\ninput.age <= 4294967295 &&\n19 < input.age &&\ninput.age <= 100\n);\n};\nif (false === __is(input)) {\nconst $report = typia_1.default.validate.report(errors);\n((input, _path, _exceptionable = true) => {\nconst $vo0 = (input, _path, _exceptionable = true) =>\n[\n(\"string\" === typeof input.id &&\n(/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\ninput.id,\n) ||\n$report(_exceptionable, {\npath: _path + \".id\",\nexpected: 'string & Format<\"uuid\">',\nvalue: input.id,\n}))) ||\n$report(_exceptionable, {\npath: _path + \".id\",\nexpected: '(string & Format<\"uuid\">)',\nvalue: input.id,\n}),\n(\"string\" === typeof input.email &&\n(/^(([^<>()[].,;:s@\"]+(.[^<>()[].,;:s@\"]+)*)|(\".+\"))@(([^<>()[].,;:s@\"]+.)+[^<>()[].,;:s@\"]{2,})$/i.test(\ninput.email,\n) ||\n$report(_exceptionable, {\npath: _path + \".email\",\nexpected: 'string & Format<\"email\">',\nvalue: input.email,\n}))) ||\n$report(_exceptionable, {\npath: _path + \".email\",\nexpected: '(string & Format<\"email\">)',\nvalue: input.email,\n}),\n(\"number\" === typeof input.age &&\n((Math.floor(input.age) === input.age &&\n0 <= input.age &&\ninput.age <= 4294967295) ||\n$report(_exceptionable, {\npath: _path + \".age\",\nexpected: 'number & Type<\"uint32\">',\nvalue: input.age,\n})) &&\n(19 < input.age ||\n$report(_exceptionable, {\npath: _path + \".age\",\nexpected: \"number & ExclusiveMinimum<19>\",\nvalue: input.age,\n})) &&\n(input.age <= 100 ||\n$report(_exceptionable, {\npath: _path + \".age\",\nexpected: \"number & Maximum<100>\",\nvalue: input.age,\n}))) ||\n$report(_exceptionable, {\npath: _path + \".age\",\nexpected:\n'(number & Type<\"uint32\"> & ExclusiveMinimum<19> & Maximum<100>)',\nvalue: input.age,\n}),\n].every((flag) => flag);\nreturn (\n(((\"object\" === typeof input && null !== input) ||\n$report(true, {\npath: _path + \"\",\nexpected: \"IMember\",\nvalue: input,\n})) &&\n$vo0(input, _path + \"\", true)) ||\n$report(true, {\npath: _path + \"\",\nexpected: \"IMember\",\nvalue: input,\n})\n);\n})(input, \"$input\", true);\n}\nconst success = 0 === errors.length;\nreturn {\nsuccess,\nerrors,\ndata: success ? input : undefined,\n};\n})({\nid: 5,\nage: 20.75,\nemail: \"samchon.github@gmail.com\",\n});\nif (!res.success) console.log(res.errors);","validateequals-function#validateEquals() function":"export function validateEquals<T>(input: T): IValidation<T>;\nexport function validateEquals<T>(input: unknown): IValidation<T>;\n\n\n\nexport type IValidation<T> =\n| IValidation.ISuccess<T>\n| IValidation.IFailure;\nexport namespace IValidation {\nexport interface ISuccess<T> {\nsuccess: true;\ndata: T;\n}\nexport interface IFailure {\nsuccess: false;\nerrors: IError[];\n}\nexport interface IError {\npath: string;\nexpected: string;\nvalue: any;\n}\n}\n\n\nMore strict validatae function prohibiting superfluous properties.typia.validate<T> function detects every type errors of input value, however, it can't detect superfluous properties. If you want to prohibit those superfluous properties, so that archive them into IValidation.IFailure.errors array, use typia.validateEquals<T>() function instead.In the below example case, as id property is different with its type definition and sex property is not defined in the IMember type, such errors would be archived into the IValidation.IFailure.errors array:\nerrors[0]\npath: input.id\nexpected: string (@format uuid)\nvalue: something\n\n\nerrors[1]\npath: input.sex\nexpected: undefined\nvalue: 1\n\n\n\n\n\n\nimport typia, { tags } from \"typia\";\n\nconst res: typia.IValidation<IMember> = typia.validateEquals<IMember>({\nage: 30,\nemail: \"samchon.github@gmail.com\",\nid: \"something\", // wrong, must be string (uuid)\nsex: 1, // extra property\n});\n\nif (!res.success) console.log(res.errors);\n\ninterface IMember {\nid: string & tags.Format<\"uuid\">;\nemail: string & tags.Format<\"email\">;\nage: number\n& tags.Type<\"uint32\">\n& tags.ExclusiveMinimum<19>\n& tags.Maximum<100>;\n}\n\n\n\n\"use strict\";\nvar __importDefault =\n(this && this.__importDefault) ||\nfunction (mod) {\nreturn mod && mod.__esModule ? mod : { default: mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst typia_1 = __importDefault(require(\"typia\"));\nconst res = ((input) => {\nconst errors = [];\nconst __is = (input, _exceptionable = true) => {\nconst $io0 = (input, _exceptionable = true) =>\n\"string\" === typeof input.id &&\n/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\ninput.id,\n) &&\n\"string\" === typeof input.email &&\n/^(([^<>()[].,;:s@\"]+(.[^<>()[].,;:s@\"]+)*)|(\".+\"))@(([^<>()[].,;:s@\"]+.)+[^<>()[].,;:s@\"]{2,})$/i.test(\ninput.email,\n) &&\n\"number\" === typeof input.age &&\nMath.floor(input.age) === input.age &&\n0 <= input.age &&\ninput.age <= 4294967295 &&\n19 < input.age &&\ninput.age <= 100 &&\n(3 === Object.keys(input).length ||\nObject.keys(input).every((key) => {\nif ([\"id\", \"email\", \"age\"].some((prop) => key === prop))\nreturn true;\nconst value = input[key];\nif (undefined === value) return true;\nreturn false;\n}));\nreturn \"object\" === typeof input && null !== input && $io0(input, true);\n};\nif (false === __is(input)) {\nconst $report = typia_1.default.validateEquals.report(errors);\n((input, _path, _exceptionable = true) => {\nconst $join = typia_1.default.validateEquals.join;\nconst $vo0 = (input, _path, _exceptionable = true) =>\n[\n(\"string\" === typeof input.id &&\n(/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\ninput.id,\n) ||\n$report(_exceptionable, {\npath: _path + \".id\",\nexpected: 'string & Format<\"uuid\">',\nvalue: input.id,\n}))) ||\n$report(_exceptionable, {\npath: _path + \".id\",\nexpected: '(string & Format<\"uuid\">)',\nvalue: input.id,\n}),\n(\"string\" === typeof input.email &&\n(/^(([^<>()[].,;:s@\"]+(.[^<>()[].,;:s@\"]+)*)|(\".+\"))@(([^<>()[].,;:s@\"]+.)+[^<>()[].,;:s@\"]{2,})$/i.test(\ninput.email,\n) ||\n$report(_exceptionable, {\npath: _path + \".email\",\nexpected: 'string & Format<\"email\">',\nvalue: input.email,\n}))) ||\n$report(_exceptionable, {\npath: _path + \".email\",\nexpected: '(string & Format<\"email\">)',\nvalue: input.email,\n}),\n(\"number\" === typeof input.age &&\n((Math.floor(input.age) === input.age &&\n0 <= input.age &&\ninput.age <= 4294967295) ||\n$report(_exceptionable, {\npath: _path + \".age\",\nexpected: 'number & Type<\"uint32\">',\nvalue: input.age,\n})) &&\n(19 < input.age ||\n$report(_exceptionable, {\npath: _path + \".age\",\nexpected: \"number & ExclusiveMinimum<19>\",\nvalue: input.age,\n})) &&\n(input.age <= 100 ||\n$report(_exceptionable, {\npath: _path + \".age\",\nexpected: \"number & Maximum<100>\",\nvalue: input.age,\n}))) ||\n$report(_exceptionable, {\npath: _path + \".age\",\nexpected:\n'(number & Type<\"uint32\"> & ExclusiveMinimum<19> & Maximum<100>)',\nvalue: input.age,\n}),\n3 === Object.keys(input).length ||\nfalse === _exceptionable ||\nObject.keys(input)\n.map((key) => {\nif (\n[\"id\", \"email\", \"age\"].some(\n(prop) => key === prop,\n)\n)\nreturn true;\nconst value = input[key];\nif (undefined === value) return true;\nreturn $report(_exceptionable, {\npath: _path + $join(key),\nexpected: \"undefined\",\nvalue: value,\n});\n})\n.every((flag) => flag),\n].every((flag) => flag);\nreturn (\n(((\"object\" === typeof input && null !== input) ||\n$report(true, {\npath: _path + \"\",\nexpected: \"IMember\",\nvalue: input,\n})) &&\n$vo0(input, _path + \"\", true)) ||\n$report(true, {\npath: _path + \"\",\nexpected: \"IMember\",\nvalue: input,\n})\n);\n})(input, \"$input\", true);\n}\nconst success = 0 === errors.length;\nreturn {\nsuccess,\nerrors,\ndata: success ? input : undefined,\n};\n})({\nage: 30,\nemail: \"samchon.github@gmail.com\",\nid: \"something\",\nsex: 1, // extra property\n});\nif (!res.success) console.log(res.errors);","reusable-functions#Reusable functions":"export function createValidate<T> = (input: unknown) => IValidation<T>;\nexport function createValidateEquals<T> = (input: unknown) => IValidation<T>;\n\n\n\nexport type IValidation<T> =\n| IValidation.ISuccess<T>\n| IValidation.IFailure;\nexport namespace IValidation {\nexport interface ISuccess<T> {\nsuccess: true;\ndata: T;\n}\nexport interface IFailure {\nsuccess: false;\nerrors: IError[];\n}\nexport interface IError {\npath: string;\nexpected: string;\nvalue: any;\n}\n}\n\n\nReusable typia.validate<T>() function generators.If you repeat to call typia.validate<T>() function on the same type, size of JavaScript files would be larger because of duplicated AOT compilation. To prevent it, you can generate reusable function through typia.createValidate<T>() function.Just look at the code below, then you may understand how to use it.\n\n\nimport typia, { tags } from \"typia\";\n\nexport const validateMember = typia.createValidate<IMember>();\n\ninterface IMember {\nid: string & tags.Format<\"uuid\">;\nemail: string & tags.Format<\"email\">;\nage: number\n& tags.Type<\"uint32\">\n& tags.ExclusiveMinimum<19>\n& tags.Maximum<100>;\n}\n\n\n\n\"use strict\";\nvar __importDefault =\n(this && this.__importDefault) ||\nfunction (mod) {\nreturn mod && mod.__esModule ? mod : { default: mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateMember = void 0;\nconst typia_1 = __importDefault(require(\"typia\"));\nconst validateMember = (input) => {\nconst errors = [];\nconst __is = (input) => {\nreturn (\n\"object\" === typeof input &&\nnull !== input &&\n\"string\" === typeof input.id &&\n/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\ninput.id,\n) &&\n\"string\" === typeof input.email &&\n/^(([^<>()[].,;:s@\"]+(.[^<>()[].,;:s@\"]+)*)|(\".+\"))@(([^<>()[].,;:s@\"]+.)+[^<>()[].,;:s@\"]{2,})$/i.test(\ninput.email,\n) &&\n\"number\" === typeof input.age &&\nMath.floor(input.age) === input.age &&\n0 <= input.age &&\ninput.age <= 4294967295 &&\n19 < input.age &&\ninput.age <= 100\n);\n};\nif (false === __is(input)) {\nconst $report = typia_1.default.createValidate.report(errors);\n((input, _path, _exceptionable = true) => {\nconst $vo0 = (input, _path, _exceptionable = true) =>\n[\n(\"string\" === typeof input.id &&\n(/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\ninput.id,\n) ||\n$report(_exceptionable, {\npath: _path + \".id\",\nexpected: 'string & Format<\"uuid\">',\nvalue: input.id,\n}))) ||\n$report(_exceptionable, {\npath: _path + \".id\",\nexpected: '(string & Format<\"uuid\">)',\nvalue: input.id,\n}),\n(\"string\" === typeof input.email &&\n(/^(([^<>()[].,;:s@\"]+(.[^<>()[].,;:s@\"]+)*)|(\".+\"))@(([^<>()[].,;:s@\"]+.)+[^<>()[].,;:s@\"]{2,})$/i.test(\ninput.email,\n) ||\n$report(_exceptionable, {\npath: _path + \".email\",\nexpected: 'string & Format<\"email\">',\nvalue: input.email,\n}))) ||\n$report(_exceptionable, {\npath: _path + \".email\",\nexpected: '(string & Format<\"email\">)',\nvalue: input.email,\n}),\n(\"number\" === typeof input.age &&\n((Math.floor(input.age) === input.age &&\n0 <= input.age &&\ninput.age <= 4294967295) ||\n$report(_exceptionable, {\npath: _path + \".age\",\nexpected: 'number & Type<\"uint32\">',\nvalue: input.age,\n})) &&\n(19 < input.age ||\n$report(_exceptionable, {\npath: _path + \".age\",\nexpected: \"number & ExclusiveMinimum<19>\",\nvalue: input.age,\n})) &&\n(input.age <= 100 ||\n$report(_exceptionable, {\npath: _path + \".age\",\nexpected: \"number & Maximum<100>\",\nvalue: input.age,\n}))) ||\n$report(_exceptionable, {\npath: _path + \".age\",\nexpected:\n'(number & Type<\"uint32\"> & ExclusiveMinimum<19> & Maximum<100>)',\nvalue: input.age,\n}),\n].every((flag) => flag);\nreturn (\n(((\"object\" === typeof input && null !== input) ||\n$report(true, {\npath: _path + \"\",\nexpected: \"IMember\",\nvalue: input,\n})) &&\n$vo0(input, _path + \"\", true)) ||\n$report(true, {\npath: _path + \"\",\nexpected: \"IMember\",\nvalue: input,\n})\n);\n})(input, \"$input\", true);\n}\nconst success = 0 === errors.length;\nreturn {\nsuccess,\nerrors,\ndata: success ? input : undefined,\n};\n};\nexports.validateMember = validateMember;","discriminated-union#Discriminated Union":"export function validate<T>(input: T): IValidation<T>;\nexport function validate<T>(input: unknown): IValidation<T>;\nexport function createValidate<T>(): (input: unknown) => IValidation<T>;\n\n\n\nexport type IValidation<T> =\n| IValidation.ISuccess<T>\n| IValidation.IFailure;\nexport namespace IValidation {\nexport interface ISuccess<T> {\nsuccess: true;\ndata: T;\n}\nexport interface IFailure {\nsuccess: false;\nerrors: IError[];\n}\nexport interface IError {\npath: string;\nexpected: string;\nvalue: any;\n}\n}\n\n\nSpecify type through if condition.typia.IValidation<T> is an union type of typia.IValidation.ISuccess<T> and typia.IValidation.IFailure. Also, they have a common property success of boolean type, but different literal values. In that case, if you write a if condition about the success property, you can specify the union type like below.In TypeScript, such union type specification through common property (of different literal value() is called \"Discriminated Union\". Therefore, when using typia.validate<T>() function, let's utilize such discriminated union specification for convenience.\nimport typia from \"typia\";\n\nconst something: unknown = ...;\nconst result: typia.IValidation<string> = typia.validate<string>(something);\n\nif (results.success) {\n// become typia.IValidation.Success<string> type\nresult.data; // accessible\n}\nelse {\n// become typia.IValidation.Failure type\nresult.errors; //accessible\n}","customization#Customization":"You can enhance validation logic by special tags.Also, with those tags, you can add your custom validation logic, too.If you want to know about such special tags detaily, read below article:\nSpecial Tags\nOutline\nType Tags\nComment Tags\nCustomization\n\n\n\n\n\n\nimport typia, { tags } from \"typia\";\n\nexport const validateSomething = typia.createValidate<Something>();\n\n//----\n// DEFINE CUSTOM TYPE TAGS\n//----\ntype Dollar = tags.TagBase<{\nkind: \"dollar\";\ntarget: \"string\";\nvalue: undefined;\nvalidate: `$input[0] === \"$\" && !isNaN(Number($input.substring(1).split(\",\").join(\"\")))`;\n}>;\n\ntype Postfix<Value extends string> = tags.TagBase<{\nkind: \"postfix\";\ntarget: \"string\";\nvalue: Value;\nvalidate: `$input.endsWith(\"${Value}\")`;\n}>;\n\ntype IsEven<Value extends number | bigint> = tags.TagBase<{\nkind: \"isEven\";\ntarget: Value extends number ? \"number\" : \"bigint\";\nvalue: undefined;\nvalidate: `$input % ${Numeric<2>} === ${Numeric<0>}`;\n}>;\n\ntype Numeric<Value extends number | bigint> = Value extends number\n? Value\n: `BigInt(${Value})`;\n\n//----\n// VALIDATION\n//----\ninterface Something {\ndollar: string & Dollar;\npostfix: string & Postfix<\"!!!\">;\nisEven: number & IsEven<number>;\n}\n\n\n\n\"use strict\";\nvar __importDefault =\n(this && this.__importDefault) ||\nfunction (mod) {\nreturn mod && mod.__esModule ? mod : { default: mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateSomething = void 0;\nconst typia_1 = __importDefault(require(\"typia\"));\nconst validateSomething = (input) => {\nconst errors = [];\nconst __is = (input) => {\nreturn (\n\"object\" === typeof input &&\nnull !== input &&\n\"string\" === typeof input.dollar &&\ninput.dollar[0] === \"$\" &&\n!isNaN(Number(input.dollar.substring(1).split(\",\").join(\"\"))) &&\n\"string\" === typeof input.postfix &&\ninput.postfix.endsWith(\"!!!\") &&\n\"number\" === typeof input.isEven &&\ninput.isEven % 2 === 0\n);\n};\nif (false === __is(input)) {\nconst $report = typia_1.default.createValidate.report(errors);\n((input, _path, _exceptionable = true) => {\nconst $vo0 = (input, _path, _exceptionable = true) =>\n[\n(\"string\" === typeof input.dollar &&\n((input.dollar[0] === \"$\" &&\n!isNaN(\nNumber(\ninput.dollar\n.substring(1)\n.split(\",\")\n.join(\"\"),\n),\n)) ||\n$report(_exceptionable, {\npath: _path + \".dollar\",\nexpected: \"string & Dollar\",\nvalue: input.dollar,\n}))) ||\n$report(_exceptionable, {\npath: _path + \".dollar\",\nexpected: \"(string & Dollar)\",\nvalue: input.dollar,\n}),\n(\"string\" === typeof input.postfix &&\n(input.postfix.endsWith(\"!!!\") ||\n$report(_exceptionable, {\npath: _path + \".postfix\",\nexpected: 'string & Postfix<\"!!!\">',\nvalue: input.postfix,\n}))) ||\n$report(_exceptionable, {\npath: _path + \".postfix\",\nexpected: '(string & Postfix<\"!!!\">)',\nvalue: input.postfix,\n}),\n(\"number\" === typeof input.isEven &&\n(input.isEven % 2 === 0 ||\n$report(_exceptionable, {\npath: _path + \".isEven\",\nexpected: \"number & IsEven<number>\",\nvalue: input.isEven,\n}))) ||\n$report(_exceptionable, {\npath: _path + \".isEven\",\nexpected: \"(number & IsEven<number>)\",\nvalue: input.isEven,\n}),\n].every((flag) => flag);\nreturn (\n(((\"object\" === typeof input && null !== input) ||\n$report(true, {\npath: _path + \"\",\nexpected: \"Something\",\nvalue: input,\n})) &&\n$vo0(input, _path + \"\", true)) ||\n$report(true, {\npath: _path + \"\",\nexpected: \"Something\",\nvalue: input,\n})\n);\n})(input, \"$input\", true);\n}\nconst success = 0 === errors.length;\nreturn {\nsuccess,\nerrors,\ndata: success ? input : undefined,\n};\n};\nexports.validateSomething = validateSomething;","performance#Performance":"Super-fast and super-safe.Comparing typia.validate<T>() function with other competitive libraries, maximum 20,000x faster.Furthermore, only typia can validate complicate union types.\nMeasured on Intel i5-1135g7, Surface Pro 8\n\nComponents\ttypia\tTypeBox\tajv\tio-ts\tzod\tC.V.\tEasy to use\t✅\t❌\t❌\t❌\t❌\t❌\tObject (simple)\t✔\t✔\t✔\t✔\t✔\t✔\tObject (hierarchical)\t✔\t✔\t✔\t✔\t✔\t✔\tObject (recursive)\t✔\t❌\t✔\t✔\t✔\t✔\t✔\tObject (union, implicit)\t✅\t❌\t❌\t❌\t❌\t❌\tObject (union, explicit)\t✔\t✔\t✔\t✔\t✔\t❌\tObject (additional tags)\t✔\t✔\t✔\t✔\t✔\t✔\tObject (template literal types)\t✔\t✔\t✔\t❌\t❌\t❌\tObject (dynamic properties)\t✔\t✔\t✔\t❌\t❌\t❌\tArray (rest tuple)\t✅\t❌\t❌\t❌\t❌\t❌\tArray (hierarchical)\t✔\t✔\t✔\t✔\t✔\t✔\tArray (recursive)\t✔\t✔\t✔\t✔\t✔\t❌\tArray (recursive, union)\t✔\t✔\t❌\t✔\t✔\t❌\tArray (R+U, implicit)\t✅\t❌\t❌\t❌\t❌\t❌\tArray (repeated)\t✅\t❌\t❌\t❌\t❌\t❌\tArray (repeated, union)\t✅\t❌\t❌\t❌\t❌\t❌\tUltimate Union Type\t✅\t❌\t❌\t❌\t❌\t❌\n\nC.V. means class-validator"}},"/docs/pure":{"title":"Pure TypeScript","data":{"":"","outline#Outline":"typia.assert<IBbsArticle>(article);\ntypia needs only one line with pure TypeScript type.You know what? Every other validator libraries need extra schema definition, that is different with pure TypeScript type. For an example, class-validator is the most famouse validator due to used in NestJS. However, NestJS and class-validator force you to define triple duplicated DTO schema.\nTypeScript Type\nclass-validator decorators\n@nestjs/swagger decorators\n\nAnother famous validator library ajv requires JSON schema definition. Move to the #Demonstration, and click the ajv (JSON Schema) tab, then you may understand how it terrible. It requires hundreds of lines of JSON schema definition even just for a simple DTO.Those duplicated schema definitions are not only annoying, but also error-prone. If you take any mistake on the extra schema definition, such mistake can't be detected by TypeScript compiler. It will be detected only at runtime, therefore become a critical runtime error. Another words, it is not type safe.Besides, typia only needs pure TypeScript type. You don't need to define any extra schema like class-validator or ajv. Just define pure TypeScript type only (especially recommend to use interface type), then typia will do all the rest.","demonstration#Demonstration":"If you're confusing how typia is different with others, just see example codes below.At first, look at the first (class-validator) tab, and find the BbsArticle.files property, enhanced by blue coloured blocks. Looking at the files property, how do you feel? Just defining an array object type, you've to call 7 decorator functions. If you take any mistake when using the decorator like omitting isArray property, it would be a critical runtime erorr.Besides, typia needs only one line. Click the third (typia) tab, and find the IAttachmentFile.files property. Only one line being used, and they are even not class, but just interface types. Comparing it to the first and second tabs, how do you feel? Isn't it more simple and readable?This is the power of typia, with pure TypeScript type.\n\n\nimport { ApiProperty } from \"@nestjs/swagger\";\nimport { ArrayNotEmpty, IsArray, IsObject, IsOptional, IsString, Match, MaxLength, Type, ValidateNested } from \"class-validator\";\n\nexport class BbsArticle {\n@ApiProperty({\nformat: \"uuid\",\n})\n@IsString()\nid!: string;\n\n// DUPLICATED SCHEMA DEFINITION\n// - duplicated function call + property type\n// - have to specify `isArray` and `nullable` props by yourself\n@ApiProperty({\ntype: () => AttachmentFile,\nnullable: true,\nisArray: true,\nminItems: 1,\ndescription: \"List of attached files.\",\n})\n@Type(() => AttachmentFile)\n@IsArray()\n@ArrayNotEmpty()\n@IsOptional()\n@IsObject({ each: true })\n@ValidateNested({ each: true })\nfiles!: AttachmentFile[] | null;\n\n@ApiProperty({\ntype: \"string\",\nnullable: true,\nminLength: 5,\nmaxLength: 100,\ndescription: \"Title of the article.\",\n})\n@IsOptional()\n@IsString()\ntitle!: string | null;\n\n@ApiProperty({\ndescription: \"Main content body of the article.\"\n})\n@IsString()\nbody!: string;\n\n@ApiProperty({\nformat: \"date-time\",\ndescription: \"Creation time of article\",\n})\n@IsString()\ncreated_at!: string;\n}\n\nexport class AttachmentFile {\n@ApiProperty({\ntype: \"string\",\nnullable: true,\nmaxLength: 255,\npattern: \"^[a-zA-Z0-9-_]+$\",\ndescription: \"File name.\",\n})\n@Matches(/^[a-z0-9]+$/)\n@MaxLength(255)\n@IsOptional()\n@IsString()\nname!: string | null;\n\n@ApiProperty({\ntype: \"string\",\nnullable: true,\nmaxLength: 255,\npattern: \"^[a-zA-Z0-9-_]+$\",\ndescription: \"File extension.\",\n})\n@Matches(/^[a-z0-9]+$/)\n@MaxLength(8)\n@IsOptional()\n@IsString()\nextension!: string | null;\n\n@ApiProperty({\nformat: \"url\",\ndescription: \"URL of the file.\",\n})\n@IsString()\nurl!: string;\n}\n\n\n\n{\n\"schemas\": [\n{\n\"$ref\": \"components#/schemas/IBbsArticle\"\n}\n],\n\"components\": {\n\"schemas\": {\n\"IBbsArticle\": {\n\"$id\": \"components#/schemas/IBbsArticle\",\n\"type\": \"object\",\n\"properties\": {\n\"id\": {\n\"type\": \"string\",\n\"nullable\": false,\n\"description\": \"Primary Key.\",\n\"x-typia-metaTags\": [\n{\n\"kind\": \"format\",\n\"value\": \"uuid\"\n}\n],\n\"x-typia-jsDocTags\": [\n{\n\"name\": \"format\",\n\"text\": [\n{\n\"text\": \"uuid\",\n\"kind\": \"text\"\n}\n]\n}\n],\n\"x-typia-required\": true,\n\"x-typia-optional\": false,\n\"format\": \"uuid\"\n},\n\"files\": {\n\"type\": \"array\",\n\"items\": {\n\"$ref\": \"components#/schemas/IAttachmentFile\",\n\"description\": \"List of attached files.\",\n\"minItems\": 1,\n\"x-typia-required\": true,\n\"x-typia-optional\": false\n},\n\"nullable\": true,\n\"description\": \"List of attached files.\",\n\"x-typia-required\": true,\n\"x-typia-optional\": false\n},\n\"title\": {\n\"type\": \"string\",\n\"nullable\": true,\n\"description\": \"Title of the article.\",\n\"x-typia-metaTags\": [\n{\n\"kind\": \"minLength\",\n\"value\": 5\n},\n{\n\"kind\": \"maxLength\",\n\"value\": 100\n}\n],\n\"x-typia-jsDocTags\": [\n{\n\"name\": \"minLength\",\n\"text\": [\n{\n\"text\": \"5\",\n\"kind\": \"text\"\n}\n]\n},\n{\n\"name\": \"maxLength\",\n\"text\": [\n{\n\"text\": \"100\",\n\"kind\": \"text\"\n}\n]\n}\n],\n\"x-typia-required\": true,\n\"x-typia-optional\": false,\n\"minLength\": 5,\n\"maxLength\": 100\n},\n\"body\": {\n\"type\": \"string\",\n\"nullable\": false,\n\"description\": \"Main content body of the article.\",\n\"x-typia-required\": true,\n\"x-typia-optional\": false\n},\n\"created_at\": {\n\"type\": \"string\",\n\"nullable\": false,\n\"description\": \"Creation time of article.\",\n\"x-typia-metaTags\": [\n{\n\"kind\": \"format\",\n\"value\": \"datetime\"\n}\n],\n\"x-typia-jsDocTags\": [\n{\n\"name\": \"format\",\n\"text\": [\n{\n\"text\": \"date-time\",\n\"kind\": \"text\"\n}\n]\n}\n],\n\"x-typia-required\": true,\n\"x-typia-optional\": false,\n\"format\": \"date-time\"\n}\n},\n\"nullable\": false,\n\"required\": [\n\"id\",\n\"files\",\n\"title\",\n\"body\",\n\"created_at\"\n],\n\"x-typia-jsDocTags\": []\n},\n\"IAttachmentFile\": {\n\"$id\": \"components#/schemas/IAttachmentFile\",\n\"type\": \"object\",\n\"properties\": {\n\"name\": {\n\"type\": \"string\",\n\"nullable\": true,\n\"description\": \"File name.\",\n\"x-typia-metaTags\": [\n{\n\"kind\": \"pattern\",\n\"value\": \"^[a-z0-9]+$\"\n},\n{\n\"kind\": \"maxLength\",\n\"value\": 255\n}\n],\n\"x-typia-jsDocTags\": [\n{\n\"name\": \"pattern\",\n\"text\": [\n{\n\"text\": \"^[a-z0-9]+$\",\n\"kind\": \"text\"\n}\n]\n},\n{\n\"name\": \"maxLength\",\n\"text\": [\n{\n\"text\": \"255\",\n\"kind\": \"text\"\n}\n]\n}\n],\n\"x-typia-required\": true,\n\"x-typia-optional\": false,\n\"pattern\": \"^[a-z0-9]+$\",\n\"maxLength\": 255\n},\n\"extension\": {\n\"type\": \"string\",\n\"nullable\": true,\n\"description\": \"File extension.\",\n\"x-typia-metaTags\": [\n{\n\"kind\": \"pattern\",\n\"value\": \"^[a-z0-9]+$\"\n},\n{\n\"kind\": \"maxLength\",\n\"value\": 8\n}\n],\n\"x-typia-jsDocTags\": [\n{\n\"name\": \"pattern\",\n\"text\": [\n{\n\"text\": \"^[a-z0-9]+$\",\n\"kind\": \"text\"\n}\n]\n},\n{\n\"name\": \"maxLength\",\n\"text\": [\n{\n\"text\": \"8\",\n\"kind\": \"text\"\n}\n]\n}\n],\n\"x-typia-required\": true,\n\"x-typia-optional\": false,\n\"pattern\": \"^[a-z0-9]+$\",\n\"maxLength\": 8\n},\n\"url\": {\n\"type\": \"string\",\n\"nullable\": false,\n\"description\": \"URL of the file.\",\n\"x-typia-jsDocTags\": [\n{\n\"name\": \"format\",\n\"text\": [\n{\n\"text\": \"uri\",\n\"kind\": \"text\"\n}\n]\n}\n],\n\"x-typia-required\": true,\n\"x-typia-optional\": false,\n\"format\": \"uri\"\n}\n},\n\"nullable\": false,\n\"required\": [\n\"name\",\n\"extension\",\n\"url\"\n],\n\"x-typia-jsDocTags\": []\n}\n}\n},\n\"purpose\": \"ajv\",\n\"prefix\": \"components#/schemas\"\n}\n\n\n\nimport { tags } from \"typia\";\n\nexport interface IBbsArticle {\n/**\n* Primary Key.\n*/\nid: string & tags.Format<\"uuid\">;\n\n/**\n* List of attached files.\n*/\nfiles: null | (IAttachmentFile[] & tags.MinItems<1>);\n\n/**\n* Title of the article.\n*/\ntitle: null | (string & tags.MinLength<5> & tags.MaxLength<100>);\n\n/**\n* Main content body of the article.\n*/\nbody: string;\n\n/**\n* Creation time of article.\n*/\ncreated_at: string & tags.Format<\"datetime\">;\n}\n\nexport interface IAttachmentFile {\n/**\n* File name.\n*/\nname:\n| null\n| (string & tags.Pattern<\"^[a-z0-9]+$\"> & tags.MaxLength<255>);\n\n/**\n* File extension.\n*/\nextension:\n| null\n| (string & tags.Pattern<\"^[a-z0-9]+$\"> & tags.MaxLength<8>);\n\n/**\n* URL of the file.\n*/\nurl: string & tags.Format<\"uri\">;\n}","aot-compilation#AOT Compilation":"Someone may be suspicious of the phrase \"Pure TypeScript Type\".\n\"As you know, TypeScript types do not have any tangible instance when compiled to JS.However, with only these fictitious TypeScript types, how can typia validates types at runtime? How typia builds much faster JSON serializer only with these types? Are these things really possible without extra schema definition like class-validator or ajv?\"\nMy answer is: \"Yes, it is possible due to typia analyzes your server code, and performs AOT compilation\".Such compile time optimization is called AOT (Ahead of Time) compilation. And this is the secret why typia can do everything with only pure TypeScript type. Read below example codes, and just look how JavaScript file being compiled. Then you may understand why typia is much easier, and futhermore much faster.\nRuntime validator is 20,000x faster than class-validator\nJSON serialization is 200x faster than class-transformer\n\n\n\n\nexport interface IBbsArticle {\n/**\n* Primary Key.\n*\n* @format uuid\n*/\nid: string;\n\n/**\n* List of attached files.\n*\n* @minItems 1\n*/\nfiles: IAttachmentFile[] | null;\n\n/**\n* Title of the article.\n*\n* @minLength 5\n* @maxLength 100\n*/\ntitle: string | null;\n\n/**\n* Main content body of the article.\n*/\nbody: string;\n\n/**\n* Creation time of article.\n*\n* @format date-time\n*/\ncreated_at: string;\n}\n\nexport interface IAttachmentFile {\n/**\n* File name.\n*\n* @pattern ^[a-z0-9]+$\n* @maxLength 255\n*/\nname: string | null;\n\n/**\n* File extension.\n*\n* @pattern ^[a-z0-9]+$\n* @maxLength 8\n*/\nextension: string | null;\n\n/**\n* URL of the file.\n*\n* @format uri\n*/\nurl: string;\n}\n\n\n\nimport typia from \"typia\";\n\nimport { IBbsArticle } from \"./IBbsArticle\";\n\nexport const assertArticle = typia.createAssert<IBbsArticle>();\n\n\n\n\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\nreturn (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.assertArticle = void 0;\nconst typia_1 = __importDefault(require(\"typia\"));\nconst assertArticle = input => {\nconst $guard = typia_1.default.createAssert.guard;\nconst $is_uuid = typia_1.default.createAssert.is_uuid;\nconst $is_datetime = typia_1.default.createAssert.is_datetime;\nconst __is = input => {\nconst $is_uuid = typia_1.default.createAssert.is_uuid;\nconst $is_datetime = typia_1.default.createAssert.is_datetime;\nconst $io0 = input => \"string\" === typeof input.id && $is_uuid(input.id) && (null === input.files || Array.isArray(input.files) && 1 <= input.files.length && input.files.every(elem => \"object\" === typeof elem && null !== elem && $io1(elem))) && (null === input.title || \"string\" === typeof input.title && 5 <= input.title.length && 100 >= input.title.length) && \"string\" === typeof input.body && (\"string\" === typeof input.created_at && $is_datetime(input.created_at));\nconst $io1 = input => (null === input.name || \"string\" === typeof input.name && RegExp(/^[a-z0-9]+$/).test(input.name) && 255 >= input.name.length) && (null === input.extension || \"string\" === typeof input.extension && RegExp(/^[a-z0-9]+$/).test(input.extension) && 8 >= input.extension.length) && \"string\" === typeof input.url;\nreturn \"object\" === typeof input && null !== input && $io0(input);\n};\nif (false === __is(input))\n((input, _path, _exceptionable = true) => {\nconst $ao0 = (input, _path, _exceptionable = true) => (\"string\" === typeof input.id && ($is_uuid(input.id) || $guard(_exceptionable, {\npath: _path + \".id\",\nexpected: \"string (@format uuid)\",\nvalue: input.id\n})) || $guard(_exceptionable, {\npath: _path + \".id\",\nexpected: \"string\",\nvalue: input.id\n})) && (null === input.files || (Array.isArray(input.files) && (1 <= input.files.length || $guard(_exceptionable, {\npath: _path + \".files\",\nexpected: \"Array.length (@minItems 1)\",\nvalue: input.files\n})) || $guard(_exceptionable, {\npath: _path + \".files\",\nexpected: \"(Array<IAttachmentFile> | null)\",\nvalue: input.files\n})) && input.files.every((elem, _index1) => (\"object\" === typeof elem && null !== elem || $guard(_exceptionable, {\npath: _path + \".files[\" + _index1 + \"]\",\nexpected: \"IAttachmentFile\",\nvalue: elem\n})) && $ao1(elem, _path + \".files[\" + _index1 + \"]\", true && _exceptionable))) && (null === input.title || \"string\" === typeof input.title && (5 <= input.title.length || $guard(_exceptionable, {\npath: _path + \".title\",\nexpected: \"string (@minLength 5)\",\nvalue: input.title\n})) && (100 >= input.title.length || $guard(_exceptionable, {\npath: _path + \".title\",\nexpected: \"string (@maxLength 100)\",\nvalue: input.title\n})) || $guard(_exceptionable, {\npath: _path + \".title\",\nexpected: \"(null | string)\",\nvalue: input.title\n})) && (\"string\" === typeof input.body || $guard(_exceptionable, {\npath: _path + \".body\",\nexpected: \"string\",\nvalue: input.body\n})) && (\"string\" === typeof input.created_at && ($is_datetime(input.created_at) || $guard(_exceptionable, {\npath: _path + \".created_at\",\nexpected: \"string (@format datetime)\",\nvalue: input.created_at\n})) || $guard(_exceptionable, {\npath: _path + \".created_at\",\nexpected: \"string\",\nvalue: input.created_at\n}));\nconst $ao1 = (input, _path, _exceptionable = true) => (null === input.name || \"string\" === typeof input.name && (RegExp(/^[a-z0-9]+$/).test(input.name) || $guard(_exceptionable, {\npath: _path + \".name\",\nexpected: \"string (@pattern ^[a-z0-9]+$)\",\nvalue: input.name\n})) && (255 >= input.name.length || $guard(_exceptionable, {\npath: _path + \".name\",\nexpected: \"string (@maxLength 255)\",\nvalue: input.name\n})) || $guard(_exceptionable, {\npath: _path + \".name\",\nexpected: \"(null | string)\",\nvalue: input.name\n})) && (null === input.extension || \"string\" === typeof input.extension && (RegExp(/^[a-z0-9]+$/).test(input.extension) || $guard(_exceptionable, {\npath: _path + \".extension\",\nexpected: \"string (@pattern ^[a-z0-9]+$)\",\nvalue: input.extension\n})) && (8 >= input.extension.length || $guard(_exceptionable, {\npath: _path + \".extension\",\nexpected: \"string (@maxLength 8)\",\nvalue: input.extension\n})) || $guard(_exceptionable, {\npath: _path + \".extension\",\nexpected: \"(null | string)\",\nvalue: input.extension\n})) && (\"string\" === typeof input.url || $guard(_exceptionable, {\npath: _path + \".url\",\nexpected: \"string\",\nvalue: input.url\n}));\nreturn (\"object\" === typeof input && null !== input || $guard(true, {\npath: _path + \"\",\nexpected: \"IBbsArticle\",\nvalue: input\n})) && $ao0(input, _path + \"\", true);\n})(input, \"$input\", true);\nreturn input;\n};\nexports.assertArticle = assertArticle;\n\n\n\nMeasured on Intel i5-1135g7, Surface Pro 8"}},"/docs/protobuf/message":{"title":"Message","data":{"":"","message-function#message() function":"export namespace protobuf {\nexport function message<T>(): string;\n}\n\n\ntypia.protobuf.message() function returns a Protocol Buffer message (structure) as a string value.With this message() function, you can share *.proto files with other languages. If you want to customize byte order or define specific type (that is not supported in the TypeScript) like uint32, use comment tags by following comment tags section.\nimport typia, { tags } from \"typia\";\n\ninterface ICustomer {\nid: number & tags.Type<\"int32\">;\nemail: string & tags.Format<\"email\">;\nname: string;\npet: null | ICat | IDog;\nmemo: null | Map<string, string>;\nlogins: Array<ICustomerLogin>;\n}\ninterface ICat {\ntype: \"cat\";\nname: string;\nribbon: boolean;\n}\ninterface IDog {\ntype: \"dog\";\nname: string;\nhunt: boolean;\n}\ninterface ICustomerLogin {\nsuccess: boolean;\nhref: string & tags.Format<\"url\">;\nreferrer: string & tags.Format<\"url\">;\nip: string & (tags.Format<\"ipv4\"> | tags.Format<\"ipv6\">);\ntime: string & tags.Format<\"date-time\">;\n}\n\ntypia.protobuf.message<ICustomer>();\n\n\nsyntax = \"proto3\";\n\nmessage ICustomer {\nrequired int32 id = 1;\nrequired string email = 2;\nrequired string name = 3;\noneof pet {\nICat v4 = 4;\nIDog v5 = 5;\n}\nmap<string, string> memo = 6;\nrepeated ICustomerLogin logins = 7;\n}\n\nmessage ICat {\nrequired string type = 1;\nrequired string name = 2;\nrequired bool ribbon = 3;\n}\n\nmessage IDog {\nrequired string type = 1;\nrequired string name = 2;\nrequired bool hunt = 3;\n}\n\nmessage ICustomerLogin {\nrequired bool success = 1;\nrequired string href = 2;\nrequired string referrer = 3;\nrequired string ip = 4;\nrequired string time = 5;\n}","type-tags#Type Tags":"By using type tags, you can use special numeric types that are not supported in the TypeScript.Just import Type (or typia.tags.Type) type, and combine it with number or bigint type through intersection symbol number & typia.tagsType<\"float\"> case. If you want to declare an union numeric type, combine | and bracket (()) symbols properly like below.When you take a mistake that choosing different target type, TypeScript compiler would block it with compliation error message. Therefore, have a confidence when using the Type tag. For such type safety reason, I recommend to use Type tag instead of using comment tags as much as possible.\nnumber & (Type<\"uint32\"> | Type<\"double\">)\nnumber type can be both uint32 and double\n\n\n(number & Type<\"int32\">) | (bigint & Type<\"uint64\">)\nnumber is int32\nbigint is uint64\n\n\n(number & (Type<\"int32\">)| Type<\"float\">) | (bigint & Type<\"uint64\">)\nnumber can be both int32 and float\nbigint is uint64\n\n\n\n\n\n\nimport typia, { tags } from \"typia\";\n\nexport interface TypeTagExample {\n// ATOMIC TYPES\nint32: number & tags.Type<\"int32\">;\nuint32: number & tags.Type<\"uint32\">;\nuint64: bigint & tags.Type<\"uint64\">;\nint64: number & tags.Type<\"int64\">;\nfloat: number & tags.Type<\"float\">;\ndouble: number | undefined;\nstring: string | null;\n\n// UNION TYPES\nuint32_or_double: number & (tags.Type<\"uint32\"> | tags.Type<\"double\">);\nint32_or_uint64:\n| (number & tags.Type<\"int32\">)\n| (bigint & tags.Type<\"uint64\">);\nint32_or_float_or_uint64:\n| (number & (tags.Type<\"int32\"> | tags.Type<\"float\">))\n| (bigint & tags.Type<\"uint64\">);\n\n// ARRAY AND MAP\nuint64_array: Array<bigint & Type<\"uint64\">>;\nint32_map?: Map<number & Type<\"int32\">, string> | null;\n}\n\n//----\n// PROTOBUF MESSAGE SCHEMA\n//----\ntypia.protobuf.message<TypeTagExample>();\n\n//----\n// DECODE FUNCTION\n//----\ntypia.protobuf.createDecode<TypeTagExample>();\n\n//----\n// ENCODE FUNCTION\n//----\ntypia.protobuf.createEncode<TypeTagExample>();\n\n\n\nsyntax = \"proto3\";\n\nmessage TypeTagExample {\nrequired int32 int32 = 1;\nrequired uint32 uint32 = 2;\nrequired uint64 uint64 = 3;\nrequired int64 int64 = 4;\nrequired float float = 5;\noptional double double = 6;\noptional string string = 7;\noneof uint32_or_double {\nuint32 v8 = 8;\ndouble v9 = 9;\n}\noneof int32_or_uint64 {\nint32 v10 = 10;\nuint64 v11 = 11;\n}\noneof int32_or_float_or_uint64 {\nint32 v12 = 12;\nuint64 v13 = 13;\nfloat v14 = 14;\n}\nrepeated uint64 uint64_array = 15;\nmap<int32, string> int32_map = 16;\n}\n\n\n\n\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\nreturn (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst typia_1 = __importDefault(require(\"typia\"));\n//----\n// PROTOBUF MESSAGE SCHEMA\n//----\n\"syntax = \\\"proto3\\\";\\n\\nmessage TypeTagExample {\\n    required int32 int32 = 1;\\n    required uint32 uint32 = 2;\\n    required uint64 uint64 = 3;\\n    required int64 int64 = 4;\\n    required float float = 5;\\n    optional double double = 6;\\n    optional string string = 7;\\n    oneof uint32_or_double {\\n        uint32 v8 = 8;\\n        double v9 = 9;\\n    }\\n    oneof int32_or_uint64 {\\n        int32 v10 = 10;\\n        uint64 v11 = 11;\\n    }\\n    oneof int32_or_float_or_uint64 {\\n        int32 v12 = 12;\\n        uint64 v13 = 13;\\n        float v14 = 14;\\n    }\\n    repeated uint64 uint64_array = 15;\\n    map<int32, string> int32_map = 16;\\n}\";\n//----\n// DECODE FUNCTION\n//----\ninput => {\nconst $Reader = typia_1.default.protobuf.createDecode.Reader;\nconst $pdo0 = (reader, length = -1) => {\nlength = length < 0 ? reader.size() : reader.index() + length;\nconst output = {\nint32: undefined,\nuint32: undefined,\nuint64: undefined,\nint64: undefined,\nfloat: undefined,\ndouble: undefined,\nstring: null,\nuint32_or_double: undefined,\nint32_or_uint64: undefined,\nint32_or_float_or_uint64: undefined,\nuint64_array: [],\nint32_map: null\n};\nwhile (reader.index() < length) {\nconst tag = reader.uint32();\nswitch (tag >>> 3) {\ncase 1:\n// int32;\noutput.int32 = reader.int32();\nbreak;\ncase 2:\n// uint32;\noutput.uint32 = reader.uint32();\nbreak;\ncase 3:\n// uint64;\noutput.uint64 = reader.uint64();\nbreak;\ncase 4:\n// int64;\noutput.int64 = Number(reader.int64());\nbreak;\ncase 5:\n// float;\noutput.float = reader.float();\nbreak;\ncase 6:\n// double;\noutput.double = reader.double();\nbreak;\ncase 7:\n// string;\noutput.string = reader.string();\nbreak;\ncase 8:\n// uint32;\noutput.uint32_or_double = reader.uint32();\nbreak;\ncase 9:\n// double;\noutput.uint32_or_double = reader.double();\nbreak;\ncase 10:\n// int32;\noutput.int32_or_uint64 = reader.int32();\nbreak;\ncase 11:\n// uint64;\noutput.int32_or_uint64 = reader.uint64();\nbreak;\ncase 12:\n// int32;\noutput.int32_or_float_or_uint64 = reader.int32();\nbreak;\ncase 13:\n// uint64;\noutput.int32_or_float_or_uint64 = reader.uint64();\nbreak;\ncase 14:\n// float;\noutput.int32_or_float_or_uint64 = reader.float();\nbreak;\ncase 15:\n// type: Array<(bigint & Type<\"uint64\">)>;\nif (2 === (tag & 7)) {\nconst piece = reader.uint32() + reader.index();\nwhile (reader.index() < piece)\noutput.uint64_array.push(reader.uint64());\n}\nelse\noutput.uint64_array.push(reader.uint64());\nbreak;\ncase 16:\n// type: Map<string, string>;\n(() => {\noutput.int32_map ??= new Map();\nconst piece = reader.uint32() + reader.index();\nconst entry = {\nkey: undefined,\nvalue: \"\"\n};\nwhile (reader.index() < piece) {\nconst kind = reader.uint32();\nswitch (kind >>> 3) {\ncase 1:\n// int32;\nentry.key = reader.int32();\nbreak;\ncase 2:\n// string;\nentry.value = reader.string();\nbreak;\ndefault:\nreader.skipType(kind & 7);\nbreak;\n}\n}\noutput.int32_map.set(entry.key, entry.value);\n})();\nbreak;\ndefault:\nreader.skipType(tag & 7);\nbreak;\n}\n}\nreturn output;\n};\nconst reader = new $Reader(input);\nreturn $pdo0(reader);\n};\n//----\n// ENCODE FUNCTION\n//----\ninput => {\nconst $throws = typia_1.default.protobuf.createEncode.throws;\nconst $Sizer = typia_1.default.protobuf.createEncode.Sizer;\nconst $Writer = typia_1.default.protobuf.createEncode.Writer;\nconst encoder = writer => {\nconst $peo0 = input => {\n// property \"int32\";\nwriter.uint32(8);\nwriter.int32(input.int32);\n// property \"uint32\";\nwriter.uint32(16);\nwriter.uint32(input.uint32);\n// property \"uint64\";\nwriter.uint32(24);\nwriter.uint64(input.uint64);\n// property \"int64\";\nwriter.uint32(32);\nwriter.int64(input.int64);\n// property \"float\";\nwriter.uint32(45);\nwriter.float(input.float);\n// property \"double\";\nif (undefined !== input.double) {\nwriter.uint32(49);\nwriter.double(input.double);\n}\n// property \"string\";\nif (null !== input.string) {\nwriter.uint32(58);\nwriter.string(input.string);\n}\n// property \"uint32_or_double\";\nif (\"number\" === typeof input.uint32_or_double && (Math.floor(input.uint32_or_double) === input.uint32_or_double && 0 <= input.uint32_or_double && input.uint32_or_double <= 4294967295)) {\nwriter.uint32(64);\nwriter.uint32(input.uint32_or_double);\n}\nelse if (\"number\" === typeof input.uint32_or_double && true) {\nwriter.uint32(73);\nwriter.double(input.uint32_or_double);\n}\nelse\n$throws({\nexpected: \"(number & (Type<\\\"uint32\\\"> | Type<\\\"double\\\">))\",\nvalue: input.uint32_or_double\n});\n// property \"int32_or_uint64\";\nif (\"number\" === typeof input.int32_or_uint64) {\nwriter.uint32(80);\nwriter.int32(input.int32_or_uint64);\n}\nelse if (\"bigint\" === typeof input.int32_or_uint64) {\nwriter.uint32(88);\nwriter.uint64(input.int32_or_uint64);\n}\nelse\n$throws({\nexpected: \"((bigint & Type<\\\"uint64\\\">) | (number & Type<\\\"int32\\\">))\",\nvalue: input.int32_or_uint64\n});\n// property \"int32_or_float_or_uint64\";\nif (\"number\" === typeof input.int32_or_float_or_uint64 && (Math.floor(input.int32_or_float_or_uint64) === input.int32_or_float_or_uint64 && -2147483648 <= input.int32_or_float_or_uint64 && input.int32_or_float_or_uint64 <= 2147483647)) {\nwriter.uint32(96);\nwriter.int32(input.int32_or_float_or_uint64);\n}\nelse if (\"bigint\" === typeof input.int32_or_float_or_uint64) {\nwriter.uint32(104);\nwriter.uint64(input.int32_or_float_or_uint64);\n}\nelse if (\"number\" === typeof input.int32_or_float_or_uint64 && (-1.175494351e+38 <= input.int32_or_float_or_uint64 && input.int32_or_float_or_uint64 <= 3.4028235e+38)) {\nwriter.uint32(117);\nwriter.float(input.int32_or_float_or_uint64);\n}\nelse\n$throws({\nexpected: \"((bigint & Type<\\\"uint64\\\">) | (number & (Type<\\\"int32\\\"> | Type<\\\"float\\\">)))\",\nvalue: input.int32_or_float_or_uint64\n});\n// property \"uint64_array\";\nif (0 !== input.uint64_array.length) {\nwriter.uint32(122);\nwriter.fork();\nfor (const elem of input.uint64_array) {\nwriter.uint64(elem);\n}\nwriter.ldelim();\n}\n// property \"int32_map\";\nif (undefined !== input.int32_map && null !== input.int32_map) {\nfor (const [key, value] of input.int32_map) {\nwriter.uint32(130);\nwriter.fork();\nwriter.uint32(8);\nwriter.int32(key);\nwriter.uint32(18);\nwriter.string(value);\nwriter.ldelim();\n}\n}\n};\n//TypeTagExample;\n$peo0(input);\nreturn writer;\n};\nconst sizer = encoder(new $Sizer());\nconst writer = encoder(new $Writer(sizer));\nreturn writer.buffer();\n};","comment-tags#Comment Tags":"By using @type {target} comment tag, you also can use special numeric types.However, this way is not recommended, because it can't perform union numeric types, and cannot be used in Array and Map types. When you declare @type int32 statement, target number type be fixed as int32 type, and never can have another numeric type by declaring union statements.Also, those comment tags are not type safe. If you take a mistake when writing a comment tag, it will not be detected by the compiler, and will cause an error at runtime. For example, if you write a mis-spelled keyword like @type unit32, the target number type would be double type, and you can identify it just by running the program (or visiting playground website).\n\n\n\nWhy supports comment tags?\nDespite these disadvantages, the reason for maintaining comment tags is as follows.First, it is to support the legacy JSDoc style that had been used in the JS camp for a long time. If you had developed a legacy project and JSDoc being used, you can use it as is.Second, to support Prisma. If a comment is created in the Prisma Schema through the /// statement as shown below and a type is created, it is converted to a TS comment as it is. And since there is no way that union types, numeric Arrays or Maps are used in Prisma (database) schema, these comment tags are surprisingly compatible with Prisma.\n\n\n\nimport typia from \"typia\";\n\nexport interface CommentTagExample {\n/**\n* @type int32\n*/\nint32: number;\n\n/**\n* @type uint32\n*/\nuint32?: number | null;\n\n/**\n* @type uint64\n*/\nuint64?: number;\n\n/**\n* @type int64\n*/\nint64: number;\n\n/**\n* @type float\n*/\nfloat: number | null;\n\ndouble: number;\n\nstring: string;\n}\n\n//----\n// PROTOBUF MESSAGE SCHEMA\n//----\ntypia.protobuf.message<CommentTagExample>();\n\n//----\n// DECODE FUNCTION\n//----\ntypia.protobuf.createDecode<CommentTagExample>();\n\n//----\n// ENCODE FUNCTION\n//----\ntypia.protobuf.createEncode<CommentTagExample>();\n\n\n\nsyntax = \"proto3\";\n\nmessage CommentTagExample {\nrequired int32 int32 = 1;\noptional uint32 uint32 = 2;\noptional uint64 uint64 = 3;\nrequired int64 int64 = 4;\noptional float float = 5;\nrequired double double = 6;\nrequired string string = 7;\n}\n\n\n\n\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\nreturn (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst typia_1 = __importDefault(require(\"typia\"));\n//----\n// PROTOBUF MESSAGE SCHEMA\n//----\n\"syntax = \\\"proto3\\\";\\n\\nmessage CommentTagExample {\\n    required int32 int32 = 1;\\n    optional uint32 uint32 = 2;\\n    optional uint64 uint64 = 3;\\n    required int64 int64 = 4;\\n    optional float float = 5;\\n    required double double = 6;\\n    required string string = 7;\\n}\";\n//----\n// DECODE FUNCTION\n//----\ninput => {\nconst $Reader = typia_1.default.protobuf.createDecode.Reader;\nconst $pdo0 = (reader, length = -1) => {\nlength = length < 0 ? reader.size() : reader.index() + length;\nconst output = {\nint32: undefined,\nuint32: null,\nuint64: undefined,\nint64: undefined,\nfloat: null,\ndouble: undefined,\nstring: \"\"\n};\nwhile (reader.index() < length) {\nconst tag = reader.uint32();\nswitch (tag >>> 3) {\ncase 1:\n// int32;\noutput.int32 = reader.int32();\nbreak;\ncase 2:\n// uint32;\noutput.uint32 = reader.uint32();\nbreak;\ncase 3:\n// uint64;\noutput.uint64 = Number(reader.uint64());\nbreak;\ncase 4:\n// int64;\noutput.int64 = Number(reader.int64());\nbreak;\ncase 5:\n// float;\noutput.float = reader.float();\nbreak;\ncase 6:\n// double;\noutput.double = reader.double();\nbreak;\ncase 7:\n// string;\noutput.string = reader.string();\nbreak;\ndefault:\nreader.skipType(tag & 7);\nbreak;\n}\n}\nreturn output;\n};\nconst reader = new $Reader(input);\nreturn $pdo0(reader);\n};\n//----\n// ENCODE FUNCTION\n//----\ninput => {\nconst $Sizer = typia_1.default.protobuf.createEncode.Sizer;\nconst $Writer = typia_1.default.protobuf.createEncode.Writer;\nconst encoder = writer => {\nconst $peo0 = input => {\n// property \"int32\";\nwriter.uint32(8);\nwriter.int32(input.int32);\n// property \"uint32\";\nif (undefined !== input.uint32 && null !== input.uint32) {\nwriter.uint32(16);\nwriter.uint32(input.uint32);\n}\n// property \"uint64\";\nif (undefined !== input.uint64) {\nwriter.uint32(24);\nwriter.uint64(input.uint64);\n}\n// property \"int64\";\nwriter.uint32(32);\nwriter.int64(input.int64);\n// property \"float\";\nif (null !== input.float) {\nwriter.uint32(45);\nwriter.float(input.float);\n}\n// property \"double\";\nwriter.uint32(49);\nwriter.double(input.double);\n// property \"string\";\nwriter.uint32(58);\nwriter.string(input.string);\n};\n//CommentTagExample;\n$peo0(input);\nreturn writer;\n};\nconst sizer = encoder(new $Sizer());\nconst writer = encoder(new $Writer(sizer));\nreturn writer.buffer();\n};","restrictions#Restrictions":"You know what? Expression power of Protocol Buffer is extremely narrower than type system of TypeScript. For example, Protocol Buffer can't express complicate union type containing array. Also, Protocol Buffer can't express multi dimensional array type, either.In such reason, when converting TypeScript type to Protocol buffer message schema, lots of restrictions are exist. Let's study which types of TyeScript are not supported in Protocol Buffer. For reference, if you try to call typia.protobuf.message<T>() function with unsupported type, typia will generate compile errors like below example cases.At first, top level type must be a sole and static object.If you try to use number or Array<T> type as a top level type, typia will generate compile error like below. Dynamic object types like Record<string, T>, or Map<string, T> types are not allowed either. For reference, the sole object means that, union of object types is not allowed, either.\n\n\nimport typia from \"typia\";\n\ninterface Cat {\ntype: \"cat\";\nname: string;\nribbon: boolean;\n}\ninterface Dog {\ntype: \"dog\";\nname: string;\nhunt: boolean;\n}\n\ntypia.protobuf.message<bigint>();\ntypia.protobuf.createDecode<Record<string, number>>();\ntypia.protobuf.createDecode<Map<number & typia.tags.Type<\"float\">, Dog>>();\ntypia.protobuf.createEncode<boolean[]>();\ntypia.protobuf.createEncode<Cat | Dog>();\n\n\n\nmain.ts:14:1 - error TS(typia.protobuf.message): unsupported type detected\n\n- bigint\n- target type must be a sole and static object type\n\nmain.ts:15:1 - error TS(typia.protobuf.typia.protobuf.createDecode): unsupported type detected\n\n- Record<string, number>\n- target type must be a sole and static object type\n\nmain.ts:16:1 - error TS(typia.protobuf.typia.protobuf.createDecode): unsupported type detected\n\n- Map<(number & Type<\"float\">), Dog>\n- target type must be a sole and static object type\n\n- (number & Type<\"float\">)\n- target type must be a sole and static object type\n\nmain.ts:17:1 - error TS(typia.protobuf.typia.protobuf.createEncode): unsupported type detected\n\n- Array<boolean>\n- target type must be a sole and static object type\n\nmain.ts:18:1 - error TS(typia.protobuf.typia.protobuf.createEncode): unsupported type detected\n\n- (Cat | Dog)\n- target type must be a sole and static object type\n\n\nAt next, in Protocol Buffer, those types are categorized as container types.\nArray<T>\nMap<Key, T>\nRecord<string, T> (dynamic object)\n\nAlso, those container types does not allow over two-dimensional stacking. Therefore, it is not possible to declaring two dimensional array like number[][], or Array type in Map like Map<string, number[]>. Besides, value type of those container also do not support union type either.Additionally, about Map<Key, T> type, key type must be an atomic type. It means that, only boolean, number, bigint and string types are allowed. Also, key type cannot be union type, either.\n\n\nimport typia from \"typia\";\n\ninterface IPointer<T> {\nvalue: T;\n}\ninterface Cat {\ntype: \"cat\";\nname: string;\nribbon: boolean;\n}\ninterface Dog {\ntype: \"dog\";\nname: string;\nhunt: boolean;\n}\n\ntypia.protobuf.message<IPointer<number[][]>>();\ntypia.protobuf.createEncode<IPointer<Record<string, string[]>>>();\ntypia.protobuf.createDecode<IPointer<Map<string, Cat|Dog>>>();\n\ntypia.protobuf.message<IPointer<Map<Cat, string>>>();\ntypia.protobuf.message<IPointer<Map<number|string, Dog>>>();\n\n\n\nmain.ts:17:1 - error TS(typia.protobuf.message): unsupported type detected\n\n- IPointer<Array<Array<number>>>[key]: Array<Array<number>>\n- does not support over two dimenstional array type\n\nmain.ts:18:1 - error TS(typia.protobuf.typia.protobuf.createEncode): unsupported type detected\n\n- IPointer<Record<string, Array<string>>>[key]: Record<string, Array<string>>\n- does not support dynamic object with array value type\n\nmain.ts:19:1 - error TS(typia.protobuf.typia.protobuf.createDecode): unsupported type detected\n\n- IPointer<Map<string, Cat | Dog>>[key]: Map<string, (Cat | Dog)>\n- does not support union type in map value type\n\nmain.ts:21:1 - error TS(typia.protobuf.message): unsupported type detected\n\n- IPointer<Map<Cat, string>>[key]: Map<Cat, string>\n- does not support non-atomic key typed map\n\nmain.ts:22:1 - error TS(typia.protobuf.message): unsupported type detected\n\n- IPointer<Map<string | number, Dog>>[key]: Map<(number | string), Dog>\n- does not support union key typed map\n- does not support non-atomic key typed map\n\n\nAt last, those types are all not allowed.\nany\nfunctional type\nSet<T>, WeakSet<T> and WeakMap<T>\nDate, Boolean, BigInt, Number, String\nBinary classes except Uint8Array\nUint8ClampedArray, Uint16Array, Uint32Array, BigUint64Array\nInt8Array, Int16Array, Int32Array, BigInt64Array\nArrayBuffer, SharedArrayBuffer and DataView\n\n\n\n\n\n\nimport typia from \"typia\";\n\ninterface Something {\nany: any;\nunknown: unknown;\nclosure: () => void;\ndict: Set<string> | WeakSet<Something> | WeakMap<Something, string>;\ndate: Date;\nclassic: String;\nbuffer: ArrayBuffer;\n}\n\ntypia.protobuf.message<Something>();\n\n\n\nmain.ts:13:1 - error TS(typia.protobuf.message): unsupported type detected\n\n- Something.any: any\n- does not support any type\n\n- Something.unknown: any\n- does not support any type\n\n- Something.closure: unknown\n- does not support functional type\n\n- Something.dict: (Set<string> | WeakMap | WeakSet)\n- does not support Set type\n- does not support WeakSet type. Use Array type instead.\n- does not support WeakMap type. Use Map type instead.\n\n- Something.date: Date\n- does not support Date type. Use string type instead.\n\n- Something.classic: String\n- does not support String type. Use string type instead.\n\n- Something.buffer: ArrayBuffer\n- does not support ArrayBuffer type. Use Uint8Array type instead."}},"/docs/validators/tags":{"title":"Tags","data":{"":"","outline#Outline":"typia can perform additional validation through type tags and comment tags.When you need additional validation logic that is not supported in pure TypeScript type spec, you can use type tags and comment tags for it. For example, if you define a type with intersection symbol like number & typia.tags.Type<\"uint32\"> and validates it, typia will check the target numeric value is unsigned integer or not.Also, in TypeScript (and JavaScript), writing @ character in comment is called Comment Tag and typia utilizes such comment tags for enhancing type validation logic. As you can see from below example code, typia analyzes @tagName value patterned comment tags, and generates optimal validation logic in the compilation level.Therefore, don't be afraid typia uses only pure TypeScript types for type validation schema. Don't be afraid about TypeScript does not support integer type. With those type tags and comment tags, you can express every types in the world.\nQ: How to validate integer type? TypeScript does not support it\nA1: Use type tag number & typia.tags.Type<\"int32\">\nA2: Write a comment tag @type int32 on the target property\n\n\nQ: Type Tag vs Comment Tags, which one is better\nA1: Type Tag is recommended because it is much safer and generous\nA2: Comment Tag is designed for legacy JSDoc styled projects\n\n\n\n\n\n\nimport typia, { tags } from \"typia\";\n\nexport const checkCustomTag = typia.createIs<CustomTag>();\n\ninterface CustomTag {\n/**\n* @type uint32\n*/\ntype: number;\n\nnumber?: number & tags.ExclusiveMinimum<19> & tags.Maximum<100>;\n\n/**\n* @minLength 3\n*/\nstring: string;\n\npattern: string & tags.Pattern<\"^[a-z]+$\">;\n\n/**\n* Type tag can perform union type.\n*\n* In here case, format can be oneof `ipv4` or `ipv6` format.\n*/\nformat: (string & (tags.Format<\"ipv4\"> | tags.Format<\"ivp6\">)) | null;\n\n/**\n* In the Array case, only type tag can restrict element type.\n*/\narray: Array<string & tags.Format<\"uuid\">>\n& tags.MinItems<3>\n& tags.MaxItems<100>;\n\n/**\n* Also, only type tag can handle map type.\n*/\nmap: Map<\nnumber & tags.Type<\"uint32\">,\nArray<string & tags.Format<\"uuid\">> & tags.MinItems<1>\n>;\n}\n\n\n\n\"use strict\";\nvar __importDefault =\n(this && this.__importDefault) ||\nfunction (mod) {\nreturn mod && mod.__esModule ? mod : { default: mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.checkCustomTag = void 0;\nconst typia_1 = __importDefault(require(\"typia\"));\nconst checkCustomTag = (input) => {\nconst $io0 = (input) =>\n\"number\" === typeof input.type &&\nMath.floor(input.type) === input.type &&\n0 <= input.type &&\ninput.type <= 4294967295 &&\n(undefined === input.number ||\n(\"number\" === typeof input.number &&\n19 < input.number &&\ninput.number <= 100)) &&\n\"string\" === typeof input.string &&\n3 <= input.string.length &&\n\"string\" === typeof input.pattern &&\n!isNaN(new Date(input.pattern).getTime()) &&\n(null === input.format ||\n(\"string\" === typeof input.format &&\n(/^(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(\ninput.format,\n) ||\n!isNaN(new Date(input.format).getTime())))) &&\nArray.isArray(input.array) &&\n3 <= input.array.length &&\ninput.array.length <= 100 &&\ninput.array.every(\n(elem) =>\n\"string\" === typeof elem &&\n/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\nelem,\n),\n) &&\ninput.map instanceof Map &&\n(() =>\n[...input.map].every(\n(elem) =>\nArray.isArray(elem) &&\nelem.length === 2 &&\n\"number\" === typeof elem[0] &&\nMath.floor(elem[0]) === elem[0] &&\n0 <= elem[0] &&\nelem[0] <= 4294967295 &&\nArray.isArray(elem[1]) &&\n1 <= elem[1].length &&\nelem[1].every(\n(elem) =>\n\"string\" === typeof elem &&\n/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\nelem,\n),\n),\n))();\nreturn \"object\" === typeof input && null !== input && $io0(input);\n};\nexports.checkCustomTag = checkCustomTag;","type-tags#Type Tags":"By using type tags, you can utilize additional validation logics.Just import one of type tags from typia, and combine it with target through intersection symbol like number & typia.tags.Type<\"uint32\"> case. If you want to declare an union validation logic, combine | and bracket (()) symbols properly like below:\nnumber & (Type<\"uint32\"> | Type<\"double\">)\nnumber type can be both uint32 and double\n\n\n(number & Type<\"int32\">) | (bigint & Type<\"uint64\">)\nnumber is int32\nbigint is uint64\n\n\n(number & (Type<\"int32\">)| Type<\"float\">) | (bigint & Type<\"uint64\">)\nnumber can be both int32 and float\nbigint is uint64\n\n\n\nHere is the entire list of type tags that typia basically supports.For reference, when you take a mistake that choosing different target type, TypeScript compiler would block it with compilation error message. Also, if you take a mistake that placing invalid argument on the type, it would also be blocked IDE and compiler. Therefore, have a confidence when using them.\nnumber\nnumber & Type<{keyword}>\nint32\nuint32\nuint64\nint64\nfloat\ndouble\n\n\nnumber & Minimum<{number}>\nnumber & Maximum<{number}>\nnumber & ExclusiveMaximum<{number}>\nnumber & ExclusiveMinimum<{number}>\nnumber & MultipleOf<{number}>\n\n\nbigint\nbigint & Type<{keyword}>\nint64\nuint64\n\n\nbigint & Minimum<{bigint}>\nbigint & Maximum<{bigint}>\nbigint & ExclusiveMaximum<{bigint}>\nbigint & ExclusiveMinimum<{bigint}>\nbigint & MultipleOf<{bigint}>\nstring\nstring & MinLength<{number}>\nstring & MaxLength<{number}>\nstring & Pattern<{regex}>\nstring & Format<{keyword}>\nemail\nuuid\nipv4\nipv6\nurl\ndate: YYYY-MM-DD\ndate-time: Date.toISOString()\n\n\n\n\n\nAlso, if you need custom validation logic, just make it by yourself referencing Customization section. It is easy to define. For such type safety and generous use case reasons even customization supporting, I recommend you to use type tags instead of comment tags, unless you are maintaining a legacy JSDoc styled project.\n\n\nimport typia, { tags } from \"typia\";\n\nexport const checkCustomTag = typia.createIs<CustomTag>();\n\ninterface CustomTag {\ntype: number & tags.Type<\"uint32\">;\n\nnumber?: number & tags.ExclusiveMinimum<19> & tags.Maximum<100>;\n\nstring: string & tags.MinLength<3>;\n\npattern: string & tags.Format<\"^[a-z]+$\">;\n\n/**\n* Type tag can perform union type.\n*\n* In here case, format can be oneof `ipv4` or `ipv6` format.\n*/\nformat: (string & (tags.Format<\"ipv4\"> | tags.Format<\"ivp6\">)) | null;\n\n/**\n* In the Array case, only type tag can restrict element type.\n*/\narray: Array<string & tags.Format<\"uuid\">>\n& tags.MinItems<3>\n& tags.MaxItems<100>;\n\n/**\n* Also, only type tag can handle map type.\n*/\nmap: Map<\nnumber & tags.Type<\"uint32\">,\nArray<string & tags.Format<\"uuid\">> & tags.MinItems<1>\n>;\n}\n\n\n\n\"use strict\";\nvar __importDefault =\n(this && this.__importDefault) ||\nfunction (mod) {\nreturn mod && mod.__esModule ? mod : { default: mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.checkCustomTag = void 0;\nconst typia_1 = __importDefault(require(\"typia\"));\nconst checkCustomTag = (input) => {\nconst $io0 = (input) =>\n\"number\" === typeof input.type &&\nMath.floor(input.type) === input.type &&\n0 <= input.type &&\ninput.type <= 4294967295 &&\n(undefined === input.number ||\n(\"number\" === typeof input.number &&\n19 < input.number &&\ninput.number <= 100)) &&\n\"string\" === typeof input.string &&\n3 <= input.string.length &&\n\"string\" === typeof input.pattern &&\n!isNaN(new Date(input.pattern).getTime()) &&\n(null === input.format ||\n(\"string\" === typeof input.format &&\n(/^(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(\ninput.format,\n) ||\n!isNaN(new Date(input.format).getTime())))) &&\nArray.isArray(input.array) &&\n3 <= input.array.length &&\ninput.array.length <= 100 &&\ninput.array.every(\n(elem) =>\n\"string\" === typeof elem &&\n/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\nelem,\n),\n) &&\ninput.map instanceof Map &&\n(() =>\n[...input.map].every(\n(elem) =>\nArray.isArray(elem) &&\nelem.length === 2 &&\n\"number\" === typeof elem[0] &&\nMath.floor(elem[0]) === elem[0] &&\n0 <= elem[0] &&\nelem[0] <= 4294967295 &&\nArray.isArray(elem[1]) &&\n1 <= elem[1].length &&\nelem[1].every(\n(elem) =>\n\"string\" === typeof elem &&\n/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\nelem,\n),\n),\n))();\nreturn \"object\" === typeof input && null !== input && $io0(input);\n};\nexports.checkCustomTag = checkCustomTag;","comment-tags#Comment Tags":"typia supports those comment tags, too.Here is the entire list of comment tags that typia supports.\nnumber\n@type {string}\nint / int32\nuint / uint32\nint64\nuint64\nfloat\n\n\n@minimum {number}\n@maximum {number}\n@exclusiveMinimum {number}\n@exclusiveMaximum {number}\n@multipleOf {number}\n\n\nbigint\n@type uint64\n@minimum {bigint}\n@maximum {bigint}\n@exclusiveMinimum {bigint}\n@exclusiveMaximum {bigint}\n@multipleOf {bigint}\n\n\nstring\n@minLength {number}\n@maxLength {number}\n@pattern {regex}\n@format {keyword}\nemail\nuuid\nipv4\nipv6\nurl\ndate: YYYY-MM-DD\ndate-time: Date.toISOString()\n\n\n\n\narray\n@minItems {number}\n@maxItems {number}\n\n\n\nBy the way, I do not recommend this way, because it can't perform union numeric types, and can be used for only object property type. It can't be used standalone, and cannot be used for element type of Array and Map even when they're declared on object property. Also, When you declare @type int32 statement, target number type be fixed as int32 type, and never can have another numeric type by declaring union statements.Also, those comment tags are not type safe. If you take a mistake when writing a comment tag, it will not be detected by the compiler, and will cause an error at runtime. For example, if you write a mis-spelled keyword like @type unit32, the target number type would be double type, and you can identify it just by running the program (or visiting playground website).\n\n\n\nWhy supports comment tags?\nDespite these disadvantages, the reason for maintaining comment tags is as follows.First, it is to support the legacy JSDoc style that had been used in the JS camp for a long time. If you had developed a legacy project and JSDoc being used, you can use it as is.Second, to support Prisma. If a comment is created in the Prisma Schema through the /// statement as shown below and a type is created, it is converted to a TS comment as it is. And since there is no way that union types, numeric Arrays or Maps are used in Prisma (database) schema, these comment tags are surprisingly compatible with Prisma.\n\n\n\nimport typia from \"typia\";\n\nexport const checkCustomTag = typia.createIs<CustomTag>();\n\ninterface CustomTag {\n/**\n* @type uint32\n*/\ntype: number;\n\n/**\n* @exclusiveMinimum 19\n* @maximum 100\n*/\nnumber?: number;\n\n/**\n* @minLength 3\n*/\nstring: string;\n\n/**\n* @format /^[a-z]+$/\n*/\npattern: string;\n\n// NO WAY WHEN COMMENT TAG\n// /**\n//  * Type tag can perform union type.\n//  *\n//  * In here case, format can be oneof `ipv4` or `ipv6` format.\n//  */\n// format: (string & (tags.Format<\"ipv4\"> | tags.Format<\"ivp6\">)) | null;\n\n// NO WAY WHEN COMMENT TAG\n// /**\n//  * In the Array case, only type tag can restrict element type.\n//  */\n// array: Array<string & tags.Format<\"uuid\">>\n//     & tags.MinItems<3>\n//     & tags.MaxItems<100>;\n\n// NO WAY WHEN COMMENT TAG\n// /**\n//  * Also, only type tag can handle map type.\n//  */\n// map: Map<\n//     number & tags.Type<\"uint32\">,\n//     Array<string & tags.Format<\"uuid\">> & tags.MinItems<1>\n// >;\n}\n\n\n\n\"use strict\";\nvar __importDefault =\n(this && this.__importDefault) ||\nfunction (mod) {\nreturn mod && mod.__esModule ? mod : { default: mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.checkCustomTag = void 0;\nconst typia_1 = __importDefault(require(\"typia\"));\nconst checkCustomTag = (input) => {\nconst $io0 = (input) =>\n\"number\" === typeof input.type &&\nMath.floor(input.type) === input.type &&\n0 <= input.type &&\ninput.type <= 4294967295 &&\n(undefined === input.number ||\n(\"number\" === typeof input.number &&\n19 < input.number &&\ninput.number <= 100)) &&\n\"string\" === typeof input.string &&\n3 <= input.string.length &&\n\"string\" === typeof input.pattern;\nreturn \"object\" === typeof input && null !== input && $io0(input);\n};\nexports.checkCustomTag = checkCustomTag;","customization#Customization":"export type TagBase<Props extends TagBase.IProps<any, any, any, any, any>> = {\n/**\n* This is a dummy property for compilation.\n*\n* It does not mean anything in runtime.\n*/\n\"typia.tag\"?: Props;\n};\nexport namespace TagBase {\nexport interface IProps<\nTarget extends \"bigint\" | \"number\" | \"string\" | \"array\",\nKind extends string,\nValue extends boolean | bigint | number | string | undefined,\nValidate extends\n| string\n| {\n[key in Target]?: string;\n},\nExclusive extends boolean | string[],\n> {\n/**\n* Target type.\n*\n* If user tries to adapt this tag to a different type, it would be a compile\n* error.\n*\n* For example, you've configured target type as `string`, but user adapted it\n* onto a `number` type (`number & YourCustomTag<Value>`), then it would be\n* blocked by TypeScript compiler.\n*/\ntarget: Target;\n\n/**\n* What kind of tag is this?\n*/\nkind: Kind;\n\n/**\n* Value to be configured by user.\n*/\nvalue: Value;\n\n/**\n* Validation code.\n*\n* This code would be inserted into the generated validation function.\n* In here script, target variable name must be `$input`. The variable name\n* `$input` would be transformed to the suitable when compilation.\n*\n* Also, If you've take a mistake on this script, compile error would be\n* occured. So, define it with confidence. Compiler will block all your\n* mistakes.\n*/\nvalidate: Validate;\n\n/**\n* Exclusive option.\n*\n* If this property configured as `true`, same {@link kind} tag cannot be\n* duplicated in the target type. Otherwise, if you've configured this property\n* as string array, all of the {@link kind} value assigned tag cannot be\n* compatible in the target type.\n*\n* @default false\n*/\nexclusive?: Exclusive | string[];\n}\n}\n\n\n\nimport { TagBase } from \"./TagBase\";\n\nexport type Minimum<Value extends number | bigint> = TagBase<{\ntarget: Value extends number ? \"number\" : \"bigint\";\nkind: \"minimum\";\nvalue: Value;\nvalidate: `${Numeric<Value>} <= $input`;\nexclusive: [\"minimum\", \"exclusiveMinimum\"];\n}>;\n\ntype Numeric<Value extends number | bigint> = Value extends number\n? Value\n: `BigInt(${Value})`;\n\n\n\nimport { TagBase } from \"./TagBase\";\n\nexport type Type<\nValue extends \"int32\" | \"uint32\" | \"int64\" | \"uint64\" | \"float\" | \"double\",\n> = TagBase<{\ntarget: Value extends \"int64\" | \"uint64\" ? \"bigint\" | \"number\" : \"number\";\nkind: \"type\";\nvalue: Value;\nvalidate: Value extends \"int32\"\n? `Math.floor($input) === $input && -2147483648 <= $input && $input <= 2147483647`\n: Value extends \"uint32\"\n? `Math.floor($input) === $input && 0 <= $input && $input <= 4294967295`\n: Value extends \"int64\"\n? {\nnumber: `Math.floor($input) === $input && -9223372036854775808 <= $input && $input <= 9223372036854775807`;\nbigint: `true`;\n}\n: Value extends \"uint64\"\n? {\nnumber: `Math.floor($input) === $input && 0 <= $input && $input <= 18446744073709551615`;\nbigint: `BigInt(0) <= $input`;\n}\n: Value extends \"float\"\n? `-1.175494351e38 <= $input && $input <= 3.4028235e38`\n: `true`;\nexclusive: true;\n}>;\n\n\n\nimport { TagBase } from \"./TagBase\";\n\nexport type Pattern<Value extends string> = TagBase<{\ntarget: \"string\";\nkind: \"pattern\";\nvalue: Value;\nvalidate: `/${Value}/.test($input)`;\n}>;\n\n\nAbove types are supported by typia basically.If you make a custom type tag extending typia.tags.TagBase<Props> type, and utilize it on your type with intersection symbol like number & Minimum<3>, its validation logic 3 <= $input would be inserted into the compiled JavaScript file.Also, as you can see from the typia.tags.TagBase<Props> type, you have to specify which target type is the tag for, and need to define the tag can be compatible with others or not through exclusive options. If your custom tag has multiple target types, you can support all of those target types by defining validate property as Record<Target, string> type like Type tag case.In the Korean proverb, there's a word that, \"it is much better to do it once than to hear it a hundred times\". Let's see how custom type tag of typia can be defined and utilized through an example code. I'll define three custom tag types, Postfix, Dollar and IsEven.Here is the example code, and I think that it may easy to understand.\n\n\nimport typia, { tags } from \"typia\";\n\nexport const checkSomething = typia.createIs<Something>();\n\n//----\n// DEFINE CUSTOM TYPE TAGS\n//----\ntype Dollar = tags.TagBase<{\nkind: \"dollar\";\ntarget: \"string\";\nvalue: undefined;\nvalidate: `$input[0] === \"$\" && !isNaN(Number($input.substring(1).split(\",\").join(\"\")))`;\n}>;\n\ntype Postfix<Value extends string> = tags.TagBase<{\nkind: \"postfix\";\ntarget: \"string\";\nvalue: Value;\nvalidate: `$input.endsWith(\"${Value}\")`;\n}>;\n\ntype IsEven<Value extends number | bigint> = tags.TagBase<{\nkind: \"isEven\";\ntarget: Value extends number ? \"number\" : \"bigint\";\nvalue: undefined;\nvalidate: `$input % ${Numeric<2>} === ${Numeric<0>}`;\n}>;\n\ntype Numeric<Value extends number | bigint> = Value extends number\n? Value\n: `BigInt(${Value})`;\n\n//----\n// VALIDATION\n//----\ninterface Something {\ndollar: string & Dollar;\npostfix: string & Postfix<\"!!!\">;\nisEven: number & IsEven<number>;\n}\n\n\n\n\"use strict\";\nvar __importDefault =\n(this && this.__importDefault) ||\nfunction (mod) {\nreturn mod && mod.__esModule ? mod : { default: mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.checkSomething = void 0;\nconst typia_1 = __importDefault(require(\"typia\"));\nconst checkSomething = (input) => {\nreturn (\n\"object\" === typeof input &&\nnull !== input &&\n\"string\" === typeof input.dollar &&\ninput.dollar[0] === \"$\" &&\n!isNaN(Number(input.dollar.substring(1).split(\",\").join(\"\"))) &&\n\"string\" === typeof input.postfix &&\ninput.postfix.endsWith(\"!!!\") &&\n\"number\" === typeof input.isEven &&\ninput.isEven % 2 === 0\n);\n};\nexports.checkSomething = checkSomething;"}}}