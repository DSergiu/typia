(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[311],{3746:function(e,n,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/playground",function(){return t(3901)}])},3901:function(e,n,t){"use strict";t.r(n),t.d(n,{default:function(){return w}});var a,i,r,o=t(5893),s=t(6961),u=t(7294),l=t(5884),p=t(5423),c=t.n(p),h=t(8781),d=t.n(h);let m=[["file:///node_modules/typia/lib/CustomValidatorMap.d.ts",'import { Customizable } from "./typings/Customizable";\n/**\n * Map of custom validators.\n *\n * Map of custom validator functions, storing tag name and type of target value\n * as key, and custom validator function as value.\n *\n * When you want to add a custom validation logic utilizing comment tags, you\n * can insert a custom validator function with specific tag name and type of\n * the target value like below.\n *\n * ```ts\n * typia.customValidators.insert("powerOf")("number")(\n *     (text: string) => {\n *         const denominator: number = Math.log(Number(text));\n *         return (value: number) => {\n *             value = Math.log(value) / denominator;\n *             return value === Math.floor(value);\n *         };\n *     }\n * );\n * typia.customValidators.insert("dollar")("string")(\n *     () => (value: string) => value.startsWith("$"),\n * );\n *\n * interface TagCustom {\n *    /**\n *     * @powerOf 10\n *     */\n *    powerOf: number;\n *\n *    /**\n *     * @dollar\n *     */\n *    dollar: string;\n * }\n * ```\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport interface CustomValidatorMap {\n    /**\n     * Get number of stored tags.\n     *\n     * @return Number of stored tags\n     */\n    size(): number;\n    /**\n     * Get number of stored types of the specified tag name.\n     *\n     * In other words, number of stored custom validator functions of\n     * the specified tag name.\n     *\n     * @param name Tag name\n     * @return Number of stored types function\n     */\n    size(name: string): number;\n    /**\n     * Test whether custom validator function exists or not.\n     *\n     * @param name Tag name\n     * @param type Type of the target value\n     * @returns Whether exists or not\n     */\n    has: (name: string) => (type: keyof Customizable) => boolean;\n    /**\n     * Get custom validator function.\n     *\n     * @param name Tag name\n     * @param type Type of the target value\n     * @returns Custom validator function or undefined value\n     */\n    get(name: string): <Type extends keyof Customizable>(type: Type) => CustomValidatorMap.Closure<Type> | undefined;\n    /**\n     * Insert a new custom validator function.\n     *\n     * You can add a custom validation logic utilizing comment tags,\n     * by inserting a function which returns a boolean value, with specific\n     * tag name and type of the target value.\n     *\n     * However, if you try to insert a duplicated tag name and type, the\n     * closure function would not be enrolled and `false` value would be\n     * returned.\n     *\n     * @param name Tag name\n     * @param type Type of the target value\n     * @param closure Custom validator function\n     * @returns Whether succeeded to insert or not\n     */\n    insert(name: string): <Type extends keyof Customizable>(type: Type) => (closure: CustomValidatorMap.Closure<Type>) => boolean;\n    /**\n     * Erase custom validator function.\n     *\n     * @param name Tag name\n     * @param type Type of the target value\n     * @returns Whether succeeded to erase or not\n     */\n    erase(name: string): (type: keyof Customizable) => boolean;\n}\nexport declare namespace CustomValidatorMap {\n    /**\n     * Type of closure function of custom validation.\n     *\n     * @template Type Type of the target value\n     * @param text Text of the tag. For example, if the tag is `@powerOf 10`, `text` is 10.\n     * @param value Value to validate\n     * @returns Whether the value is valid or not\n     */\n    type Closure<Type extends keyof Customizable> = (text: string) => (value: Customizable[Type]) => boolean;\n}\n'],["file:///node_modules/typia/lib/index.d.ts",'import * as typia from "./module";\nexport default typia;\nexport * from "./module";\n'],["file:///node_modules/typia/lib/IRandomGenerator.d.ts",'import { Customizable } from "./typings/Customizable";\nexport interface IRandomGenerator {\n    boolean(): boolean;\n    integer(minimum?: number, maximum?: number): number;\n    number(minimum?: number, maximum?: number): number;\n    bigint(minimum?: bigint, maximum?: bigint): bigint;\n    string(length?: number): string;\n    array<T>(closure: (index: number) => T, count?: number): T[];\n    length(): number;\n    uuid(): string;\n    email(): string;\n    url(): string;\n    ipv4(): string;\n    ipv6(): string;\n    pattern(regex: RegExp): string;\n    date(minimum?: number, maximum?: number): string;\n    datetime(minimum?: number, maximum?: number): string;\n    customs?: IRandomGenerator.CustomMap;\n}\nexport declare namespace IRandomGenerator {\n    type CustomMap = {\n        [Type in keyof Customizable]?: (tags: ICommentTag[]) => Customizable[Type] | undefined;\n    };\n    interface ICommentTag {\n        name: string;\n        value?: string;\n    }\n}\n'],["file:///node_modules/typia/lib/IValidation.d.ts","export type IValidation<T = unknown> = IValidation.ISuccess<T> | IValidation.IFailure;\nexport declare namespace IValidation {\n    interface ISuccess<T = unknown> {\n        success: true;\n        data: T;\n        errors: [];\n    }\n    interface IFailure {\n        success: false;\n        errors: IError[];\n    }\n    interface IError {\n        path: string;\n        expected: string;\n        value: any;\n    }\n}\n"],["file:///node_modules/typia/lib/module.d.ts",'import { IJsonApplication } from "./schemas/IJsonApplication";\nimport { Atomic } from "./typings/Atomic";\nimport { CustomValidatorMap } from "./CustomValidatorMap";\nimport { IRandomGenerator } from "./IRandomGenerator";\nimport { IValidation } from "./IValidation";\nimport { Primitive } from "./Primitive";\nexport * from "./schemas/IJsonApplication";\nexport * from "./schemas/IJsonComponents";\nexport * from "./schemas/IJsonSchema";\nexport * from "./IRandomGenerator";\nexport * from "./IValidation";\nexport * from "./Primitive";\nexport * from "./TypeGuardError";\n/**\n * Asserts a value type.\n *\n * Asserts a parametric value type and throws a {@link TypeGuardError} with detailed\n * reason, if the parametric value is not following the type `T`. Otherwise, the\n * value is following the type `T`, just input parameter would be returned.\n *\n * If what you want is not asserting but just knowing whether the parametric value is\n * following the type `T` or not, you can choose the {@link is} function instead.\n * Otherwise you want to know all the errors, {@link validate} is the way to go.\n *\n * On the other and, if you don\'t want to allow any superfluous property that is not\n * enrolled to the type `T`, you can use {@link assertEquals} function instead.\n *\n * @template T Type of the input value\n * @param input A value to be asserted\n * @returns Parametric input value\n * @throws A {@link TypeGuardError} instance with detailed reason\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function assert<T>(input: T): T;\n/**\n * Asserts a value type.\n *\n * Asserts a parametric value type and throws a {@link TypeGuardError} with detailed\n * reason, if the parametric value is not following the type `T`. Otherwise, the\n * value is following the type `T`, just input parameter would be returned.\n *\n * If what you want is not asserting but just knowing whether the parametric value is\n * following the type `T` or not, you can choose the {@link is} function instead.\n * Otherwise, you want to know all the errors, {@link validate} is the way to go.\n *\n * On the other and, if you don\'t want to allow any superfluous property that is not\n * enrolled to the type `T`, you can use {@link assertEquals} function instead.\n *\n * @template T Type of the input value\n * @param input A value to be asserted\n * @returns Parametric input value casted as `T`\n * @throws A {@link TypeGuardError} instance with detailed reason\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function assert<T>(input: unknown): T;\n/**\n * Asserts a value type.\n *\n * Duplicated function of {@link assert} for `typescript-is` users.\n *\n * @template T Type of the input value\n * @param input A value to be asserted\n * @returns Parametric input value\n * @throws A {@link TypeGuardError} instance with detailed reason\n *\n * @author Jeongho Nam - https://github.com/samchon\n * @deprecated\n */\nexport declare function assertType<T>(input: T): T;\n/**\n * Asserts a value type.\n *\n * Duplicated function of {@link assert} for `typescript-is` users.\n *\n * @template T Type of the input value\n * @param input A value to be asserted\n * @returns Parametric input value\n * @throws A {@link TypeGuardError} instance with detailed reason\n *\n * @author Jeongho Nam - https://github.com/samchon\n * @deprecated\n */\nexport declare function assertType<T>(input: unknown): T;\n/**\n * Tests a value type.\n *\n * Tests a parametric value type and returns whether it\'s following the type `T` or not.\n * If the parametric value is matched with the type `T`, `true` value would be returned.\n * Otherwise, the parametric value is not following the type `T`, `false` value would be\n * returned.\n *\n * If what you want is not just knowing whether the parametric value is following the\n * type `T` or not, but throwing an exception with detailed reason, you can choose\n * {@link assert} function instead. Also, if you want to know all the errors with\n * detailed reasons, {@link validate} function would be useful.\n *\n * On the other and, if you don\'t want to allow any superfluous property that is not\n * enrolled to the type `T`, you can use {@link equals} function instead.\n *\n * @template T Type of the input value\n * @param input A value to be tested\n * @returns Whether the parametric value is following the type `T` or not\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function is<T>(input: T): input is T;\n/**\n * Tests a value type.\n *\n * Tests a parametric value type and returns whether it\'s following the type `T` or not.\n * If the parametric value is matched with the type `T`, `true` value would be returned.\n * Otherwise, the parametric value is not following the type `T`, `false` value would be\n * returned.\n *\n * If what you want is not just knowing whether the parametric value is following the\n * type `T` or not, but throwing an exception with detailed reason, you can choose\n * {@link assert} function instead. Also, if you want to know all the errors with\n * detailed reasons, {@link validate} function would be useful.\n *\n * On the other and, if you don\'t want to allow any superfluous property that is not\n * enrolled to the type `T`, you can use {@link equals} function instead.\n *\n * @template T Type of the input value\n * @param input A value to be tested\n * @returns Whether the parametric value is following the type `T` or not\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function is<T>(input: unknown): input is T;\n/**\n * Validates a value type.\n *\n * Validates a parametric value type and archives all the type errors into an\n * {@link IValidation.errors} array, if the parametric value is not following the\n * type `T`. Of course, if the parametric value is following the type `T`, the\n * {@link IValidation.errors} array would be empty and {@link IValidation.success}\n * would have the `true` value.\n *\n * If what you want is not finding all the error, but asserting the parametric value\n * type with exception throwing, you can choose {@link assert} function instead.\n * Otherwise, you just want to know whether the parametric value is matched with the\n * type `T`, {@link is} function is the way to go.\n *\n * On the other and, if you don\'t want to allow any superfluous property that is not\n * enrolled to the type `T`, you can use {@link validateEquals} function instead.\n *\n * @template Type of the input value\n * @param input A value to be validated\n * @returns Validation result\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function validate<T>(input: T): IValidation<T>;\n/**\n * Validates a value type.\n *\n * Validates a parametric value type and archives all the type errors into an\n * {@link IValidation.errors} array, if the parametric value is not following the\n * type `T`. Of course, if the parametric value is following the type `T`, the\n * {@link IValidation.errors} array would be empty and {@link IValidation.success}\n * would have the `true` value.\n *\n * If what you want is not finding all the error, but asserting the parametric value\n * type with exception throwing, you can choose {@link assert} function instead.\n * Otherwise, you just want to know whether the parametric value is matched with the\n * type `T`, {@link is} function is the way to go.\n *\n * On the other and, if you don\'t want to allow any superfluous property that is not\n * enrolled to the type `T`, you can use {@link validateEquals} function instead.\n *\n * @template Type of the input value\n * @param input A value to be validated\n * @returns Validation result\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function validate<T>(input: unknown): IValidation<T>;\n/**\n * Asserts equality between a value and its type.\n *\n * Asserts a parametric value type and throws a {@link TypeGuardError} with detailed\n * reason, if the parametric value is not following the type `T` or some superfluous\n * property that is not listed on the type `T` has been found. Otherwise, the value is\n * following the type `T` without any superfluous property, just input parameter would\n * be returned.\n *\n * If what you want is not asserting but just knowing whether the parametric value is\n * following the type `T` or not, you can choose the {@link equals} function instead.\n * Otherwise, you want to know all the errors, {@link validateEquals} is the way to go.\n *\n * On the other hand, if you want to allow superfluous property that is not enrolled\n * to the type `T`, you can use {@link assert} function instead.\n *\n * @template T Type of the input value\n * @param input A value to be asserted\n * @returns Parametric input value\n * @throws A {@link TypeGuardError} instance with detailed reason\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function assertEquals<T>(input: T): T;\n/**\n * Asserts equality between a value and its type.\n *\n * Asserts a parametric value type and throws a {@link TypeGuardError} with detailed\n * reason, if the parametric value is not following the type `T` or some superfluous\n * property that is not listed on the type `T` has been found. Otherwise, the value is\n * following the type `T` without any superfluous property, just input parameter would\n * be returned.\n *\n * If what you want is not asserting but just knowing whether the parametric value is\n * following the type `T` or not, you can choose the {@link equals} function instead.\n * Otherwise, you want to know all the errors, {@link validateEquals} is the way to go.\n *\n * On the other hand, if you want to allow superfluous property that is not enrolled\n * to the type `T`, you can use {@link assert} function instead.\n *\n * @template T Type of the input value\n * @param input A value to be asserted\n * @returns Parametric input value casted as `T`\n * @throws A {@link TypeGuardError} instance with detailed reason\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function assertEquals<T>(input: unknown): T;\n/**\n * Tests equality between a value and its type.\n *\n * Tests a parametric value type and returns whether it\'s equivalent to the type `T`\n * or not. If the parametric value is matched with the type `T` and there\'s not any\n * superfluous property that is not listed on the type `T`, `true` value would be\n * returned. Otherwise, the parametric value is not following the type `T` or some\n * superfluous property exists, `false` value would be returned.\n *\n * If what you want is not just knowing whether the parametric value is following the\n * type `T` or not, but throwing an exception with detailed reason, you can choose\n * {@link assertEquals} function instead. Also, if you want to know all the errors with\n * detailed reasons, {@link validateEquals} function would be useful.\n *\n * On the other hand, if you want to allow superfluous property that is not enrolled\n * to the type `T`, you can use {@link is} function instead.\n *\n * @template T Type of the input value\n * @param input A value to be tested\n * @returns Whether the parametric value is equivalent to the type `T` or not\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function equals<T>(input: T): input is T;\n/**\n * Tests equality between a value and its type.\n *\n * Tests a parametric value type and returns whether it\'s equivalent to the type `T`\n * or not. If the parametric value is matched with the type `T` and there\'s not any\n * superfluous property that is not listed on the type `T`, `true` value would be\n * returned. Otherwise, the parametric value is not following the type `T` or some\n * superfluous property exists, `false` value would be returned.\n *\n * If what you want is not just knowing whether the parametric value is following the\n * type `T` or not, but throwing an exception with detailed reason, you can choose\n * {@link assertEquals} function instead. Also, if you want to know all the errors with\n * detailed reasons, {@link validateEquals} function would be useful.\n *\n * On the other hand, if you want to allow superfluous property that is not enrolled\n * to the type `T`, you can use {@link is} function instead.\n *\n * @template T Type of the input value\n * @param input A value to be tested\n * @returns Whether the parametric value is equivalent to the type `T` or not\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function equals<T>(input: unknown): input is T;\n/**\n * Validates equality between a value and its type.\n *\n * Validates a parametric value type and archives all the type errors into an\n * {@link IValidation.errors} array, if the parametric value is not following the\n * type `T` or some superfluous property that is not listed on the type `T` has been\n * found. Of course, if the parametric value is following the type `T` and no\n * superfluous property exists, the {@link IValidation.errors} array would be empty\n * and {@link IValidation.success} would have the `true` value.\n *\n * If what you want is not finding all the error, but asserting the parametric value\n * type with exception throwing, you can choose {@link assert} function instead.\n * Otherwise, you just want to know whether the parametric value is matched with the\n * type `T`, {@link is} function is the way to go.\n *\n * On the other and, if you don\'t want to allow any superfluous property that is not\n * enrolled to the type `T`, you can use {@link validateEquals} function instead.\n *\n * @template Type of the input value\n * @param input A value to be validated\n * @returns Validation result\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function validateEquals<T>(input: T): IValidation<T>;\n/**\n * Validates equality between a value and its type.\n *\n * Validates a parametric value type and archives all the type errors into an\n * {@link IValidation.errors} array, if the parametric value is not following the\n * type `T` or some superfluous property that is not listed on the type `T` has been\n * found. Of course, if the parametric value is following the type `T` and no\n * superfluous property exists, the {@link IValidation.errors} array would be empty\n * and {@link IValidation.success} would have the `true` value.\n *\n * If what you want is not finding all the error, but asserting the parametric value\n * type with exception throwing, you can choose {@link assert} function instead.\n * Otherwise, you just want to know whether the parametric value is matched with the\n * type `T`, {@link is} function is the way to go.\n *\n * On the other and, if you don\'t want to allow any superfluous property that is not\n * enrolled to the type `T`, you can use {@link validateEquals} function instead.\n *\n * @template Type of the input value\n * @param input A value to be validated\n * @returns Validation result\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function validateEquals<T>(input: unknown): IValidation<T>;\n/**\n * Custom validators.\n *\n * If you want to add a custom validation logic utilizing comment tags,\n * add a closure function with its tag and type name. Below example code\n * would helpful to understand how to use this instance.\n *\n * ```ts\n * typia.customValidators.insert("powerOf")("number")(\n *     (text: string) => {\n *         const denominator: number = Math.log(Number(text));\n *         return (value: number) => {\n *             value = Math.log(value) / denominator;\n *             return value === Math.floor(value);\n *         };\n *     }\n * );\n * typia.customValidators.insert("dollar")("string")(\n *     () => (value: string) => value.startsWith("$"),\n * );\n *\n * interface TagCustom {\n *    /**\n *     * @powerOf 10\n *     */\n *    powerOf: number;\n *\n *    /**\n *     * @dollar\n *     */\n *    dollar: string;\n * }\n * ```\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare const customValidators: CustomValidatorMap;\n/**\n * > You must configure the generic argument `T`.\n *\n * JSON Schema Application.\n *\n * Creates a JSON schema application which contains both main JSON schemas and components.\n * Note that, all of the object types are stored in the {@link IJsonApplication.components}\n * property for the `$ref` referencing.\n *\n * Also, `typia.application()` has additional generic arguments, *Purpose*.\n * As JSON schema definitions used by `swagger` and `ajv` are different a little bit,\n * you should configure the *Purpose* appropriately.\n *\n * For an example, `ajv` has an extra property "$recursiveRef" that are not exists\n * in the standard JSON schema definition spec. Otherwise, `swagger` can\'t identify\n * the tuple definition.\n *\n * @template Types Tuple of target types\n * @template Purpose Purpose of the JSON schema`\n * @return JSON schema application\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function application(): never;\n/**\n * JSON Schema Application.\n *\n * Creates a JSON schema application which contains both main JSON schemas and components.\n * Note that, all of the object types are stored in the {@link IJsonApplication.components}\n * property for the `$ref` referencing.\n *\n * Also, `typia.application()` has additional generic arguments, *Purpose*.\n * As JSON schema definitions used by `swagger` and `ajv` are different a little bit,\n * you should configure the *Purpose* appropriately.\n *\n * For an example, `ajv` has an extra property "$recursiveRef" that are not exists\n * in the standard JSON schema definition spec. Otherwise, `swagger` can\'t identify\n * the tuple definition.\n *\n * @template Types Tuple of target types\n * @template Purpose Purpose of the JSON schema\n * @return JSON schema application\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function application<Types extends unknown[], Purpose extends "ajv" | "swagger" = "swagger">(): IJsonApplication;\n/**\n * > You must configure the generic argument `T`.\n *\n * Safe `JSON.parse()` function with type assertion.\n *\n * `typia.assertParse()` is a combination function of `JSON.parse()` and {@link assert}.\n * Therefore, it convers a JSON (JavaScript Object Notation) string to a `T` typed\n * instance with type assertion.\n *\n * In such reason, when parsed JSON string value is not matched with the type `T`, it\n * throws {@link TypeGuardError}. Otherwise, there\'s no problem on the parsed value,\n * the parsed value would be returned.\n *\n * @template T Expected type of parsed value\n * @param input JSON string\n * @returns Parsed value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function assertParse(input: string): never;\n/**\n * Safe `JSON.parse()` function with type assertion.\n *\n * `typia.assertParse()` is a combination function of `JSON.parse()` and {@link assert}.\n * Therefore, it convers a JSON (JavaScript Object Notation) string to a `T` typed\n * instance with type assertion.\n *\n * In such reason, when parsed JSON string value is not matched with the type `T`, it\n * throws {@link TypeGuardError}. Otherwise, there\'s no problem on the parsed value,\n * the parsed value would be returned.\n *\n * @template T Expected type of parsed value\n * @param input JSON string\n * @returns Parsed value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function assertParse<T>(input: string): Primitive<T>;\n/**\n * > You must configure the generic argument `T`.\n *\n * Safe `JSON.parse()` function with type checking.\n *\n * `typia.isParse()` is a combination function of `JSON.parse()` and {@link is}.\n * Therefore, it convers a JSON (JavaScript Object Notation) string to a `T` typed\n * instance with type checking.\n *\n * In such reason, when parsed JSON string value is not matched with the type `T`, it\n * returns `null` value. Otherwise, there\'s no problem on the parsed value, the parsed\n * value would be returned.\n *\n * @template T Expected type of parsed value\n * @param input JSON string\n * @returns Parsed value when exact type, otherwise `null`\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function isParse(input: string): never;\n/**\n * Safe `JSON.parse()` function with type checking.\n *\n * `typia.isParse()` is a combination function of `JSON.parse()` and {@link is}.\n * Therefore, it convers a JSON (JavaScript Object Notation) string to a `T` typed\n * instance with type checking.\n *\n * In such reason, when parsed JSON string value is not matched with the type `T`, it\n * returns `null` value. Otherwise, there\'s no problem on the parsed value, the parsed\n * value would be returned.\n *\n * @template T Expected type of parsed value\n * @param input JSON string\n * @returns Parsed value when exact type, otherwise `null`\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function isParse<T>(input: string): Primitive<T> | null;\n/**\n * > You must configure the generic argument `T`.\n *\n * Safe `JSON.parse()` function with detailed type validation.\n *\n * `typia.validateParse()` is a combination function of `JSON.parse()` and\n * {@link validate}. Therefore, it convers a JSON (JavaScript Object Notation) string\n * to a `T` typed instance with detailed type validation.\n *\n * In such reason, when parsed JSON string value is not matched with the type `T`, it\n * returns {@link IValidation.IFailure} value with detailed error reasons. Otherwise,\n * there\'s no problem on the parsed value, the parsed value would be stored in `data`\n * property of the output {@link IValidation.ISuccess} instance.\n *\n * @template T Expected type of parsed value\n * @param input JSON string\n * @returns Validation result with JSON parsed value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function validateParse(input: string): never;\n/**\n * Safe `JSON.parse()` function with detailed type validation.\n *\n * `typia.validateParse()` is a combination function of `JSON.parse()` and\n * {@link validate}. Therefore, it convers a JSON (JavaScript Object Notation) string\n * to a `T` typed instance with detailed type validation.\n *\n * In such reason, when parsed JSON string value is not matched with the type `T`, it\n * returns {@link IValidation.IFailure} value with detailed error reasons. Otherwise,\n * there\'s no problem on the parsed value, the parsed value would be stored in `data`\n * property of the output {@link IValidation.ISuccess} instance.\n *\n * @template T Expected type of parsed value\n * @param input JSON string\n * @returns Validation result with JSON parsed value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function validateParse<T>(input: string): IValidation<Primitive<T>>;\n/**\n * 8x faster `JSON.stringify()` function.\n *\n * Converts an input value to a JSON (JavaScript Object Notation) string, about 8x faster\n * than the native `JSON.stringify()` function. The 5x faster principle is because\n * it writes an optimized JSON conversion plan, only for the type `T`.\n *\n * For reference, this `typia.stringify()` does not validate the input value type.\n * It just believes that the input value is following the type `T`. Therefore, if you\n * can\'t ensure the input value type, it would be better to call one of below functions\n * instead.\n *\n *  - {@link assertStringify}\n *  - {@link isStringify}\n *  - {@link validateStringify}\n *\n * @template T Type of the input value\n * @param input A value to be converted\n * @return JSON string value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function stringify<T>(input: T): string;\n/**\n * 5x faster `JSON.stringify()` function with type assertion.\n *\n * `typia.assertStringify()` is a combination function of {@link assert} and\n * {@link stringify}. Therefore, it converts an input value to JSON (JavaScript Object\n * Notation) string, with type assertion.\n *\n * In such reason, when `input` value is not matched with the type `T`, it throws an\n * {@link TypeGuardError}. Otherwise, there\'s no problem on the `input` value, JSON\n * string would be returned.\n *\n * For reference, with type assertion, it is even 5x times faster than the native\n * `JSON.stringify()` function. So, just enjoy the safe and fast JSON conversion\n * with confidence.\n *\n * @template T Type of the input value\n * @param input A value to be asserted and converted\n * @return JSON string value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function assertStringify<T>(input: T): string;\n/**\n * 5x faster `JSON.stringify()` function with type assertion.\n *\n * `typia.assertStringify()` is a combination function of {@link assert} and\n * {@link stringify}. Therefore, it converts an input value to JSON (JavaScript Object\n * Notation) string, with type assertion.\n *\n * In such reason, when `input` value is not matched with the type `T`, it throws an\n * {@link TypeGuardError}. Otherwise, there\'s no problem on the `input` value, JSON\n * string would be returned.\n *\n * For reference, with type assertion, it is even 5x times faster than the native\n * `JSON.stringify()` function. So, just enjoy the safe and fast JSON conversion\n * with confidence.\n *\n * @template T Type of the input value\n * @param input A value to be asserted and converted\n * @return JSON string value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function assertStringify<T>(input: T): unknown;\n/**\n * 7x faster `JSON.stringify()` function with type checking.\n *\n * `typia.stringify()` is a combination function of {@link is} and\n * {@link stringify}. Therefore, it converts an input value to JSON\n * (JavaScript Object Notation) string, with type checking.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * `null` value. Otherwise, there\'s no problem on the `input` value, JSON string would\n * be returned.\n *\n * For reference, with type checking, it is even 7x times faster than the native\n * `JSON.stringify()` function. So, just enjoy the safe and fast JSON conversion\n * with confidence.\n *\n * @template T Type of the input value\n * @param input A value to be checked and converted\n * @return JSON string value when exact type, otherwise null\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function isStringify<T>(input: T): string | null;\n/**\n * 7x faster `JSON.stringify()` function with type checking.\n *\n * `typia.isStringify()` is a combination function of {@link is} and\n * {@link stringify}. Therefore, it converts an input value to JSON\n * (JavaScript Object Notation) string, with type checking.\n *f\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * `null` value. Otherwise, there\'s no problem on the `input` value, JSON string would\n * be returned.\n *\n * For reference, with type checking, it is even 7x times faster than the native\n * `JSON.stringify()` function. So, just enjoy the safe and fast JSON conversion\n * with confidence.\n *\n * @template T Type of the input value\n * @param input A value to be checked and converted\n * @return JSON string value when exact type, otherwise null\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function isStringify<T>(input: unknown): string | null;\n/**\n * 5x faster `JSON.stringify()` function with detailed type validation.\n *\n * `typia.validateStringify()` is a combination function of {@link validate} and\n * {@link stringify}. Therefore, it converts an input value to JSON (JavaScript Object\n * Notation) string, with detailed type validation.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * {@link IValidation.IFailure} value with detailed error reasons. Otherwise, there\'s no\n * problem on the `input` value, JSON string would be stored in `data` property of\n * the output {@link IValidation.ISuccess} instance.\n *\n * For reference, with detailed type validation, it is even 5x times faster than the\n * native `JSON.stringify()` function. So, just enjoy the safe and fast JSON conversion\n * with confidence.\n *\n * @template T Type of the input value\n * @param input A value to be checked and converted\n * @returns Validation result with JSON string value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function validateStringify<T>(input: T): IValidation<string>;\n/**\n * 5x faster `JSON.stringify()` function with detailed type validation.\n *\n * `typia.validateStringify()` is a combination function of {@link validate} and\n * {@link stringify}. Therefore, it converts an input value to JSON (JavaScript Object\n * Notation) string, with detailed type validation.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * {@link IValidation.IFailure} value with detailed error reasons. Otherwise, there\'s no\n * problem on the `input` value, JSON string would be stored in `data` property of\n * the output {@link IValidation.ISuccess} instance.\n *\n * For reference, with detailed type validation, it is even 5x times faster than the\n * native `JSON.stringify()` function. So, just enjoy the safe and fast JSON conversion\n * with confidence.\n *\n * @template T Type of the input value\n * @param input A value to be checked and converted\n * @returns Validation result with JSON string value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function validateStringify<T>(input: unknown): IValidation<string>;\n/**\n * > You must configure the generic argument `T`.\n *\n * Generate random data.\n *\n * Generates a random data following type the `T`.\n *\n * For reference, this `typia.random()` function generates only primitive type.\n * If there\'re some methods in the type `T` or its nested instances, those would\n * be ignored. Also, when the type `T` has a `toJSON()` method, its return type\n * would be generated instead.\n *\n * @template T Type of data to generate\n * @param generator Random data generator\n * @return Randomly generated data\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function random(generator?: Partial<IRandomGenerator>): never;\n/**\n * Generate random data.\n *\n * Generates a random data following type the `T`.\n *\n * For reference, this `typia.random()` function generates only primitive type.\n * If there\'re some methods in the type `T` or its nested instances, those would\n * be ignored. Also, when the type `T` has a `toJSON()` method, its return type\n * would be generated instead.\n *\n * @template T Type of data to generate\n * @param generator Random data generator\n * @return Randomly generated data\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function random<T>(generator?: Partial<IRandomGenerator>): Primitive<T>;\n/**\n * > You must configure the generic argument `T`.\n *\n * Union literal type to array.\n *\n * Converts a union literal type to an array of its members.\n *\n * ```typescript\n * literals<"A" | "B" | 1>; // ["A", "B", 1]\n * ```\n *\n * @template T Union literal type\n * @return Array of union literal type\'s members\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function literals(): never;\n/**\n * Union literal type to array.\n *\n * Converts a union literal type to an array of its members.\n *\n * ```typescript\n * literals<"A" | "B" | 1>; // ["A", "B", 1]\n * ```\n *\n * @template T Union literal type\n * @return Array of union literal type\'s members\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function literals<T extends Atomic.Type>(): T[];\n/**\n * Clone a data.\n *\n * Clones an instance following type `T`. If the target *input* value or its member\n * variable contains a class instance that is having a `toJSON()` method, its return\n * value would be cloned.\n *\n * For reference, this `typia.clone()` function does not validate the input value type.\n * It just believes that the input value is following the type `T`. Therefore, if you\n * can\'t ensure the input value type, it would be better to call {@link assertClone}\n * function instead.\n *\n * @template T Type of the input value\n * @param input A value to be cloned\n * @return Cloned data\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function clone<T>(input: T): Primitive<T>;\n/**\n * Clone a data with type assertion.\n *\n * Clones an instance following type `T`, with type assertion. If the target `input`\n * value or its member variable contains a class instance that is having a `toJSON()`\n * method, its return value would be cloned.\n *\n * In such reason, when `input` value is not matched with the type `T`, it throws an\n * {@link TypeGuardError}. Otherwise, there\'s no problem on the `input` value, cloned\n * data would be returned.\n *\n * @template T Type of the input value\n * @param input A value to be cloned\n * @return Cloned data\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function assertClone<T>(input: T): Primitive<T>;\n/**\n * Clone a data with type assertion.\n *\n * Clones an instance following type `T`, with type assertion. If the target `input`\n * value or its member variable contains a class instance that is having a `toJSON()`\n * method, its return value would be cloned.\n *\n * In such reason, when `input` value is not matched with the type `T`, it throws an\n * {@link TypeGuardError}. Otherwise, there\'s no problem on the `input` value, cloned\n * data would be returned.\n *\n * @template T Type of the input value\n * @param input A value to be cloned\n * @return Cloned data\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function assertClone<T>(input: unknown): Primitive<T>;\n/**\n * Clone a data with type checking.\n *\n * Clones an instance following type `T`, with type checking. If the target `input`\n * value or its member variable contains a class instance that is having a `toJSON()`\n * method, its return value would be cloned.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * `null` value instead. Otherwise, there\'s no problem on the `input` value, cloned\n * data would be returned.\n *\n * @template T Type of the input value\n * @param input A value to be cloned\n * @return Cloned data when exact type, otherwise null\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function isClone<T>(input: T): Primitive<T> | null;\n/**\n * Clone a data with type checking.\n *\n * Clones an instance following type `T`, with type checking. If the target `input`\n * value or its member variable contains a class instance that is having a `toJSON()`\n * method, its return value would be cloned.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * `null` value instead. Otherwise, there\'s no problem on the `input` value, cloned\n * data would be returned.\n *\n * @template T Type of the input value\n * @param input A value to be cloned\n * @return Cloned data when exact type, otherwise null\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function isClone<T>(input: unknown): Primitive<T> | null;\n/**\n * Clone a data with detailed type validation.\n *\n * Clones an instance following type `T`, with detailed type validation. If the target\n * `input` value or its member variable contains a class instance that is having a\n * `toJSON()` method, its return value would be cloned.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * {@link IValidation.Failure} value. Otherwise, there\'s no problem on the `input`\n * value, cloned data would be stored in `data` property of the output\n * {@link IValidation.Success} instance.\n *\n * @template T Type of the input value\n * @param input A value to be cloned\n * @returns Validation result with cloned value\n */\nexport declare function validateClone<T>(input: T): IValidation<Primitive<T>>;\n/**\n * Clone a data with detailed type validation.\n *\n * Clones an instance following type `T`, with detailed type validation. If the target\n * `input` value or its member variable contains a class instance that is having a\n * `toJSON()` method, its return value would be cloned.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * {@link IValidation.Failure} value. Otherwise, there\'s no problem on the `input`\n * value, cloned data would be stored in `data` property of the output\n * {@link IValidation.Success} instance.\n *\n * @template T Type of the input value\n * @param input A value to be cloned\n * @returns Validation result with cloned value\n */\nexport declare function validateClone<T>(input: unknown): IValidation<Primitive<T>>;\n/**\n * Prune, erase superfluous properties.\n *\n * Remove every superfluous properties from the `input` object, even including nested\n * objects. Note that, as every superfluous properties would be deleted, you never can\n * read those superfluous properties after calling this `prune()` function.\n *\n * For reference, this `typia.prune()` function does not validate the input value type.\n * It just believes that the input value is following the type `T`. Therefore, if you\n * can\'t ensure the input value type, it would better to call one of below functions\n * instead.\n *\n *   - {@link assertPrune}\n *   - {@link isPrune}\n *   - {@link validatePrune}\n *\n * @template T Type of the input value\n * @param input Target instance to prune\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function prune<T extends object>(input: T): void;\n/**\n * Prune, erase superfluous properties, with type assertion.\n *\n * `typia.assertPrune()` is a combination function of {@link assert} and {@link prune}.\n * Therefore, it removes every superfluous properties from the `input` object including\n * nested objects, with type assertion.\n *\n * In such reason, when `input` value is not matched with the type `T`, it throws an\n * {@link TypeGuardError}. Otherwise, there\'s no problem on the `input` value, its\n * every superfluous properties would be removed, including nested objects.\n *\n * @template T Type of the input value\n * @param input Target instance to assert and prune\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function assertPrune<T>(input: T): T;\n/**\n * Prune, erase superfluous properties, with type assertion.\n *\n * `typia.assertPrune()` is a combination function of {@link assert} and {@link prune}.\n * Therefore, it removes every superfluous properties from the `input` object including\n * nested objects, with type assertion.\n *\n * In such reason, when `input` value is not matched with the type `T`, it throws an\n * {@link TypeGuardError}. Otherwise, there\'s no problem on the `input` value, its\n * every superfluous properties would be removed, including nested objects.\n *\n * @template T Type of the input value\n * @param input Target instance to assert and prune\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function assertPrune<T>(input: unknown): T;\n/**\n * Prune, erase superfluous properties, with type checking.\n *\n * `typia.assertPrune()` is a combination function of {@link is} and {@link prune}.\n * Therefore, it removes every superfluous properties from the `input` object including\n * nested objects, with type checking.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * `false` value. Otherwise, there\'s no problem on the `input` value, it returns\n * `true` after removing every superfluous properties, including nested objects.\n *\n * @template T Type of the input value\n * @param input Target instance to check and prune\n * @returns Whether the parametric value is following the type `T` or not\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function isPrune<T>(input: T): input is T;\n/**\n * Prune, erase superfluous properties, with type checking.\n *\n * `typia.assertPrune()` is a combination function of {@link is} and {@link prune}.\n * Therefore, it removes every superfluous properties from the `input` object including\n * nested objects, with type checking.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * `false` value. Otherwise, there\'s no problem on the `input` value, it returns\n * `true` after removing every superfluous properties, including nested objects.\n *\n * @template T Type of the input value\n * @param input Target instance to check and prune\n * @returns Whether the parametric value is following the type `T` or not\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function isPrune<T>(input: unknown): input is T;\n/**\n * Prune, erase superfluous properties, with type validation.\n *\n * `typia.validatePrune()` is a combination function of {@link validate} and {@link prune}.\n * Therefore, it removes every superfluous properties from the `input` object including\n * nested objects, with type validation.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * {@link IValidation.IFailure} value with detailed error reasons. Otherwise, there\'s\n * no problem on the `input` value, it returns {@link IValidation.ISucess} value after\n * removing every superfluous properties, including nested objects.\n *\n * @template T Type of the input value\n * @param input Target instance to validate and prune\n * @returns Validation result\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function validatePrune<T>(input: T): IValidation<T>;\n/**\n * Prune, erase superfluous properties, with type validation.\n *\n * `typia.validatePrune()` is a combination function of {@link validate} and {@link prune}.\n * Therefore, it removes every superfluous properties from the `input` object including\n * nested objects, with type validation.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * {@link IValidation.IFailure} value with detailed error reasons. Otherwise, there\'s\n * no problem on the `input` value, it returns {@link IValidation.ISucess} value after\n * removing every superfluous properties, including nested objects.\n *\n * @template T Type of the input value\n * @param input Target instance to validate and prune\n * @returns Validation result\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function validatePrune<T>(input: unknown): IValidation<T>;\n/**\n * Creates a reusable {@link assert} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createAssert(): never;\n/**\n * Creates a reusable {@link assert} function.\n *\n * @template T Type of the input value\n * @returns A reusable `assert` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createAssert<T>(): (input: unknown) => T;\n/**\n * Creates a reusable {@link assertType} function.\n *\n * Duplicated function of {@link createAssert} for `typescript-is` users.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n * @deprecated\n */\nexport declare function createAssertType(): never;\n/**\n * Creates a reusable {@link assertType} function.\n *\n * Duplicated function of {@link createAssert} for `typescript-is` users.\n *\n * @template T Type of the input value\n * @returns A reusable `assert` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n * @deprecated\n */\nexport declare function createAssertType<T>(): (input: unknown) => T;\n/**\n * Creates a reusable {@link is} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createIs(): never;\n/**\n * Creates a reusable {@link is} function.\n *\n * @template T Type of the input value\n * @returns A reusable `is` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createIs<T>(): (input: unknown) => input is T;\n/**\n * Creates a reusable {@link validate} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createValidate(): never;\n/**\n * Creates a reusable {@link validate} function.\n *\n * @template T Type of the input value\n * @returns A reusable `validate` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createValidate<T>(): (input: unknown) => IValidation<T>;\n/**\n * Creates a reusable {@link assertEquals} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createAssertEquals(): never;\n/**\n * Creates a reusable {@link assertEquals} function.\n *\n * @template T Type of the input value\n * @returns A reusable `assertEquals` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createAssertEquals<T>(): (input: unknown) => T;\n/**\n * Creates a reusable {@link equals} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createEquals(): never;\n/**\n * Creates a reusable {@link equals} function.\n *\n * @template T Type of the input value\n * @returns A reusable `equals` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createEquals<T>(): (input: unknown) => input is T;\n/**\n * Creates a reusable {@link validateEquals} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createValidateEquals(): never;\n/**\n * Creates a reusable {@link validateEquals} function.\n *\n * @template T Type of the input value\n * @returns A reusable `validateEquals` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createValidateEquals<T>(): (input: unknown) => IValidation<T>;\n/**\n * Creates a reusable {@link isParse} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createIsParse(): never;\n/**\n * Creates a reusable {@link isParse} function.\n *\n * @template T Expected type of parsed value\n * @returns A reusable `isParse` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createIsParse<T>(): (input: string) => Primitive<T> | null;\n/**\n * Creates a reusable {@link assertParse} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createAssertParse(): never;\n/**\n * Creates a reusable {@link assertParse} function.\n *\n * @template T Expected type of parsed value\n * @returns A reusable `assertParse` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createAssertParse<T>(): (input: string) => Primitive<T>;\n/**\n * Creates a reusable {@link validateParse} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createValidateParse(): never;\n/**\n * Creates a reusable {@link validateParse} function.\n *\n * @template T Expected type of parsed value\n * @returns A reusable `validateParse` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createValidateParse<T>(): (input: string) => IValidation<Primitive<T>>;\n/**\n * Creates a reusable {@link stringify} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createStringify(): never;\n/**\n * Creates a reusable {@link stringify} function.\n *\n * @template T Type of the input value\n * @returns A reusable `stringify` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createStringify<T>(): (input: T) => string;\n/**\n * Creates a reusable {@link assertStringify} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createAssertStringify(): never;\n/**\n * Creates a reusable {@link assertStringify} function.\n *\n * @template T Type of the input value\n * @returns A reusable `assertStringify` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createAssertStringify<T>(): (input: unknown) => string;\n/**\n * Creates a reusable {@link isStringify} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createIsStringify(): never;\n/**\n * Creates a reusable {@link isStringify} function.\n *\n * @template T Type of the input value\n * @returns A reusable `isStringify` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createIsStringify<T>(): (input: unknown) => string | null;\n/**\n * Creates a reusable {@link validateStringify} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createValidateStringify(): never;\n/**\n * Creates a reusable {@link validateStringify} function.\n *\n * @template T Type of the input value\n * @returns A reusable `validateStringify` function\n\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createValidateStringify<T>(): (input: unknown) => IValidation<string>;\n/**\n * Creates a reusable {@link random} function.\n *\n * @danger You have to specify the generic argument `T`\n * @param generator Random data generator\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createRandom(generator?: Partial<IRandomGenerator>): never;\n/**\n * Creates a resuable {@link random} function.\n *\n * @template T Type of the input value\n * @param generator Random data generator\n * @returns A reusable `random` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createRandom<T>(generator?: Partial<IRandomGenerator>): () => Primitive<T>;\n/**\n * Creates a reusable {@link clone} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createClone(): never;\n/**\n * Creates a resuable {@link clone} function.\n *\n * @template T Type of the input value\n * @returns A reusable `clone` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createClone<T>(): (input: T) => Primitive<T>;\n/**\n * Creates a reusable {@link assertClone} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createAssertClone(): never;\n/**\n * Creates a resuable {@link assertClone} function.\n *\n * @template T Type of the input value\n * @returns A reusable `clone` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createAssertClone<T>(): (input: unknown) => Primitive<T>;\n/**\n * Creates a reusable {@link isClone} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createIsClone(): never;\n/**\n * Creates a resuable {@link isClone} function.\n *\n * @template T Type of the input value\n * @returns A reusable `clone` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createIsClone<T>(): (input: unknown) => Primitive<T> | null;\n/**\n * Creates a reusable {@link validateClone} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createValidateClone(): never;\n/**\n * Creates a resuable {@link validateClone} function.\n *\n * @template T Type of the input value\n * @returns A reusable `clone` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createValidateClone<T>(): (input: unknown) => IValidation<Primitive<T>>;\n/**\n * Creates a reusable {@link prune} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createPrune(): never;\n/**\n * Creates a resuable {@link prune} function.\n *\n * @template T Type of the input value\n * @returns A reusable `prune` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createPrune<T extends object>(): (input: T) => void;\n/**\n * Creates a reusable {@link assertPrune} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createAssertPrune(): never;\n/**\n * Creates a resuable {@link assertPrune} function.\n *\n * @template T Type of the input value\n * @returns A reusable `isPrune` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createAssertPrune<T extends object>(): (input: T) => T;\n/**\n * Creates a reusable {@link isPrune} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createIsPrune(): never;\n/**\n * Creates a resuable {@link isPrune} function.\n *\n * @template T Type of the input value\n * @returns A reusable `isPrune` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createIsPrune<T extends object>(): (input: T) => input is T;\n/**\n * Creates a reusable {@link validatePrune} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createValidatePrune(): never;\n/**\n * Creates a resuable {@link validatePrune} function.\n *\n * @template T Type of the input value\n * @returns A reusable `validatePrune` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createValidatePrune<T extends object>(): (input: T) => IValidation<T>;\n'],["file:///node_modules/typia/lib/Primitive.d.ts",'/**\n * Primitive type.\n *\n * `Primitive` is a type of TMP (Type Meta Programming) type who converts its argument as a\n * primitive type.\n *\n * If the target argument is a built-in class who returns its origin primitive type through\n * the `valueOf()` method like the `String` or `Number`, its return type would be the\n * `string` or `number`.\n *\n * Otherwise, the target argument is a type of custom class, all of its custom method would\n * be erased and its prototype would be changed to the primitive `object`. Therefore, return\n * type of the TMP type finally be the primitive object.\n *\n * In addition, if the target argument is a type of custom class and it has a special\n * method `toJSON()`, return type of this `Primitive` would be not `Primitive<Instance>`\n * but `Primitive<ReturnType<Instance.toJSON>>`.\n *\n * Before                  | After\n * ------------------------|----------------------------------------\n * `Boolean`               | `boolean`\n * `Number`                | `number`\n * `String`                | `string`\n * `Class`                 | `object`\n * `Class` with `toJSON()` | `Primitive<ReturnType<Class.toJSON>>`\n * Others                  | No change\n *\n * @template Instance Target argument type.\n * @author Jenogho Nam - https://github.com/samchon\n * @author Kyungsu Kang - https://github.com/kakasoo\n * @author Michael - https://github.com/8471919\n */\nexport type Primitive<T> = Equal<T, PrimitiveMain<T>> extends true ? T : PrimitiveMain<T>;\ntype Equal<X, Y> = X extends Y ? (Y extends X ? true : false) : false;\ntype PrimitiveMain<Instance> = Instance extends [never] ? never : ValueOf<Instance> extends boolean | number | bigint | string ? ValueOf<Instance> : ValueOf<Instance> extends object ? Instance extends object ? Instance extends NativeClass ? {} : Instance extends IJsonable<infer Raw> ? ValueOf<Raw> extends object ? Raw extends object ? PrimitiveObject<Raw> : never : ValueOf<Raw> : PrimitiveObject<Instance> : never : ValueOf<Instance>;\ntype PrimitiveObject<Instance extends object> = Instance extends Array<infer T> ? IsTuple<Instance> extends true ? PrimitiveTuple<Instance> : PrimitiveMain<T>[] : {\n    [P in keyof Instance]: Instance[P] extends Function ? never : PrimitiveMain<Instance[P]>;\n};\ntype PrimitiveTuple<T extends readonly any[]> = T extends [] ? [] : T extends [infer F] ? [PrimitiveMain<F>] : T extends [infer F, ...infer Rest extends readonly any[]] ? [PrimitiveMain<F>, ...PrimitiveTuple<Rest>] : T extends [(infer F)?] ? [PrimitiveMain<F>?] : T extends [(infer F)?, ...infer Rest extends readonly any[]] ? [PrimitiveMain<F>?, ...PrimitiveTuple<Rest>] : [];\ntype ValueOf<Instance> = IsValueOf<Instance, Boolean> extends true ? boolean : IsValueOf<Instance, Number> extends true ? number : IsValueOf<Instance, String> extends true ? string : Instance;\ntype NativeClass = Set<any> | Map<any, any> | WeakSet<any> | WeakMap<any, any> | Uint8Array | Uint8ClampedArray | Uint16Array | Uint32Array | BigUint64Array | Int8Array | Int16Array | Int32Array | BigInt64Array | Float32Array | Float64Array | ArrayBuffer | SharedArrayBuffer | DataView;\ntype IsTuple<T extends readonly any[] | {\n    length: number;\n}> = [T] extends [\n    never\n] ? false : T extends readonly any[] ? number extends T["length"] ? false : true : false;\ntype IsValueOf<Instance, Object extends IValueOf<any>> = Instance extends Object ? Object extends IValueOf<infer Primitive> ? Instance extends Primitive ? false : true : false : false;\ninterface IValueOf<T> {\n    valueOf(): T;\n}\ninterface IJsonable<T> {\n    toJSON(): T;\n}\nexport {};\n'],["file:///node_modules/typia/lib/TypeGuardError.d.ts","export declare class TypeGuardError extends Error {\n    readonly method: string;\n    readonly path: string | undefined;\n    readonly expected: string;\n    readonly value: any;\n    constructor(props: TypeGuardError.IProps);\n}\nexport declare namespace TypeGuardError {\n    interface IProps {\n        method: string;\n        path?: string;\n        expected: string;\n        value: any;\n        message?: string;\n    }\n}\n"],["file:///node_modules/typia/lib/schemas/IJsonApplication.d.ts",'import { IJsonComponents } from "./IJsonComponents";\nimport { IJsonSchema } from "./IJsonSchema";\nexport interface IJsonApplication {\n    schemas: IJsonSchema[];\n    components: IJsonComponents;\n    purpose: "swagger" | "ajv";\n}\n'],["file:///node_modules/typia/lib/schemas/IJsonComponents.d.ts",'import { IJsDocTagInfo } from "../metadata/IJsDocTagInfo";\nimport { IJsonSchema } from "./IJsonSchema";\nexport interface IJsonComponents {\n    schemas?: Record<string, IJsonComponents.IObject | IJsonComponents.IAlias>;\n}\nexport declare namespace IJsonComponents {\n    interface IObject {\n        $id?: string;\n        type: "object";\n        /**\n         * Only when swagger mode.\n         */\n        nullable?: boolean;\n        properties: Record<string, IJsonSchema>;\n        patternProperties?: Record<string, IJsonSchema>;\n        additionalProperties?: IJsonSchema;\n        required?: string[];\n        description?: string;\n        "x-typia-jsDocTags"?: IJsDocTagInfo[];\n        "x-typia-patternProperties"?: Record<string, IJsonSchema>;\n        "x-typia-additionalProperties"?: IJsonSchema;\n    }\n    type IAlias = IJsonSchema & {\n        $id?: string;\n        $recursiveAnchor?: boolean;\n    };\n}\n'],["file:///node_modules/typia/lib/schemas/IJsonSchema.d.ts",'import { IJsDocTagInfo } from "../metadata/IJsDocTagInfo";\nimport { IMetadataTag } from "../metadata/IMetadataTag";\nimport { Atomic } from "../typings/Atomic";\nexport type IJsonSchema = IJsonSchema.Known | IJsonSchema.IUnknown;\nexport declare namespace IJsonSchema {\n    type Known = IEnumeration<"boolean"> | IEnumeration<"number"> | IEnumeration<"string"> | IBoolean | IInteger | INumber | IString | IArray | ITuple | IOneOf | IReference | INullOnly;\n    interface IUnknown extends IAttribute {\n        type?: undefined;\n    }\n    interface IEnumeration<Literal extends Exclude<Atomic.Literal, "bigint">> extends IAtomic<Literal> {\n        enum: Array<Atomic.Mapper[Literal]>;\n    }\n    interface IAtomic<Literal extends Exclude<Atomic.Literal, "bigint">> extends ISignificant<Literal> {\n        default?: Atomic.Mapper[Literal];\n    }\n    interface IString extends IAtomic<"string"> {\n        /**\n         * @type uint\n         */\n        minLength?: number;\n        /**\n         * @type uint\n         */\n        maxLength?: number;\n        pattern?: string;\n        format?: string;\n    }\n    interface INumber extends IAtomic<"number"> {\n        minimum?: number;\n        maximum?: number;\n        exclusiveMinimum?: boolean;\n        exclusiveMaximum?: boolean;\n        multipleOf?: number;\n    }\n    interface IInteger extends IAtomic<"integer"> {\n        /**\n         * @type int\n         */\n        minimum?: number;\n        /**\n         * @type int\n         */\n        maximum?: number;\n        exclusiveMinimum?: boolean;\n        exclusiveMaximum?: boolean;\n        /**\n         * @type int\n         */\n        multipleOf?: number;\n    }\n    interface IBoolean extends IAtomic<"boolean"> {\n    }\n    interface IArray extends ISignificant<"array"> {\n        items: IJsonSchema;\n        /**\n         * @type uint\n         */\n        minItems?: number;\n        /**\n         * @type uint\n         */\n        maxItems?: number;\n        "x-typia-tuple"?: ITuple;\n    }\n    interface ITuple extends ISignificant<"array"> {\n        items: IJsonSchema[];\n        /**\n         * @type uint\n         */\n        minItems: number;\n        /**\n         * @type uint\n         */\n        maxItems?: number;\n    }\n    interface IReference extends IAttribute {\n        $ref: string;\n    }\n    interface INullOnly extends IAttribute {\n        type: "null";\n    }\n    interface IOneOf extends IAttribute {\n        oneOf: IJsonSchema[];\n    }\n    interface ISignificant<Literal extends string> extends IAttribute {\n        type: Literal;\n        /**\n         * Only when swagger mode.\n         */\n        nullable?: boolean;\n    }\n    interface IAttribute {\n        deprecated?: boolean;\n        title?: string;\n        description?: string;\n        "x-typia-metaTags"?: IMetadataTag[];\n        "x-typia-jsDocTags"?: IJsDocTagInfo[];\n        "x-typia-required"?: boolean;\n        "x-typia-optional"?: boolean;\n        "x-typia-rest"?: boolean;\n    }\n}\n'],["file:///node_modules/typia/lib/typings/Atomic.d.ts",'export declare namespace Atomic {\n    type Type = boolean | number | string | bigint;\n    type Literal = "boolean" | "integer" | "number" | "string" | "bigint";\n    type Mapper = {\n        boolean: boolean;\n        integer: number;\n        number: number;\n        string: string;\n        bigint: bigint;\n    };\n}\n'],["file:///node_modules/typia/lib/typings/Customizable.d.ts","export type Customizable = {\n    number: number;\n    string: string;\n    bigint: bigint;\n};\n"],["file:///node_modules/typia/lib/metadata/ICommentTag.d.ts","export interface ICommentTag {\n    name: string;\n    value?: string;\n}\n"],["file:///node_modules/typia/lib/metadata/IJsDocTagInfo.d.ts","export interface IJsDocTagInfo {\n    name: string;\n    text?: IJsDocTagInfo.IText[];\n}\nexport declare namespace IJsDocTagInfo {\n    interface IText {\n        text: string;\n        kind: string;\n    }\n}\n"],["file:///node_modules/typia/lib/metadata/IMetadataTag.d.ts",'export type IMetadataTag = IMetadataTag.IType | IMetadataTag.IMinimum | IMetadataTag.IMaximum | IMetadataTag.IExclusiveMinimum | IMetadataTag.IExclusiveMaximum | IMetadataTag.IMultipleOf | IMetadataTag.IStep | IMetadataTag.IFormat | IMetadataTag.IPattern | IMetadataTag.ILength | IMetadataTag.IMinLength | IMetadataTag.IMaxLength | IMetadataTag.IItems | IMetadataTag.IMinItems | IMetadataTag.IMaxItems;\nexport declare namespace IMetadataTag {\n    interface IType {\n        kind: "type";\n        value: "int" | "uint";\n    }\n    interface IMinimum {\n        kind: "minimum";\n        value: number;\n    }\n    interface IMaximum {\n        kind: "maximum";\n        value: number;\n    }\n    interface IExclusiveMinimum {\n        kind: "exclusiveMinimum";\n        value: number;\n    }\n    interface IExclusiveMaximum {\n        kind: "exclusiveMaximum";\n        value: number;\n    }\n    interface IMultipleOf {\n        kind: "multipleOf";\n        value: number;\n    }\n    interface IStep {\n        kind: "step";\n        value: number;\n    }\n    interface IFormat {\n        kind: "format";\n        value: "uuid" | "email" | "url" | "ipv4" | "ipv6" | "date" | "datetime";\n    }\n    interface IPattern {\n        kind: "pattern";\n        value: string;\n    }\n    interface ILength {\n        kind: "length";\n        value: number;\n    }\n    interface IMinLength {\n        kind: "minLength";\n        value: number;\n    }\n    interface IMaxLength {\n        kind: "maxLength";\n        value: number;\n    }\n    interface IItems {\n        kind: "items";\n        value: number;\n    }\n    interface IMinItems {\n        kind: "minItems";\n        value: number;\n    }\n    interface IMaxItems {\n        kind: "maxItems";\n        value: number;\n    }\n}\n'],["file:///node_modules/typia/index.d.ts",'export * from "./lib";\nimport typia from "./lib";\nexport default typia;'],["file:///node_modules/typia/packageJson.d.ts",'{\n  "name": "typia",\n  "version": "4.1.1-dev.20230621",\n  "description": "Superfast runtime validators with only one line",\n  "main": "lib/index.js",\n  "typings": "lib/index.d.ts",\n  "bin": {\n    "typia": "./lib/executable/typia.js"\n  },\n  "scripts": {\n    "benchmark": "npm run build:benchmark && node measure/benchmark",\n    "benchmark:generate": "ts-node benchmark/generate && npm run build:benchmark",\n    "test:generate": "npx ts-node src/executable/typia generate --input test/features --output test/generated/output --project test/tsconfig.json",\n    "test:template": "npx tsc && ts-node -P build/tsconfig.json build/test.ts",\n    "----------------------------------------------": "",\n    "build": "rimraf lib && tsc --removeComments --declaration false && tsc --emitDeclarationOnly",\n    "build:test": "rimraf bin && tsc -p test/tsconfig.json",\n    "build:benchmark": "rimraf measure && tsc -p benchmark/tsconfig.json",\n    "build:test:prettier": "npm run build:test && prettier --write ./bin/**/*.js",\n    "dev": "rimraf lib && tsc --watch",\n    "dev:test": "rimraf bin && tsc -p test/tsconfig.json --watch",\n    "eslint": "eslint ./**/*.ts",\n    "eslint:fix": "eslint ./**/*.ts --fix",\n    "prettier": "prettier  --write ./**/*.ts",\n    "-----------------------------------------------": "",\n    "issue": "node test/issue",\n    "issue:generate": "ts-node src/executable/typia generate --input test/issues/generate/input --output test/issues/generate --project test/tsconfig.json",\n    "test": "node bin/test",\n    "test:manual": "node test/manual",\n    "------------------------------------------------": "",\n    "package:latest": "ts-node build/publish.ts latest",\n    "package:next": "ts-node build/publish.ts next",\n    "package:patch": "ts-node build/publish.ts patch",\n    "package:deprecate": "npm deprecate typescript-json "Renamed to typia"",\n    "prepare": "ts-patch install"\n  },\n  "repository": {\n    "type": "git",\n    "url": "https://github.com/samchon/typia"\n  },\n  "keywords": [\n    "fast",\n    "json",\n    "stringify",\n    "typescript",\n    "transform",\n    "ajv",\n    "io-ts",\n    "schema",\n    "jsonschema",\n    "generator",\n    "assert",\n    "clone",\n    "is",\n    "validate",\n    "equal",\n    "runtime",\n    "type",\n    "typebox",\n    "checker",\n    "validator",\n    "safe",\n    "parse",\n    "prune",\n    "random"\n  ],\n  "author": "Jeongho Nam",\n  "license": "MIT",\n  "bugs": {\n    "url": "https://github.com/samchon/typia/issues"\n  },\n  "homepage": "https://typia.io",\n  "dependencies": {\n    "commander": "^10.0.0",\n    "comment-json": "^4.2.3",\n    "inquirer": "^8.2.5",\n    "randexp": "^0.5.3",\n    "raw-loader": "^4.0.2"\n  },\n  "peerDependencies": {\n    "typescript": ">= 4.7.4"\n  },\n  "devDependencies": {\n    "@fastify/type-provider-typebox": "^3.0.0",\n    "@trivago/prettier-plugin-sort-imports": "^3.3.0",\n    "@typegoose/typegoose": "^10.1.1",\n    "@types/autocannon": "^7.9.0",\n    "@types/benchmark": "^2.1.2",\n    "@types/cli": "^0.11.20",\n    "@types/commander": "^2.12.2",\n    "@types/d3": "^7.4.0",\n    "@types/express": "^4.17.14",\n    "@types/inquirer": "^8.2.5",\n    "@types/nested-error-stacks": "^2.1.0",\n    "@types/node": "^18.15.12",\n    "@types/physical-cpu-count": "^2.0.0",\n    "@types/uuid": "^8.3.4",\n    "@typescript-eslint/eslint-plugin": "^5.59.11",\n    "@typescript-eslint/parser": "^5.59.11",\n    "ajv": "^8.12.0",\n    "autocannon": "^7.10.0",\n    "benchmark": "^2.1.4",\n    "chalk": "^4.1.0",\n    "class-transformer": "^0.5.1",\n    "class-validator": "^0.14.0",\n    "cli": "^1.0.1",\n    "d3": "^5.16.0",\n    "eslint-plugin-deprecation": "^1.4.1",\n    "express": "^4.18.2",\n    "fast-json-stringify": "^5.4.0",\n    "fastify": "^4.9.2",\n    "io-ts": "^2.2.19",\n    "jsdom": "^21.1.1",\n    "physical-cpu-count": "^2.0.0",\n    "prettier": "^2.6.2",\n    "reflect-metadata": "^0.1.13",\n    "rimraf": "^3.0.2",\n    "sloc": "^0.2.1",\n    "source-map-support": "^0.5.21",\n    "suppress-warnings": "^1.0.2",\n    "tgrid": "^0.8.7",\n    "ts-node": "^10.9.1",\n    "ts-patch": "^3.0.0",\n    "tstl": "^2.5.13",\n    "typescript": "^5.1.3",\n    "typescript-transform-paths": "^3.4.6",\n    "uuid": "^8.3.2",\n    "zod": "^3.19.1"\n  },\n  "stackblitzs": {\n    "startCommand": "npm run prepare && npm run build && npm run build:test && npm run test"\n  },\n  "files": [\n    "LICENSE",\n    "README.md",\n    "package.json",\n    "lib",\n    "src"\n  ]\n}']];(a=r||(r={})).compile=e=>{let n=new Map;for(let[e,t]of m){if(e.endsWith("packageJson.d.ts"))continue;let a=e.replace("file:///",""),i=c().createSourceFile(e,t,c().ScriptTarget.ES2016);n.set(a,i)}let t=c().createSourceFile("main.ts",e,c().ScriptTarget.ES2016);n.set("main.ts",t);let a={value:""},r=c().createProgram(["main.ts"],i,{fileExists:e=>"node_modules/typia/package.json"===e||n.has(e),writeFile:(e,n)=>a.value=n,readFile:e=>"node_modules/typia/package.json"===e?m.find(e=>e[0].endsWith("packageJson.d.ts"))[1]:void 0,getSourceFile:e=>n.get(e),getDefaultLibFileName:()=>"node_modules/typia/index.d.ts",directoryExists:()=>!0,getCurrentDirectory:()=>"",getDirectories:()=>[],getNewLine:()=>"\n",getCanonicalFileName:e=>e,useCaseSensitiveFileNames:()=>!1});window.checker=r.getTypeChecker(),window.source=t;try{return r.emit(void 0,void 0,void 0,void 0,{before:[d()(r)]}),{type:"success",content:a.value}}catch(e){return{type:"error",error:e}}},i=a.OPTIONS={target:c().ScriptTarget.ES2015,module:c().ModuleKind.CommonJS,lib:["DOM","ES2015"],esModuleInterop:!0,forceConsistentCasingInFileNames:!0,strict:!0,skipLibCheck:!0,emitDecoratorMetadata:!0,experimentalDecorators:!0};var f=t(3764);function g(e){let[n,t]=(0,u.useState)(),a=(0,f.Ik)();return(0,u.useEffect)(()=>{a&&(async()=>{let n=await a.editor.colorize(e.content,e.language,{tabSize:4});t(n)})()},[a,e.content]),(0,o.jsx)("div",{children:n&&(0,o.jsx)("div",{dangerouslySetInnerHTML:{__html:n},style:{backgroundColor:"#1e1e1e",overflowX:"auto",overflowY:"auto",paddingLeft:"15px",width:"calc(50vw - 15px)",height:"calc(90vh - 25px)",fontFamily:"monospace"}})})}let y=e=>{let n=(n,t)=>{for(let[n,a]of(t.languages.typescript.typescriptDefaults.setCompilerOptions(e.options),e.imports))t.languages.typescript.typescriptDefaults.addExtraLib(a,n);let a=t.editor.createModel(e.script,"typescript",t.Uri.parse("file:///main.ts"));n.setModel(a)};return(0,o.jsx)(f.ZP,{height:"calc(90vh - 25px)",theme:"vs-dark",onMount:n,onChange:e.setScript})};var v=t(2571),b=t.n(v);let T=()=>{let[e,n]=(0,u.useState)('import typia from "typia";\n\ninterface IMember {\n    /** \n     * @format uuid \n     */ \n    id: string;\n\n    /** \n     * @format email \n     */ \n    email: string;\n\n    /**\n     * @type uint\n     * @minimum 20\n     * @exclusiveMaximum 100\n     */\n    age: number;\n    parent: IMember | null;\n    children: IMember[];\n}\n\ntypia.createIs<IMember>();\ntypia.createEquals<IMember>();\ntypia.createAssertStringify<IMember>();\n'),[t,a]=(0,u.useState)(null);(0,u.useEffect)(()=>{document.body.style.overflow="hidden",document.body.style.margin="0",document.body.style.fontFamily="Arial, sans-serif",document.body.style.backgroundColor="#1e1e1e";let n=Object.fromEntries(new URLSearchParams(window.location.search).entries());if(n.script){let e=(0,s.decompressFromEncodedURIComponent)(n.script);if(!e)return;i(e)}else i(e)},[]);let i=t=>{n(null!=t?t:"");let i=r.compile(null!=t?t:"");"success"===i.type&&window.history.replaceState(null,"Typia Playground","".concat(location.origin).concat(location.pathname,"?script=").concat((0,s.compressToEncodedURIComponent)(e))),a(i)},p=l.Z;return(0,o.jsxs)("div",{children:[(0,o.jsxs)("header",{className:b().header,children:[(0,o.jsxs)("div",{style:{display:"flex"},children:[(0,o.jsx)("h2",{children:"Typia - Superfast Runtime Validator"}),(0,o.jsx)("button",{className:b().button,onClick:()=>{e&&navigator.permissions.query({name:"clipboard-write"}).then(n=>{("granted"==n.state||"prompt"==n.state)&&navigator.clipboard.writeText(location.origin+location.pathname+"?script=".concat((0,s.compressToEncodedURIComponent)(e)))})},children:"Copy Link"})]}),(0,o.jsx)("a",{href:"https://github.com/samchon/typia",style:{fontSize:"24px"},children:(0,o.jsx)("svg",{xmlns:"http://www.w3.org/2000/svg",width:"28",height:"28",fill:"currentColor",viewBox:"0 0 16 16",children:(0,o.jsx)("path",{d:"M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z"})})})]}),(0,o.jsxs)(p,{split:"vertical",defaultSize:"50%",primary:"first",children:[(0,o.jsx)(y,{options:r.OPTIONS,imports:m,script:e,setScript:i}),(0,o.jsx)(g,{language:"javascript",content:null===t?"":"success"===t.type?t.content:t.error.message})]}),(0,o.jsx)("footer",{className:b().footer,children:(0,o.jsxs)("p",{children:["Made with ❤️ by ",(0,o.jsx)("a",{href:"https://github.com/samchon",children:"Samchon"}),"."]})})]})};var w=T},2571:function(e){e.exports={header:"layout_header__2Q6Ab",footer:"layout_footer__MKiK_",button:"layout_button__262nO",runSection:"layout_runSection__l8m2m",runSectionResult:"layout_runSectionResult__W_yRQ"}},3411:function(e){function n(e){var n=Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}n.keys=function(){return[]},n.resolve=n,n.id=3411,e.exports=n},2183:function(){},3024:function(){},2715:function(){},3611:function(){},8353:function(){},1210:function(){},3454:function(){}},function(e){e.O(0,[138,70,774,888,179],function(){return e(e.s=3746)}),_N_E=e.O()}]);