(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[311],{3589:function(e,n,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/playground",function(){return t(9909)}])},9369:function(e,n,t){"use strict";var a=t(5893);t(7294);let r={logo:()=>(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)("img",{src:"/favicon/android-chrome-192x192.png",width:32,height:32}),(0,a.jsx)("span",{style:{fontWeight:"bold",fontSize:"1.2rem",paddingLeft:10,paddingRight:10},children:"Typia"}),(0,a.jsx)("span",{children:"Superfast Runtime Validator"})]}),project:{link:"https://github.com/samchon/typia",icon:(0,a.jsx)("img",{alt:"Typia Github repo stars",src:"https://img.shields.io/github/stars/samchon/typia?style=social"})},docsRepositoryBase:"https://github.com/samchon/typia/blob/master/website",footer:{text:()=>(0,a.jsxs)("span",{children:["Made by"," ",(0,a.jsx)("a",{href:"https://github.com/samchon",target:"_blank",style:{color:"blue"},children:(0,a.jsx)("u",{children:" Samchon "})})]})},useNextSeoProps:()=>({defaultTitle:"Typia Guide Documents",titleTemplate:"Typia Guide Documents - %s",additionalLinkTags:[{rel:"apple-touch-icon",sizes:"180x180",href:"/favicon/apple-touch-icon.png"},{rel:"manifest",href:"/favicon/site.webmanifest"},...[16,32].map(e=>({rel:"icon",type:"image/png",sizes:"".concat(e,"x").concat(e),href:"/favicon/favicon-".concat(e,"x").concat(e,".png")}))],additionalMetaTags:[{property:"og:image",content:"/og.jpg"},{property:"og:type",content:"object"},{property:"og:title",content:"Typia Guide Documents"},{property:"og:description",content:"Superfast Runtime Validator with only one line"},{property:"og:site_name",content:"Typia Guide Documents"},{property:"og:url",content:"https://typia.io"},{name:"twitter:card",content:"summary"},{name:"twitter:image",content:"https://typia.io/og.jpg"},{name:"twitter:title",content:"Typia Guide Documents"},{name:"twitter:description",content:"Superfast Runtime Validator with only one line"},{name:"twitter:site",content:"@SamchonGithub"}]})};n.Z=r},9909:function(e,n,t){"use strict";t.r(n),t.d(n,{default:function(){return j}});var a,r,i,o=t(5893),s=t(4319),l=t(9271),c=t(9369);t(9966);var u=t(1151);t(5675);var d=t(6961),m=t(7294),p=t(5423),h=t.n(p),f=t(8781),y=t.n(f);let b=[["file:///node_modules/typia/package.json",'{\n  "name": "typia",\n  "version": "4.1.1",\n  "description": "Superfast runtime validators with only one line",\n  "main": "lib/index.js",\n  "typings": "lib/index.d.ts",\n  "bin": {\n    "typia": "./lib/executable/typia.js"\n  },\n  "scripts": {\n    "benchmark": "npm run build:benchmark && node measure/benchmark",\n    "benchmark:generate": "ts-node benchmark/generate && npm run build:benchmark",\n    "test:generate": "npx ts-node src/executable/typia generate --input test/features --output test/generated/output --project test/tsconfig.json",\n    "test:template": "npx tsc && ts-node -P build/tsconfig.json build/test.ts",\n    "----------------------------------------------": "",\n    "build": "rimraf lib && tsc --removeComments --declaration false && tsc --emitDeclarationOnly",\n    "build:test": "rimraf bin && tsc -p test/tsconfig.json",\n    "build:benchmark": "rimraf measure && tsc -p benchmark/tsconfig.json",\n    "build:test:prettier": "npm run build:test && prettier --write ./bin/**/*.js",\n    "dev": "rimraf lib && tsc --watch",\n    "dev:test": "rimraf bin && tsc -p test/tsconfig.json --watch",\n    "eslint": "eslint ./**/*.ts",\n    "eslint:fix": "eslint ./**/*.ts --fix",\n    "prettier": "prettier  --write ./**/*.ts",\n    "-----------------------------------------------": "",\n    "issue": "node test/issue",\n    "issue:generate": "ts-node src/executable/typia generate --input test/issues/generate/input --output test/issues/generate --project test/tsconfig.json",\n    "test": "node bin/test",\n    "test:manual": "node test/manual",\n    "------------------------------------------------": "",\n    "package:latest": "ts-node build/publish.ts latest",\n    "package:next": "ts-node build/publish.ts next",\n    "package:patch": "ts-node build/publish.ts patch",\n    "package:deprecate": "npm deprecate typescript-json "Renamed to typia"",\n    "prepare": "ts-patch install"\n  },\n  "repository": {\n    "type": "git",\n    "url": "https://github.com/samchon/typia"\n  },\n  "keywords": [\n    "fast",\n    "json",\n    "stringify",\n    "typescript",\n    "transform",\n    "ajv",\n    "io-ts",\n    "schema",\n    "jsonschema",\n    "generator",\n    "assert",\n    "clone",\n    "is",\n    "validate",\n    "equal",\n    "runtime",\n    "type",\n    "typebox",\n    "checker",\n    "validator",\n    "safe",\n    "parse",\n    "prune",\n    "random"\n  ],\n  "author": "Jeongho Nam",\n  "license": "MIT",\n  "bugs": {\n    "url": "https://github.com/samchon/typia/issues"\n  },\n  "homepage": "https://typia.io",\n  "dependencies": {\n    "commander": "^10.0.0",\n    "comment-json": "^4.2.3",\n    "inquirer": "^8.2.5",\n    "randexp": "^0.5.3",\n    "raw-loader": "^4.0.2"\n  },\n  "peerDependencies": {\n    "typescript": ">= 4.7.4"\n  },\n  "devDependencies": {\n    "@fastify/type-provider-typebox": "^3.0.0",\n    "@trivago/prettier-plugin-sort-imports": "^3.3.0",\n    "@typegoose/typegoose": "^10.1.1",\n    "@types/autocannon": "^7.9.0",\n    "@types/benchmark": "^2.1.2",\n    "@types/cli": "^0.11.20",\n    "@types/commander": "^2.12.2",\n    "@types/d3": "^7.4.0",\n    "@types/express": "^4.17.14",\n    "@types/inquirer": "^8.2.5",\n    "@types/nested-error-stacks": "^2.1.0",\n    "@types/node": "^18.15.12",\n    "@types/physical-cpu-count": "^2.0.0",\n    "@types/uuid": "^8.3.4",\n    "@typescript-eslint/eslint-plugin": "^5.59.11",\n    "@typescript-eslint/parser": "^5.59.11",\n    "ajv": "^8.12.0",\n    "autocannon": "^7.10.0",\n    "benchmark": "^2.1.4",\n    "chalk": "^4.1.0",\n    "class-transformer": "^0.5.1",\n    "class-validator": "^0.14.0",\n    "cli": "^1.0.1",\n    "d3": "^5.16.0",\n    "eslint-plugin-deprecation": "^1.4.1",\n    "express": "^4.18.2",\n    "fast-json-stringify": "^5.4.0",\n    "fastify": "^4.9.2",\n    "io-ts": "^2.2.19",\n    "jsdom": "^21.1.1",\n    "physical-cpu-count": "^2.0.0",\n    "prettier": "^2.6.2",\n    "reflect-metadata": "^0.1.13",\n    "rimraf": "^3.0.2",\n    "sloc": "^0.2.1",\n    "source-map-support": "^0.5.21",\n    "suppress-warnings": "^1.0.2",\n    "tgrid": "^0.8.7",\n    "ts-node": "^10.9.1",\n    "ts-patch": "^3.0.0",\n    "tstl": "^2.5.13",\n    "typescript": "^5.1.3",\n    "typescript-transform-paths": "^3.4.6",\n    "uuid": "^8.3.2",\n    "zod": "^3.19.1"\n  },\n  "stackblitzs": {\n    "startCommand": "npm run prepare && npm run build && npm run build:test && npm run test"\n  },\n  "files": [\n    "LICENSE",\n    "README.md",\n    "package.json",\n    "lib",\n    "src"\n  ]\n}'],["file:///node_modules/typia/index.d.ts",'export * from "./lib;\nimport * as typia from "./lib";\nexport default typia;'],["file:///node_modules/typia/lib/CustomValidatorMap.d.ts",'import { Customizable } from "./typings/Customizable";\n/**\n * Map of custom validators.\n *\n * Map of custom validator functions, storing tag name and type of target value\n * as key, and custom validator function as value.\n *\n * When you want to add a custom validation logic utilizing comment tags, you\n * can insert a custom validator function with specific tag name and type of\n * the target value like below.\n *\n * ```ts\n * typia.customValidators.insert("powerOf")("number")(\n *     (text: string) => {\n *         const denominator: number = Math.log(Number(text));\n *         return (value: number) => {\n *             value = Math.log(value) / denominator;\n *             return value === Math.floor(value);\n *         };\n *     }\n * );\n * typia.customValidators.insert("dollar")("string")(\n *     () => (value: string) => value.startsWith("$"),\n * );\n *\n * interface TagCustom {\n *    /**\n *     * @powerOf 10\n *     */\n *    powerOf: number;\n *\n *    /**\n *     * @dollar\n *     */\n *    dollar: string;\n * }\n * ```\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport interface CustomValidatorMap {\n    /**\n     * Get number of stored tags.\n     *\n     * @return Number of stored tags\n     */\n    size(): number;\n    /**\n     * Get number of stored types of the specified tag name.\n     *\n     * In other words, number of stored custom validator functions of\n     * the specified tag name.\n     *\n     * @param name Tag name\n     * @return Number of stored types function\n     */\n    size(name: string): number;\n    /**\n     * Test whether custom validator function exists or not.\n     *\n     * @param name Tag name\n     * @param type Type of the target value\n     * @returns Whether exists or not\n     */\n    has: (name: string) => (type: keyof Customizable) => boolean;\n    /**\n     * Get custom validator function.\n     *\n     * @param name Tag name\n     * @param type Type of the target value\n     * @returns Custom validator function or undefined value\n     */\n    get(name: string): <Type extends keyof Customizable>(type: Type) => CustomValidatorMap.Closure<Type> | undefined;\n    /**\n     * Insert a new custom validator function.\n     *\n     * You can add a custom validation logic utilizing comment tags,\n     * by inserting a function which returns a boolean value, with specific\n     * tag name and type of the target value.\n     *\n     * However, if you try to insert a duplicated tag name and type, the\n     * closure function would not be enrolled and `false` value would be\n     * returned.\n     *\n     * @param name Tag name\n     * @param type Type of the target value\n     * @param closure Custom validator function\n     * @returns Whether succeeded to insert or not\n     */\n    insert(name: string): <Type extends keyof Customizable>(type: Type) => (closure: CustomValidatorMap.Closure<Type>) => boolean;\n    /**\n     * Erase custom validator function.\n     *\n     * @param name Tag name\n     * @param type Type of the target value\n     * @returns Whether succeeded to erase or not\n     */\n    erase(name: string): (type: keyof Customizable) => boolean;\n}\nexport declare namespace CustomValidatorMap {\n    /**\n     * Type of closure function of custom validation.\n     *\n     * @template Type Type of the target value\n     * @param text Text of the tag. For example, if the tag is `@powerOf 10`, `text` is 10.\n     * @param value Value to validate\n     * @returns Whether the value is valid or not\n     */\n    type Closure<Type extends keyof Customizable> = (text: string) => (value: Customizable[Type]) => boolean;\n}\n'],["file:///node_modules/typia/lib/executable/setup/ArgumentParser.d.ts",'import commander from "commander";\nimport inquirer from "inquirer";\nimport { PackageManager } from "./PackageManager";\nexport declare namespace ArgumentParser {\n    type Inquiry<T> = (pack: PackageManager, command: commander.Command, prompt: (opt?: inquirer.StreamOptions) => inquirer.PromptModule, action: (closure: (options: Partial<T>) => Promise<T>) => Promise<T>) => Promise<T>;\n    const parse: (pack: PackageManager) => <T>(inquiry: (pack: PackageManager, command: commander.Command, prompt: (opt?: inquirer.StreamOptions) => inquirer.PromptModule, action: (closure: (options: Partial<T>) => Promise<T>) => Promise<T>) => Promise<T>) => Promise<T>;\n}\n'],["file:///node_modules/typia/lib/executable/setup/CommandExecutor.d.ts","export declare namespace CommandExecutor {\n    const run: (str: string) => void;\n}\n"],["file:///node_modules/typia/lib/executable/setup/FileRetriever.d.ts","export declare namespace FileRetriever {\n    const directory: (name: string) => (dir: string, depth?: number) => string | null;\n    const file: (name: string) => (directory: string, depth?: number) => string | null;\n}\n"],["file:///node_modules/typia/lib/executable/setup/PackageManager.d.ts","export declare class PackageManager {\n    readonly directory: string;\n    data: Package.Data;\n    manager: string;\n    get file(): string;\n    static mount(): Promise<PackageManager>;\n    save(modifier: (data: Package.Data) => void): Promise<void>;\n    install(props: {\n        dev: boolean;\n        modulo: string;\n        version: string;\n    }): boolean;\n    private constructor();\n    private static load;\n}\nexport declare namespace Package {\n    interface Data {\n        scripts?: Record<string, string>;\n        dependencies?: Record<string, string>;\n        devDependencies?: Record<string, string>;\n    }\n}\n"],["file:///node_modules/typia/lib/executable/setup/PluginConfigurator.d.ts",'import { TypiaSetupWizard } from "../TypiaSetupWizard";\nexport declare namespace PluginConfigurator {\n    function configure(args: TypiaSetupWizard.IArguments): Promise<void>;\n}\n'],["file:///node_modules/typia/lib/executable/typia.d.ts",'#!/usr/bin/env node\ndeclare const USAGE = "Wrong command has been detected. Use like below:\n\n  npx typia setup \\\n    --manager (npm|pnpm|yarn) \\\n    --project {tsconfig.json file path}\n\n    - npx typia setup\n    - npx typia setup --manager pnpm\n    - npx typia setup --project tsconfig.test.json\n\n  npx typia generate \n    --input {directory} \\\n    --output {directory}\n\n    --npx typia generate --input src/templates --output src/functinoal\n";\ndeclare const halt: (desc: string) => never;\ndeclare const main: () => Promise<void>;\n'],["file:///node_modules/typia/lib/executable/TypiaGenerateWizard.d.ts","export declare namespace TypiaGenerateWizard {\n    function generate(): Promise<void>;\n    interface IArguments {\n        input: string;\n        output: string;\n        project: string;\n    }\n}\n"],["file:///node_modules/typia/lib/executable/TypiaSetupWizard.d.ts",'export declare namespace TypiaSetupWizard {\n    interface IArguments {\n        manager: "npm" | "pnpm" | "yarn";\n        project: string | null;\n    }\n    function setup(): Promise<void>;\n}\n'],["file:///node_modules/typia/lib/factories/CommentFactory.d.ts",'import ts from "typescript";\nexport declare namespace CommentFactory {\n    const description: (symbol: ts.Symbol) => string | undefined;\n    const merge: (comments: ts.SymbolDisplayPart[]) => string;\n}\n'],["file:///node_modules/typia/lib/factories/ExpressionFactory.d.ts",'import ts from "typescript";\nexport declare namespace ExpressionFactory {\n    const isRequired: (input: ts.Expression) => ts.Expression;\n    const isArray: (input: ts.Expression) => ts.Expression;\n    const isObject: (options: {\n        checkNull: boolean;\n        checkArray: boolean;\n    }) => (input: ts.Expression) => ts.Expression;\n    const isInstanceOf: (type: string) => (input: ts.Expression) => ts.Expression;\n    const coalesce: (x: ts.Expression) => (y: ts.Expression) => ts.Expression;\n}\n'],["file:///node_modules/typia/lib/factories/IdentifierFactory.d.ts",'import ts from "typescript";\nexport declare namespace IdentifierFactory {\n    const identifier: (name: string) => ts.Identifier | ts.StringLiteral;\n    const access: (target: ts.Expression) => (property: string) => ts.ElementAccessExpression | ts.PropertyAccessExpression;\n    const postfix: (str: string) => string;\n    const parameter: (name: string | ts.BindingName, type?: ts.TypeNode, init?: ts.Expression | ts.PunctuationToken<ts.SyntaxKind.QuestionToken>) => any;\n}\n'],["file:///node_modules/typia/lib/factories/internal/metadata/emend_metadata_atomics.d.ts",'import { Metadata } from "../../../metadata/Metadata";\nexport declare const emend_metadata_atomics: (meta: Metadata) => void;\n'],["file:///node_modules/typia/lib/factories/internal/metadata/emplace_metadata_array.d.ts",'import ts from "typescript";\nimport { MetadataArray } from "../../../metadata/MetadataArray";\nimport { MetadataCollection } from "../../MetadataCollection";\nimport { MetadataFactory } from "../../MetadataFactory";\nexport declare const emplace_metadata_array: (checker: ts.TypeChecker) => (options: MetadataFactory.IOptions) => (collection: MetadataCollection) => (type: ts.Type, nullable: boolean) => MetadataArray;\n'],["file:///node_modules/typia/lib/factories/internal/metadata/emplace_metadata_definition.d.ts",'import ts from "typescript";\nimport { MetadataAlias } from "../../../metadata/MetadataAlias";\nimport { MetadataCollection } from "../../MetadataCollection";\nimport { MetadataFactory } from "../../MetadataFactory";\nexport declare const emplace_metadata_definition: (checker: ts.TypeChecker) => (options: MetadataFactory.IOptions) => (collection: MetadataCollection) => (type: ts.Type, nullable: boolean) => MetadataAlias;\n'],["file:///node_modules/typia/lib/factories/internal/metadata/emplace_metadata_object.d.ts",'import ts from "typescript";\nimport { MetadataObject } from "../../../metadata/MetadataObject";\nimport { MetadataCollection } from "../../MetadataCollection";\nimport { MetadataFactory } from "../../MetadataFactory";\nexport declare const emplace_metadata_object: (checker: ts.TypeChecker) => (options: MetadataFactory.IOptions) => (collection: MetadataCollection) => (parent: ts.Type, nullable: boolean) => MetadataObject;\n'],["file:///node_modules/typia/lib/factories/internal/metadata/emplace_metadata_tuple.d.ts",'import ts from "typescript";\nimport { MetadataTuple } from "../../../metadata/MetadataTuple";\nimport { MetadataCollection } from "../../MetadataCollection";\nimport { MetadataFactory } from "../../MetadataFactory";\nexport declare const emplace_metadata_tuple: (checker: ts.TypeChecker) => (options: MetadataFactory.IOptions) => (collection: MetadataCollection) => (type: ts.TupleType, nullable: boolean) => MetadataTuple;\n'],["file:///node_modules/typia/lib/factories/internal/metadata/explore_metadata.d.ts",'import ts from "typescript";\nimport { Metadata } from "../../../metadata/Metadata";\nimport { MetadataCollection } from "../../MetadataCollection";\nimport { MetadataFactory } from "../../MetadataFactory";\nexport declare const explore_metadata: (checker: ts.TypeChecker) => (options: MetadataFactory.IOptions) => (collection: MetadataCollection) => (type: ts.Type | null, parentResolved: boolean, aliased?: boolean) => Metadata;\n'],["file:///node_modules/typia/lib/factories/internal/metadata/iterate_metadata.d.ts",'import ts from "typescript";\nimport { Metadata } from "../../../metadata/Metadata";\nimport { MetadataCollection } from "../../MetadataCollection";\nimport { MetadataFactory } from "../../MetadataFactory";\nexport declare const iterate_metadata: (checker: ts.TypeChecker) => (options: MetadataFactory.IOptions) => (collection: MetadataCollection) => (meta: Metadata, type: ts.Type, resolved: boolean, aliased: boolean) => void;\n'],["file:///node_modules/typia/lib/factories/internal/metadata/iterate_metadata_alias.d.ts",'import ts from "typescript";\nimport { Metadata } from "../../../metadata/Metadata";\nimport { MetadataCollection } from "../../MetadataCollection";\nimport { MetadataFactory } from "../../MetadataFactory";\nexport declare const iterate_metadata_alias: (checker: ts.TypeChecker) => (options: MetadataFactory.IOptions) => (collection: MetadataCollection) => (meta: Metadata, type: ts.Type) => boolean;\n'],["file:///node_modules/typia/lib/factories/internal/metadata/iterate_metadata_array.d.ts",'import ts from "typescript";\nimport { Metadata } from "../../../metadata/Metadata";\nimport { MetadataCollection } from "../../MetadataCollection";\nimport { MetadataFactory } from "../../MetadataFactory";\nexport declare const iterate_metadata_array: (checker: ts.TypeChecker) => (options: MetadataFactory.IOptions) => (collection: MetadataCollection) => (meta: Metadata, type: ts.Type) => boolean;\n'],["file:///node_modules/typia/lib/factories/internal/metadata/iterate_metadata_atomic.d.ts",'import ts from "typescript";\nimport { Metadata } from "../../../metadata/Metadata";\nexport declare const iterate_metadata_atomic: (meta: Metadata, type: ts.Type) => boolean;\n'],["file:///node_modules/typia/lib/factories/internal/metadata/iterate_metadata_coalesce.d.ts",'import ts from "typescript";\nimport { Metadata } from "../../../metadata/Metadata";\nexport declare const iterate_metadata_coalesce: (meta: Metadata, type: ts.Type) => boolean;\n'],["file:///node_modules/typia/lib/factories/internal/metadata/iterate_metadata_collection.d.ts",'import { MetadataCollection } from "../../MetadataCollection";\nexport declare const iterate_metadata_collection: (collection: MetadataCollection) => void;\n'],["file:///node_modules/typia/lib/factories/internal/metadata/iterate_metadata_constant.d.ts",'import ts from "typescript";\nimport { Metadata } from "../../../metadata/Metadata";\nimport { MetadataFactory } from "../../MetadataFactory";\nexport declare const iterate_metadata_constant: (checker: ts.TypeChecker) => (options: MetadataFactory.IOptions) => (meta: Metadata, type: ts.Type) => boolean;\n'],["file:///node_modules/typia/lib/factories/internal/metadata/iterate_metadata_intersection.d.ts",'import ts from "typescript";\nimport { Metadata } from "../../../metadata/Metadata";\nimport { MetadataCollection } from "../../MetadataCollection";\nimport { MetadataFactory } from "../../MetadataFactory";\nexport declare const iterate_metadata_intersection: (checker: ts.TypeChecker) => (options: MetadataFactory.IOptions) => (collection: MetadataCollection) => (meta: Metadata, type: ts.Type, resolved: boolean, aliased: boolean) => boolean;\n'],["file:///node_modules/typia/lib/factories/internal/metadata/iterate_metadata_map.d.ts",'import ts from "typescript";\nimport { Metadata } from "../../../metadata/Metadata";\nimport { MetadataCollection } from "../../MetadataCollection";\nimport { MetadataFactory } from "../../MetadataFactory";\nexport declare const iterate_metadata_map: (checker: ts.TypeChecker) => (options: MetadataFactory.IOptions) => (collection: MetadataCollection) => (meta: Metadata, type: ts.Type) => boolean;\n'],["file:///node_modules/typia/lib/factories/internal/metadata/iterate_metadata_native.d.ts",'import ts from "typescript";\nimport { Metadata } from "../../../metadata/Metadata";\nexport declare const iterate_metadata_native: (checker: ts.TypeChecker) => (meta: Metadata, type: ts.Type) => boolean;\n'],["file:///node_modules/typia/lib/factories/internal/metadata/iterate_metadata_object.d.ts",'import ts from "typescript";\nimport { Metadata } from "../../../metadata/Metadata";\nimport { MetadataCollection } from "../../MetadataCollection";\nimport { MetadataFactory } from "../../MetadataFactory";\nexport declare const iterate_metadata_object: (checker: ts.TypeChecker) => (options: MetadataFactory.IOptions) => (collection: MetadataCollection) => (meta: Metadata, type: ts.Type, parentResolved: boolean, ensure?: boolean) => boolean;\n'],["file:///node_modules/typia/lib/factories/internal/metadata/iterate_metadata_resolve.d.ts",'import ts from "typescript";\nimport { Metadata } from "../../../metadata/Metadata";\nimport { MetadataCollection } from "../../MetadataCollection";\nimport { MetadataFactory } from "../../MetadataFactory";\nexport declare const iterate_metadata_resolve: (checker: ts.TypeChecker) => (options: MetadataFactory.IOptions) => (collection: MetadataCollection) => (meta: Metadata, type: ts.Type, resolved: boolean, aliased: boolean) => boolean;\n'],["file:///node_modules/typia/lib/factories/internal/metadata/iterate_metadata_set.d.ts",'import ts from "typescript";\nimport { Metadata } from "../../../metadata/Metadata";\nimport { MetadataCollection } from "../../MetadataCollection";\nimport { MetadataFactory } from "../../MetadataFactory";\nexport declare const iterate_metadata_set: (checker: ts.TypeChecker) => (options: MetadataFactory.IOptions) => (collection: MetadataCollection) => (meta: Metadata, type: ts.Type) => boolean;\n'],["file:///node_modules/typia/lib/factories/internal/metadata/iterate_metadata_sort.d.ts",'import { Metadata } from "../../../metadata/Metadata";\nimport { MetadataCollection } from "../../MetadataCollection";\nexport declare const iterate_metadata_sort: (collection: MetadataCollection) => (meta: Metadata) => void;\n'],["file:///node_modules/typia/lib/factories/internal/metadata/iterate_metadata_template.d.ts",'import ts from "typescript";\nimport { Metadata } from "../../../metadata/Metadata";\nimport { MetadataCollection } from "../../MetadataCollection";\nimport { MetadataFactory } from "../../MetadataFactory";\nexport declare const iterate_metadata_template: (checker: ts.TypeChecker) => (options: MetadataFactory.IOptions) => (collection: MetadataCollection) => (meta: Metadata, type: ts.Type) => boolean;\n'],["file:///node_modules/typia/lib/factories/internal/metadata/iterate_metadata_tuple.d.ts",'import ts from "typescript";\nimport { Metadata } from "../../../metadata/Metadata";\nimport { MetadataCollection } from "../../MetadataCollection";\nimport { MetadataFactory } from "../../MetadataFactory";\nexport declare const iterate_metadata_tuple: (checker: ts.TypeChecker) => (options: MetadataFactory.IOptions) => (collection: MetadataCollection) => (meta: Metadata, type: ts.TupleType) => boolean;\n'],["file:///node_modules/typia/lib/factories/internal/metadata/iterate_metadata_union.d.ts",'import ts from "typescript";\nimport { Metadata } from "../../../metadata/Metadata";\nimport { MetadataCollection } from "../../MetadataCollection";\nimport { MetadataFactory } from "../../MetadataFactory";\nexport declare const iterate_metadata_union: (checker: ts.TypeChecker) => (options: MetadataFactory.IOptions) => (collection: MetadataCollection) => (meta: Metadata, type: ts.Type, parentResolved: boolean) => boolean;\n'],["file:///node_modules/typia/lib/factories/internal/metadata/MetadataHelper.d.ts",'import { Metadata } from "../../../metadata/Metadata";\nexport declare namespace MetadataHelper {\n    const literal_to_metadata: (key: string) => Metadata;\n}\n'],["file:///node_modules/typia/lib/factories/LiteralFactory.d.ts",'import ts from "typescript";\nexport declare namespace LiteralFactory {\n    const generate: (input: any) => ts.Expression;\n}\n'],["file:///node_modules/typia/lib/factories/MetadataCollection.d.ts",'import ts from "typescript";\nimport { IMetadataCollection } from "../metadata/IMetadataCollection";\nimport { Metadata } from "../metadata/Metadata";\nimport { MetadataAlias } from "../metadata/MetadataAlias";\nimport { MetadataArray } from "../metadata/MetadataArray";\nimport { MetadataObject } from "../metadata/MetadataObject";\nimport { MetadataTuple } from "../metadata/MetadataTuple";\nexport declare class MetadataCollection {\n    private readonly options?;\n    private readonly objects_;\n    private readonly object_unions_;\n    private readonly aliases_;\n    private readonly arrays_;\n    private readonly tuples_;\n    private readonly names_;\n    private object_index_;\n    private recursive_array_index_;\n    private recursive_tuple_index_;\n    constructor(options?: Partial<MetadataCollection.IOptions> | undefined);\n    aliases(): MetadataAlias[];\n    objects(): MetadataObject[];\n    unions(): MetadataObject[][];\n    arrays(): MetadataArray[];\n    tuples(): MetadataTuple[];\n    private getName;\n    emplace(checker: ts.TypeChecker, type: ts.Type): [MetadataObject, boolean];\n    emplaceAlias(checker: ts.TypeChecker, type: ts.Type, symbol: ts.Symbol): [MetadataAlias, boolean, (meta: Metadata) => void];\n    emplaceArray(checker: ts.TypeChecker, type: ts.Type): [MetadataArray, boolean, (meta: Metadata) => void];\n    emplaceTuple(checker: ts.TypeChecker, type: ts.TupleType): [MetadataTuple, boolean, (elements: Metadata[]) => void];\n    setTupleRecursive(tuple: MetadataTuple, recursive: boolean): void;\n    toJSON(): IMetadataCollection;\n}\nexport declare namespace MetadataCollection {\n    interface IOptions {\n        replace?(str: string): string;\n    }\n    const replace: (str: string) => string;\n    const escape: (str: string) => string;\n}\n'],["file:///node_modules/typia/lib/factories/MetadataFactory.d.ts",'import ts from "typescript";\nimport { Metadata } from "../metadata/Metadata";\nimport { MetadataCollection } from "./MetadataCollection";\nexport declare namespace MetadataFactory {\n    interface IOptions {\n        resolve: boolean;\n        constant: boolean;\n        absorb: boolean;\n        validate?: (meta: Metadata) => void;\n    }\n    const analyze: (checker: ts.TypeChecker) => (options: IOptions) => (collection: MetadataCollection) => (type: ts.Type | null) => Metadata;\n}\n'],["file:///node_modules/typia/lib/factories/MetadataTagFactory.d.ts",'import ts from "typescript";\nimport { IMetadataTag } from "../metadata/IMetadataTag";\nimport { Metadata } from "../metadata/Metadata";\nexport declare namespace MetadataTagFactory {\n    const generate: (metadata: Metadata) => (tagList: ts.JSDocTagInfo[]) => (identifier: () => string) => IMetadataTag[];\n}\n'],["file:///node_modules/typia/lib/factories/StatementFactory.d.ts",'import ts from "typescript";\nexport declare namespace StatementFactory {\n    const constant: (name: string, initializer?: ts.Expression) => ts.VariableStatement;\n    const transpile: (script: string) => ts.ExpressionStatement;\n}\n'],["file:///node_modules/typia/lib/factories/TemplateFactory.d.ts",'import ts from "typescript";\nexport declare namespace TemplateFactory {\n    const generate: (expressions: ts.Expression[]) => ts.Expression;\n}\n'],["file:///node_modules/typia/lib/factories/TypeFactory.d.ts",'import ts from "typescript";\nexport declare namespace TypeFactory {\n    const resolve: (checker: ts.TypeChecker) => (type: ts.Type) => ts.Type | null;\n    const isFunction: (type: ts.Type) => boolean;\n    const getReturnType: (checker: ts.TypeChecker) => (type: ts.Type) => (name: string) => ts.Type | null;\n    const getFullName: (checker: ts.TypeChecker) => (type: ts.Type, symbol?: ts.Symbol) => string;\n    const keyword: (type: "void" | "any" | "unknown" | "boolean" | "number" | "bigint" | "string") => ts.KeywordTypeNode<ts.SyntaxKind.VoidKeyword | ts.SyntaxKind.AnyKeyword | ts.SyntaxKind.BooleanKeyword | ts.SyntaxKind.NumberKeyword | ts.SyntaxKind.StringKeyword | ts.SyntaxKind.UnknownKeyword | ts.SyntaxKind.BigIntKeyword>;\n}\n'],["file:///node_modules/typia/lib/factories/ValueFactory.d.ts",'import ts from "typescript";\nexport declare namespace ValueFactory {\n    const NULL: () => ts.NullLiteral;\n    const UNDEFINED: () => ts.Identifier;\n    const BOOLEAN: (value: boolean) => ts.FalseLiteral | ts.TrueLiteral;\n    const INPUT: (str?: string) => ts.Identifier;\n    const TYPEOF: (input: ts.Expression) => ts.TypeOfExpression;\n}\n'],["file:///node_modules/typia/lib/functional/$any.d.ts","export declare const $any: (val: any) => any;\n"],["file:///node_modules/typia/lib/functional/$dictionary.d.ts",'import { Customizable } from "../typings/Customizable";\nexport declare const $dictionary: Map<string, Map<keyof Customizable, (tagText: string) => (value: any) => boolean>>;\n'],["file:///node_modules/typia/lib/functional/$every.d.ts",'import { TypeGuardError } from "../TypeGuardError";\nexport declare const $every: <T>(array: T[], pred: (value: T, i: number) => null | Omit<TypeGuardError.IProps, "method">) => null | Omit<TypeGuardError.IProps, "method">;\n'],["file:///node_modules/typia/lib/functional/$guard.d.ts","export {};\n"],["file:///node_modules/typia/lib/functional/$is_between.d.ts","export declare const $is_between: (value: number, minimum: number, maximum: number) => boolean;\n"],["file:///node_modules/typia/lib/functional/$is_custom.d.ts",'import { Customizable } from "../typings/Customizable";\nexport declare const $is_custom: <Type extends keyof Customizable>(name: string, type: Type, text: string, value: Customizable[Type]) => boolean;\n'],["file:///node_modules/typia/lib/functional/$is_date.d.ts","export declare const $is_date: (value: string) => boolean;\n"],["file:///node_modules/typia/lib/functional/$is_datetime.d.ts","export declare const $is_datetime: (value: string) => boolean;\n"],["file:///node_modules/typia/lib/functional/$is_email.d.ts","export declare const $is_email: (str: string) => boolean;\n"],["file:///node_modules/typia/lib/functional/$is_ipv4.d.ts","export declare const $is_ipv4: (str: string) => boolean;\n"],["file:///node_modules/typia/lib/functional/$is_ipv6.d.ts","export declare const $is_ipv6: (str: string) => boolean;\n"],["file:///node_modules/typia/lib/functional/$is_url.d.ts","export declare const $is_url: (str: string) => boolean;\n"],["file:///node_modules/typia/lib/functional/$is_uuid.d.ts","export declare const $is_uuid: (str: string) => boolean;\n"],["file:///node_modules/typia/lib/functional/$join.d.ts","export declare const $join: (str: string) => string;\n"],["file:///node_modules/typia/lib/functional/$number.d.ts","export declare const $number: (value: number) => number;\n"],["file:///node_modules/typia/lib/functional/$report.d.ts",'import { IValidation } from "../IValidation";\nexport declare const $report: (array: IValidation.IError[]) => (exceptable: boolean, error: IValidation.IError) => false;\n'],["file:///node_modules/typia/lib/functional/$rest.d.ts","export declare const $rest: (str: string) => string;\n"],["file:///node_modules/typia/lib/functional/$string.d.ts","export {};\n"],["file:///node_modules/typia/lib/functional/$tail.d.ts","export {};\n"],["file:///node_modules/typia/lib/functional/Namespace.d.ts","export {};\n"],["file:///node_modules/typia/lib/index.d.ts",'import * as typia from "./module";\nexport default typia;\nexport * from "./module";\n'],["file:///node_modules/typia/lib/IRandomGenerator.d.ts",'import { Customizable } from "./typings/Customizable";\nexport interface IRandomGenerator {\n    boolean(): boolean;\n    integer(minimum?: number, maximum?: number): number;\n    number(minimum?: number, maximum?: number): number;\n    bigint(minimum?: bigint, maximum?: bigint): bigint;\n    string(length?: number): string;\n    array<T>(closure: (index: number) => T, count?: number): T[];\n    length(): number;\n    uuid(): string;\n    email(): string;\n    url(): string;\n    ipv4(): string;\n    ipv6(): string;\n    pattern(regex: RegExp): string;\n    date(minimum?: number, maximum?: number): string;\n    datetime(minimum?: number, maximum?: number): string;\n    customs?: IRandomGenerator.CustomMap;\n}\nexport declare namespace IRandomGenerator {\n    type CustomMap = {\n        [Type in keyof Customizable]?: (tags: ICommentTag[]) => Customizable[Type] | undefined;\n    };\n    interface ICommentTag {\n        name: string;\n        value?: string;\n    }\n}\n'],["file:///node_modules/typia/lib/IValidation.d.ts","export type IValidation<T = unknown> = IValidation.ISuccess<T> | IValidation.IFailure;\nexport declare namespace IValidation {\n    interface ISuccess<T = unknown> {\n        success: true;\n        data: T;\n        errors: [];\n    }\n    interface IFailure {\n        success: false;\n        errors: IError[];\n    }\n    interface IError {\n        path: string;\n        expected: string;\n        value: any;\n    }\n}\n"],["file:///node_modules/typia/lib/metadata/ICommentTag.d.ts","export interface ICommentTag {\n    name: string;\n    value?: string;\n}\n"],["file:///node_modules/typia/lib/metadata/IJsDocTagInfo.d.ts","export interface IJsDocTagInfo {\n    name: string;\n    text?: IJsDocTagInfo.IText[];\n}\nexport declare namespace IJsDocTagInfo {\n    interface IText {\n        text: string;\n        kind: string;\n    }\n}\n"],["file:///node_modules/typia/lib/metadata/IMetadata.d.ts",'import { Atomic } from "../typings/Atomic";\nimport { IMetadataConstant } from "./IMetadataConstant";\nimport { IMetadataEntry } from "./IMetadataEntry";\nimport { IMetadataResolved } from "./IMetadataResolved";\nexport interface IMetadata {\n    any: boolean;\n    required: boolean;\n    optional: boolean;\n    nullable: boolean;\n    functional: boolean;\n    atomics: Atomic.Literal[];\n    constants: IMetadataConstant[];\n    templates: IMetadata[][];\n    resolved: IMetadataResolved | null;\n    rest: IMetadata | null;\n    arrays: string[];\n    tuples: string[];\n    objects: string[];\n    aliases: string[];\n    natives: string[];\n    sets: IMetadata[];\n    maps: IMetadataEntry[];\n}\n'],["file:///node_modules/typia/lib/metadata/IMetadataAlias.d.ts",'import { IJsDocTagInfo } from "./IJsDocTagInfo";\nimport { IMetadata } from "./IMetadata";\nexport interface IMetadataAlias {\n    name: string;\n    value: IMetadata;\n    description: string | null;\n    jsDocTags: IJsDocTagInfo[];\n    recursive: boolean;\n    nullables: boolean[];\n}\n'],["file:///node_modules/typia/lib/metadata/IMetadataApplication.d.ts",'import { IMetadata } from "./IMetadata";\nimport { IMetadataCollection } from "./IMetadataCollection";\nexport interface IMetadataApplication {\n    metadatas: IMetadata[];\n    collection: IMetadataCollection;\n}\n'],["file:///node_modules/typia/lib/metadata/IMetadataArray.d.ts",'import { IMetadata } from "./IMetadata";\nexport interface IMetadataArray {\n    name: string;\n    value: IMetadata;\n    nullables: boolean[];\n    recursive: boolean;\n    index: number | null;\n}\n'],["file:///node_modules/typia/lib/metadata/IMetadataCollection.d.ts",'import { IMetadataAlias } from "./IMetadataAlias";\nimport { IMetadataArray } from "./IMetadataArray";\nimport { IMetadataObject } from "./IMetadataObject";\nimport { IMetadataTuple } from "./IMetadataTuple";\nexport interface IMetadataCollection {\n    objects: IMetadataObject[];\n    aliases: IMetadataAlias[];\n    arrays: IMetadataArray[];\n    tuples: IMetadataTuple[];\n}\n'],["file:///node_modules/typia/lib/metadata/IMetadataConstant.d.ts",'import { Atomic } from "../typings/Atomic";\nexport type IMetadataConstant = IMetadataConstant.IBase<"boolean", boolean> | IMetadataConstant.IBase<"number", number> | IMetadataConstant.IBase<"string", string> | IMetadataConstant.IBase<"bigint", bigint>;\nexport declare namespace IMetadataConstant {\n    interface IBase<Type extends Atomic.Literal, Value extends Atomic.Type> {\n        type: Type;\n        values: Value[];\n    }\n}\n'],["file:///node_modules/typia/lib/metadata/IMetadataDictionary.d.ts","export {};\n"],["file:///node_modules/typia/lib/metadata/IMetadataEntry.d.ts",'import { IMetadata } from "./IMetadata";\nexport interface IMetadataEntry {\n    key: IMetadata;\n    value: IMetadata;\n}\n'],["file:///node_modules/typia/lib/metadata/IMetadataObject.d.ts",'import { IJsDocTagInfo } from "./IJsDocTagInfo";\nimport { IMetadataProperty } from "./IMetadataProperty";\nexport interface IMetadataObject {\n    name: string;\n    properties: IMetadataProperty[];\n    description?: string;\n    jsDocTags: IJsDocTagInfo[];\n    index: number;\n    recursive: boolean;\n    nullables: boolean[];\n}\n'],["file:///node_modules/typia/lib/metadata/IMetadataProperty.d.ts",'import { IJsDocTagInfo } from "./IJsDocTagInfo";\nimport { IMetadata } from "./IMetadata";\nimport { IMetadataTag } from "./IMetadataTag";\nexport interface IMetadataProperty {\n    key: IMetadata;\n    value: IMetadata;\n    description: string | null;\n    tags: IMetadataTag[];\n    jsDocTags: IJsDocTagInfo[];\n}\n'],["file:///node_modules/typia/lib/metadata/IMetadataResolved.d.ts",'import { IMetadata } from "./IMetadata";\nexport interface IMetadataResolved {\n    original: IMetadata;\n    returns: IMetadata;\n}\n'],["file:///node_modules/typia/lib/metadata/IMetadataTag.d.ts",'export type IMetadataTag = IMetadataTag.IType | IMetadataTag.IMinimum | IMetadataTag.IMaximum | IMetadataTag.IExclusiveMinimum | IMetadataTag.IExclusiveMaximum | IMetadataTag.IMultipleOf | IMetadataTag.IStep | IMetadataTag.IFormat | IMetadataTag.IPattern | IMetadataTag.ILength | IMetadataTag.IMinLength | IMetadataTag.IMaxLength | IMetadataTag.IItems | IMetadataTag.IMinItems | IMetadataTag.IMaxItems;\nexport declare namespace IMetadataTag {\n    interface IType {\n        kind: "type";\n        value: "int" | "uint";\n    }\n    interface IMinimum {\n        kind: "minimum";\n        value: number;\n    }\n    interface IMaximum {\n        kind: "maximum";\n        value: number;\n    }\n    interface IExclusiveMinimum {\n        kind: "exclusiveMinimum";\n        value: number;\n    }\n    interface IExclusiveMaximum {\n        kind: "exclusiveMaximum";\n        value: number;\n    }\n    interface IMultipleOf {\n        kind: "multipleOf";\n        value: number;\n    }\n    interface IStep {\n        kind: "step";\n        value: number;\n    }\n    interface IFormat {\n        kind: "format";\n        value: "uuid" | "email" | "url" | "ipv4" | "ipv6" | "date" | "datetime";\n    }\n    interface IPattern {\n        kind: "pattern";\n        value: string;\n    }\n    interface ILength {\n        kind: "length";\n        value: number;\n    }\n    interface IMinLength {\n        kind: "minLength";\n        value: number;\n    }\n    interface IMaxLength {\n        kind: "maxLength";\n        value: number;\n    }\n    interface IItems {\n        kind: "items";\n        value: number;\n    }\n    interface IMinItems {\n        kind: "minItems";\n        value: number;\n    }\n    interface IMaxItems {\n        kind: "maxItems";\n        value: number;\n    }\n}\n'],["file:///node_modules/typia/lib/metadata/IMetadataTuple.d.ts",'import { IMetadata } from "./IMetadata";\nexport interface IMetadataTuple {\n    name: string;\n    elements: IMetadata[];\n    index: number | null;\n    recursive: boolean;\n    nullables: boolean[];\n}\n'],["file:///node_modules/typia/lib/metadata/Metadata.d.ts",'import { Atomic } from "../typings/Atomic";\nimport { IMetadata } from "./IMetadata";\nimport { IMetadataCollection } from "./IMetadataCollection";\nimport { MetadataAlias } from "./MetadataAlias";\nimport { MetadataArray } from "./MetadataArray";\nimport { MetadataConstant } from "./MetadataConstant";\nimport { MetadataObject } from "./MetadataObject";\nimport { MetadataResolved } from "./MetadataResolved";\nimport { MetadataTuple } from "./MetadataTuple";\nexport declare class Metadata {\n    any: boolean;\n    required: boolean;\n    optional: boolean;\n    nullable: boolean;\n    functional: boolean;\n    resolved: MetadataResolved | null;\n    atomics: Atomic.Literal[];\n    constants: MetadataConstant[];\n    templates: Metadata[][];\n    rest: Metadata | null;\n    aliases: MetadataAlias[];\n    arrays: MetadataArray[];\n    tuples: MetadataTuple[];\n    objects: MetadataObject[];\n    natives: string[];\n    sets: Metadata[];\n    maps: Metadata.Entry[];\n    /**\n     * @hidden\n     */\n    private constructor();\n    toJSON(): IMetadata;\n    static from(meta: IMetadata, collection: IMetadataCollection): Metadata;\n    getName(): string;\n    empty(): boolean;\n    size(): number;\n    bucket(): number;\n    isConstant(): boolean;\n}\nexport declare namespace Metadata {\n    const intersects: (x: Metadata, y: Metadata) => boolean;\n    const covers: (x: Metadata, y: Metadata, level?: number) => boolean;\n}\nexport declare namespace Metadata {\n    interface Entry {\n        key: Metadata;\n        value: Metadata;\n    }\n}\n'],["file:///node_modules/typia/lib/metadata/MetadataAlias.d.ts",'import { IJsDocTagInfo } from "./IJsDocTagInfo";\nimport { IMetadataAlias } from "./IMetadataAlias";\nimport { Metadata } from "./Metadata";\nexport declare class MetadataAlias {\n    readonly name: string;\n    readonly value: Metadata;\n    readonly description: string | null;\n    readonly jsDocTags: IJsDocTagInfo[];\n    readonly recursive: boolean;\n    readonly nullables: boolean[];\n    /**\n     * @hidden\n     */\n    private constructor();\n    toJSON(): IMetadataAlias;\n}\n'],["file:///node_modules/typia/lib/metadata/MetadataArray.d.ts",'import { IMetadataArray } from "./IMetadataArray";\nimport { Metadata } from "./Metadata";\nexport declare class MetadataArray {\n    readonly name: string;\n    readonly value: Metadata;\n    readonly nullables: boolean[];\n    readonly recursive: boolean;\n    readonly index: number | null;\n    /**\n     * @hidden\n     */\n    private constructor();\n    toJSON(): IMetadataArray;\n}\n'],["file:///node_modules/typia/lib/metadata/MetadataConstant.d.ts",'import { IMetadataConstant } from "./IMetadataConstant";\nexport type MetadataConstant = IMetadataConstant;\n'],["file:///node_modules/typia/lib/metadata/MetadataObject.d.ts",'import { IJsDocTagInfo } from "./IJsDocTagInfo";\nimport { IMetadataObject } from "./IMetadataObject";\nimport { MetadataProperty } from "./MetadataProperty";\nexport declare class MetadataObject {\n    readonly name: string;\n    readonly properties: Array<MetadataProperty>;\n    readonly description: string | undefined;\n    readonly jsDocTags: IJsDocTagInfo[];\n    readonly index: number;\n    validated: boolean;\n    recursive: boolean;\n    nullables: boolean[];\n    /**\n     * @hidden\n     */\n    private constructor();\n    toJSON(): IMetadataObject;\n}\n'],["file:///node_modules/typia/lib/metadata/MetadataProperty.d.ts",'import { IJsDocTagInfo } from "./IJsDocTagInfo";\nimport { IMetadataProperty } from "./IMetadataProperty";\nimport { IMetadataTag } from "./IMetadataTag";\nimport { Metadata } from "./Metadata";\nexport declare class MetadataProperty {\n    readonly key: Metadata;\n    readonly value: Metadata;\n    readonly description: string | null;\n    readonly tags: IMetadataTag[];\n    readonly jsDocTags: IJsDocTagInfo[];\n    /**\n     * @hidden\n     */\n    private constructor();\n    toJSON(): IMetadataProperty;\n}\n'],["file:///node_modules/typia/lib/metadata/MetadataResolved.d.ts",'import { IMetadataResolved } from "./IMetadataResolved";\nimport { Metadata } from "./Metadata";\nexport declare class MetadataResolved {\n    readonly original: Metadata;\n    readonly returns: Metadata;\n    /**\n     * @hidden\n     */\n    private constructor();\n    getName(): string;\n    toJSON(): IMetadataResolved;\n}\n'],["file:///node_modules/typia/lib/metadata/MetadataTuple.d.ts",'import { ClassProperties } from "../typings/ClassProperties";\nimport { IMetadataTuple } from "./IMetadataTuple";\nimport { Metadata } from "./Metadata";\nexport declare class MetadataTuple {\n    readonly name: string;\n    readonly elements: Metadata[];\n    readonly index: number | null;\n    readonly recursive: boolean;\n    readonly nullables: boolean[];\n    static create(props: ClassProperties<MetadataTuple>): MetadataTuple;\n    toJSON(): IMetadataTuple;\n}\n'],["file:///node_modules/typia/lib/module.d.ts",'import { IJsonApplication } from "./schemas/IJsonApplication";\nimport { Atomic } from "./typings/Atomic";\nimport { CustomValidatorMap } from "./CustomValidatorMap";\nimport { IRandomGenerator } from "./IRandomGenerator";\nimport { IValidation } from "./IValidation";\nimport { Primitive } from "./Primitive";\nexport * from "./schemas/IJsonApplication";\nexport * from "./schemas/IJsonComponents";\nexport * from "./schemas/IJsonSchema";\nexport * from "./IRandomGenerator";\nexport * from "./IValidation";\nexport * from "./Primitive";\nexport * from "./TypeGuardError";\n/**\n * Asserts a value type.\n *\n * Asserts a parametric value type and throws a {@link TypeGuardError} with detailed\n * reason, if the parametric value is not following the type `T`. Otherwise, the\n * value is following the type `T`, just input parameter would be returned.\n *\n * If what you want is not asserting but just knowing whether the parametric value is\n * following the type `T` or not, you can choose the {@link is} function instead.\n * Otherwise you want to know all the errors, {@link validate} is the way to go.\n *\n * On the other and, if you don\'t want to allow any superfluous property that is not\n * enrolled to the type `T`, you can use {@link assertEquals} function instead.\n *\n * @template T Type of the input value\n * @param input A value to be asserted\n * @returns Parametric input value\n * @throws A {@link TypeGuardError} instance with detailed reason\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function assert<T>(input: T): T;\n/**\n * Asserts a value type.\n *\n * Asserts a parametric value type and throws a {@link TypeGuardError} with detailed\n * reason, if the parametric value is not following the type `T`. Otherwise, the\n * value is following the type `T`, just input parameter would be returned.\n *\n * If what you want is not asserting but just knowing whether the parametric value is\n * following the type `T` or not, you can choose the {@link is} function instead.\n * Otherwise, you want to know all the errors, {@link validate} is the way to go.\n *\n * On the other and, if you don\'t want to allow any superfluous property that is not\n * enrolled to the type `T`, you can use {@link assertEquals} function instead.\n *\n * @template T Type of the input value\n * @param input A value to be asserted\n * @returns Parametric input value casted as `T`\n * @throws A {@link TypeGuardError} instance with detailed reason\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function assert<T>(input: unknown): T;\n/**\n * Asserts a value type.\n *\n * Duplicated function of {@link assert} for `typescript-is` users.\n *\n * @template T Type of the input value\n * @param input A value to be asserted\n * @returns Parametric input value\n * @throws A {@link TypeGuardError} instance with detailed reason\n *\n * @author Jeongho Nam - https://github.com/samchon\n * @deprecated\n */\nexport declare function assertType<T>(input: T): T;\n/**\n * Asserts a value type.\n *\n * Duplicated function of {@link assert} for `typescript-is` users.\n *\n * @template T Type of the input value\n * @param input A value to be asserted\n * @returns Parametric input value\n * @throws A {@link TypeGuardError} instance with detailed reason\n *\n * @author Jeongho Nam - https://github.com/samchon\n * @deprecated\n */\nexport declare function assertType<T>(input: unknown): T;\n/**\n * Tests a value type.\n *\n * Tests a parametric value type and returns whether it\'s following the type `T` or not.\n * If the parametric value is matched with the type `T`, `true` value would be returned.\n * Otherwise, the parametric value is not following the type `T`, `false` value would be\n * returned.\n *\n * If what you want is not just knowing whether the parametric value is following the\n * type `T` or not, but throwing an exception with detailed reason, you can choose\n * {@link assert} function instead. Also, if you want to know all the errors with\n * detailed reasons, {@link validate} function would be useful.\n *\n * On the other and, if you don\'t want to allow any superfluous property that is not\n * enrolled to the type `T`, you can use {@link equals} function instead.\n *\n * @template T Type of the input value\n * @param input A value to be tested\n * @returns Whether the parametric value is following the type `T` or not\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function is<T>(input: T): input is T;\n/**\n * Tests a value type.\n *\n * Tests a parametric value type and returns whether it\'s following the type `T` or not.\n * If the parametric value is matched with the type `T`, `true` value would be returned.\n * Otherwise, the parametric value is not following the type `T`, `false` value would be\n * returned.\n *\n * If what you want is not just knowing whether the parametric value is following the\n * type `T` or not, but throwing an exception with detailed reason, you can choose\n * {@link assert} function instead. Also, if you want to know all the errors with\n * detailed reasons, {@link validate} function would be useful.\n *\n * On the other and, if you don\'t want to allow any superfluous property that is not\n * enrolled to the type `T`, you can use {@link equals} function instead.\n *\n * @template T Type of the input value\n * @param input A value to be tested\n * @returns Whether the parametric value is following the type `T` or not\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function is<T>(input: unknown): input is T;\n/**\n * Validates a value type.\n *\n * Validates a parametric value type and archives all the type errors into an\n * {@link IValidation.errors} array, if the parametric value is not following the\n * type `T`. Of course, if the parametric value is following the type `T`, the\n * {@link IValidation.errors} array would be empty and {@link IValidation.success}\n * would have the `true` value.\n *\n * If what you want is not finding all the error, but asserting the parametric value\n * type with exception throwing, you can choose {@link assert} function instead.\n * Otherwise, you just want to know whether the parametric value is matched with the\n * type `T`, {@link is} function is the way to go.\n *\n * On the other and, if you don\'t want to allow any superfluous property that is not\n * enrolled to the type `T`, you can use {@link validateEquals} function instead.\n *\n * @template Type of the input value\n * @param input A value to be validated\n * @returns Validation result\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function validate<T>(input: T): IValidation<T>;\n/**\n * Validates a value type.\n *\n * Validates a parametric value type and archives all the type errors into an\n * {@link IValidation.errors} array, if the parametric value is not following the\n * type `T`. Of course, if the parametric value is following the type `T`, the\n * {@link IValidation.errors} array would be empty and {@link IValidation.success}\n * would have the `true` value.\n *\n * If what you want is not finding all the error, but asserting the parametric value\n * type with exception throwing, you can choose {@link assert} function instead.\n * Otherwise, you just want to know whether the parametric value is matched with the\n * type `T`, {@link is} function is the way to go.\n *\n * On the other and, if you don\'t want to allow any superfluous property that is not\n * enrolled to the type `T`, you can use {@link validateEquals} function instead.\n *\n * @template Type of the input value\n * @param input A value to be validated\n * @returns Validation result\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function validate<T>(input: unknown): IValidation<T>;\n/**\n * Asserts equality between a value and its type.\n *\n * Asserts a parametric value type and throws a {@link TypeGuardError} with detailed\n * reason, if the parametric value is not following the type `T` or some superfluous\n * property that is not listed on the type `T` has been found. Otherwise, the value is\n * following the type `T` without any superfluous property, just input parameter would\n * be returned.\n *\n * If what you want is not asserting but just knowing whether the parametric value is\n * following the type `T` or not, you can choose the {@link equals} function instead.\n * Otherwise, you want to know all the errors, {@link validateEquals} is the way to go.\n *\n * On the other hand, if you want to allow superfluous property that is not enrolled\n * to the type `T`, you can use {@link assert} function instead.\n *\n * @template T Type of the input value\n * @param input A value to be asserted\n * @returns Parametric input value\n * @throws A {@link TypeGuardError} instance with detailed reason\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function assertEquals<T>(input: T): T;\n/**\n * Asserts equality between a value and its type.\n *\n * Asserts a parametric value type and throws a {@link TypeGuardError} with detailed\n * reason, if the parametric value is not following the type `T` or some superfluous\n * property that is not listed on the type `T` has been found. Otherwise, the value is\n * following the type `T` without any superfluous property, just input parameter would\n * be returned.\n *\n * If what you want is not asserting but just knowing whether the parametric value is\n * following the type `T` or not, you can choose the {@link equals} function instead.\n * Otherwise, you want to know all the errors, {@link validateEquals} is the way to go.\n *\n * On the other hand, if you want to allow superfluous property that is not enrolled\n * to the type `T`, you can use {@link assert} function instead.\n *\n * @template T Type of the input value\n * @param input A value to be asserted\n * @returns Parametric input value casted as `T`\n * @throws A {@link TypeGuardError} instance with detailed reason\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function assertEquals<T>(input: unknown): T;\n/**\n * Tests equality between a value and its type.\n *\n * Tests a parametric value type and returns whether it\'s equivalent to the type `T`\n * or not. If the parametric value is matched with the type `T` and there\'s not any\n * superfluous property that is not listed on the type `T`, `true` value would be\n * returned. Otherwise, the parametric value is not following the type `T` or some\n * superfluous property exists, `false` value would be returned.\n *\n * If what you want is not just knowing whether the parametric value is following the\n * type `T` or not, but throwing an exception with detailed reason, you can choose\n * {@link assertEquals} function instead. Also, if you want to know all the errors with\n * detailed reasons, {@link validateEquals} function would be useful.\n *\n * On the other hand, if you want to allow superfluous property that is not enrolled\n * to the type `T`, you can use {@link is} function instead.\n *\n * @template T Type of the input value\n * @param input A value to be tested\n * @returns Whether the parametric value is equivalent to the type `T` or not\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function equals<T>(input: T): input is T;\n/**\n * Tests equality between a value and its type.\n *\n * Tests a parametric value type and returns whether it\'s equivalent to the type `T`\n * or not. If the parametric value is matched with the type `T` and there\'s not any\n * superfluous property that is not listed on the type `T`, `true` value would be\n * returned. Otherwise, the parametric value is not following the type `T` or some\n * superfluous property exists, `false` value would be returned.\n *\n * If what you want is not just knowing whether the parametric value is following the\n * type `T` or not, but throwing an exception with detailed reason, you can choose\n * {@link assertEquals} function instead. Also, if you want to know all the errors with\n * detailed reasons, {@link validateEquals} function would be useful.\n *\n * On the other hand, if you want to allow superfluous property that is not enrolled\n * to the type `T`, you can use {@link is} function instead.\n *\n * @template T Type of the input value\n * @param input A value to be tested\n * @returns Whether the parametric value is equivalent to the type `T` or not\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function equals<T>(input: unknown): input is T;\n/**\n * Validates equality between a value and its type.\n *\n * Validates a parametric value type and archives all the type errors into an\n * {@link IValidation.errors} array, if the parametric value is not following the\n * type `T` or some superfluous property that is not listed on the type `T` has been\n * found. Of course, if the parametric value is following the type `T` and no\n * superfluous property exists, the {@link IValidation.errors} array would be empty\n * and {@link IValidation.success} would have the `true` value.\n *\n * If what you want is not finding all the error, but asserting the parametric value\n * type with exception throwing, you can choose {@link assert} function instead.\n * Otherwise, you just want to know whether the parametric value is matched with the\n * type `T`, {@link is} function is the way to go.\n *\n * On the other and, if you don\'t want to allow any superfluous property that is not\n * enrolled to the type `T`, you can use {@link validateEquals} function instead.\n *\n * @template Type of the input value\n * @param input A value to be validated\n * @returns Validation result\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function validateEquals<T>(input: T): IValidation<T>;\n/**\n * Validates equality between a value and its type.\n *\n * Validates a parametric value type and archives all the type errors into an\n * {@link IValidation.errors} array, if the parametric value is not following the\n * type `T` or some superfluous property that is not listed on the type `T` has been\n * found. Of course, if the parametric value is following the type `T` and no\n * superfluous property exists, the {@link IValidation.errors} array would be empty\n * and {@link IValidation.success} would have the `true` value.\n *\n * If what you want is not finding all the error, but asserting the parametric value\n * type with exception throwing, you can choose {@link assert} function instead.\n * Otherwise, you just want to know whether the parametric value is matched with the\n * type `T`, {@link is} function is the way to go.\n *\n * On the other and, if you don\'t want to allow any superfluous property that is not\n * enrolled to the type `T`, you can use {@link validateEquals} function instead.\n *\n * @template Type of the input value\n * @param input A value to be validated\n * @returns Validation result\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function validateEquals<T>(input: unknown): IValidation<T>;\n/**\n * Custom validators.\n *\n * If you want to add a custom validation logic utilizing comment tags,\n * add a closure function with its tag and type name. Below example code\n * would helpful to understand how to use this instance.\n *\n * ```ts\n * typia.customValidators.insert("powerOf")("number")(\n *     (text: string) => {\n *         const denominator: number = Math.log(Number(text));\n *         return (value: number) => {\n *             value = Math.log(value) / denominator;\n *             return value === Math.floor(value);\n *         };\n *     }\n * );\n * typia.customValidators.insert("dollar")("string")(\n *     () => (value: string) => value.startsWith("$"),\n * );\n *\n * interface TagCustom {\n *    /**\n *     * @powerOf 10\n *     */\n *    powerOf: number;\n *\n *    /**\n *     * @dollar\n *     */\n *    dollar: string;\n * }\n * ```\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare const customValidators: CustomValidatorMap;\n/**\n * > You must configure the generic argument `T`.\n *\n * JSON Schema Application.\n *\n * Creates a JSON schema application which contains both main JSON schemas and components.\n * Note that, all of the object types are stored in the {@link IJsonApplication.components}\n * property for the `$ref` referencing.\n *\n * Also, `typia.application()` has additional generic arguments, *Purpose*.\n * As JSON schema definitions used by `swagger` and `ajv` are different a little bit,\n * you should configure the *Purpose* appropriately.\n *\n * For an example, `ajv` has an extra property "$recursiveRef" that are not exists\n * in the standard JSON schema definition spec. Otherwise, `swagger` can\'t identify\n * the tuple definition.\n *\n * @template Types Tuple of target types\n * @template Purpose Purpose of the JSON schema`\n * @return JSON schema application\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function application(): never;\n/**\n * JSON Schema Application.\n *\n * Creates a JSON schema application which contains both main JSON schemas and components.\n * Note that, all of the object types are stored in the {@link IJsonApplication.components}\n * property for the `$ref` referencing.\n *\n * Also, `typia.application()` has additional generic arguments, *Purpose*.\n * As JSON schema definitions used by `swagger` and `ajv` are different a little bit,\n * you should configure the *Purpose* appropriately.\n *\n * For an example, `ajv` has an extra property "$recursiveRef" that are not exists\n * in the standard JSON schema definition spec. Otherwise, `swagger` can\'t identify\n * the tuple definition.\n *\n * @template Types Tuple of target types\n * @template Purpose Purpose of the JSON schema\n * @return JSON schema application\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function application<Types extends unknown[], Purpose extends "ajv" | "swagger" = "swagger">(): IJsonApplication;\n/**\n * > You must configure the generic argument `T`.\n *\n * Safe `JSON.parse()` function with type assertion.\n *\n * `typia.assertParse()` is a combination function of `JSON.parse()` and {@link assert}.\n * Therefore, it convers a JSON (JavaScript Object Notation) string to a `T` typed\n * instance with type assertion.\n *\n * In such reason, when parsed JSON string value is not matched with the type `T`, it\n * throws {@link TypeGuardError}. Otherwise, there\'s no problem on the parsed value,\n * the parsed value would be returned.\n *\n * @template T Expected type of parsed value\n * @param input JSON string\n * @returns Parsed value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function assertParse(input: string): never;\n/**\n * Safe `JSON.parse()` function with type assertion.\n *\n * `typia.assertParse()` is a combination function of `JSON.parse()` and {@link assert}.\n * Therefore, it convers a JSON (JavaScript Object Notation) string to a `T` typed\n * instance with type assertion.\n *\n * In such reason, when parsed JSON string value is not matched with the type `T`, it\n * throws {@link TypeGuardError}. Otherwise, there\'s no problem on the parsed value,\n * the parsed value would be returned.\n *\n * @template T Expected type of parsed value\n * @param input JSON string\n * @returns Parsed value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function assertParse<T>(input: string): Primitive<T>;\n/**\n * > You must configure the generic argument `T`.\n *\n * Safe `JSON.parse()` function with type checking.\n *\n * `typia.isParse()` is a combination function of `JSON.parse()` and {@link is}.\n * Therefore, it convers a JSON (JavaScript Object Notation) string to a `T` typed\n * instance with type checking.\n *\n * In such reason, when parsed JSON string value is not matched with the type `T`, it\n * returns `null` value. Otherwise, there\'s no problem on the parsed value, the parsed\n * value would be returned.\n *\n * @template T Expected type of parsed value\n * @param input JSON string\n * @returns Parsed value when exact type, otherwise `null`\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function isParse(input: string): never;\n/**\n * Safe `JSON.parse()` function with type checking.\n *\n * `typia.isParse()` is a combination function of `JSON.parse()` and {@link is}.\n * Therefore, it convers a JSON (JavaScript Object Notation) string to a `T` typed\n * instance with type checking.\n *\n * In such reason, when parsed JSON string value is not matched with the type `T`, it\n * returns `null` value. Otherwise, there\'s no problem on the parsed value, the parsed\n * value would be returned.\n *\n * @template T Expected type of parsed value\n * @param input JSON string\n * @returns Parsed value when exact type, otherwise `null`\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function isParse<T>(input: string): Primitive<T> | null;\n/**\n * > You must configure the generic argument `T`.\n *\n * Safe `JSON.parse()` function with detailed type validation.\n *\n * `typia.validateParse()` is a combination function of `JSON.parse()` and\n * {@link validate}. Therefore, it convers a JSON (JavaScript Object Notation) string\n * to a `T` typed instance with detailed type validation.\n *\n * In such reason, when parsed JSON string value is not matched with the type `T`, it\n * returns {@link IValidation.IFailure} value with detailed error reasons. Otherwise,\n * there\'s no problem on the parsed value, the parsed value would be stored in `data`\n * property of the output {@link IValidation.ISuccess} instance.\n *\n * @template T Expected type of parsed value\n * @param input JSON string\n * @returns Validation result with JSON parsed value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function validateParse(input: string): never;\n/**\n * Safe `JSON.parse()` function with detailed type validation.\n *\n * `typia.validateParse()` is a combination function of `JSON.parse()` and\n * {@link validate}. Therefore, it convers a JSON (JavaScript Object Notation) string\n * to a `T` typed instance with detailed type validation.\n *\n * In such reason, when parsed JSON string value is not matched with the type `T`, it\n * returns {@link IValidation.IFailure} value with detailed error reasons. Otherwise,\n * there\'s no problem on the parsed value, the parsed value would be stored in `data`\n * property of the output {@link IValidation.ISuccess} instance.\n *\n * @template T Expected type of parsed value\n * @param input JSON string\n * @returns Validation result with JSON parsed value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function validateParse<T>(input: string): IValidation<Primitive<T>>;\n/**\n * 8x faster `JSON.stringify()` function.\n *\n * Converts an input value to a JSON (JavaScript Object Notation) string, about 8x faster\n * than the native `JSON.stringify()` function. The 5x faster principle is because\n * it writes an optimized JSON conversion plan, only for the type `T`.\n *\n * For reference, this `typia.stringify()` does not validate the input value type.\n * It just believes that the input value is following the type `T`. Therefore, if you\n * can\'t ensure the input value type, it would be better to call one of below functions\n * instead.\n *\n *  - {@link assertStringify}\n *  - {@link isStringify}\n *  - {@link validateStringify}\n *\n * @template T Type of the input value\n * @param input A value to be converted\n * @return JSON string value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function stringify<T>(input: T): string;\n/**\n * 5x faster `JSON.stringify()` function with type assertion.\n *\n * `typia.assertStringify()` is a combination function of {@link assert} and\n * {@link stringify}. Therefore, it converts an input value to JSON (JavaScript Object\n * Notation) string, with type assertion.\n *\n * In such reason, when `input` value is not matched with the type `T`, it throws an\n * {@link TypeGuardError}. Otherwise, there\'s no problem on the `input` value, JSON\n * string would be returned.\n *\n * For reference, with type assertion, it is even 5x times faster than the native\n * `JSON.stringify()` function. So, just enjoy the safe and fast JSON conversion\n * with confidence.\n *\n * @template T Type of the input value\n * @param input A value to be asserted and converted\n * @return JSON string value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function assertStringify<T>(input: T): string;\n/**\n * 5x faster `JSON.stringify()` function with type assertion.\n *\n * `typia.assertStringify()` is a combination function of {@link assert} and\n * {@link stringify}. Therefore, it converts an input value to JSON (JavaScript Object\n * Notation) string, with type assertion.\n *\n * In such reason, when `input` value is not matched with the type `T`, it throws an\n * {@link TypeGuardError}. Otherwise, there\'s no problem on the `input` value, JSON\n * string would be returned.\n *\n * For reference, with type assertion, it is even 5x times faster than the native\n * `JSON.stringify()` function. So, just enjoy the safe and fast JSON conversion\n * with confidence.\n *\n * @template T Type of the input value\n * @param input A value to be asserted and converted\n * @return JSON string value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function assertStringify<T>(input: T): unknown;\n/**\n * 7x faster `JSON.stringify()` function with type checking.\n *\n * `typia.stringify()` is a combination function of {@link is} and\n * {@link stringify}. Therefore, it converts an input value to JSON\n * (JavaScript Object Notation) string, with type checking.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * `null` value. Otherwise, there\'s no problem on the `input` value, JSON string would\n * be returned.\n *\n * For reference, with type checking, it is even 7x times faster than the native\n * `JSON.stringify()` function. So, just enjoy the safe and fast JSON conversion\n * with confidence.\n *\n * @template T Type of the input value\n * @param input A value to be checked and converted\n * @return JSON string value when exact type, otherwise null\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function isStringify<T>(input: T): string | null;\n/**\n * 7x faster `JSON.stringify()` function with type checking.\n *\n * `typia.isStringify()` is a combination function of {@link is} and\n * {@link stringify}. Therefore, it converts an input value to JSON\n * (JavaScript Object Notation) string, with type checking.\n *f\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * `null` value. Otherwise, there\'s no problem on the `input` value, JSON string would\n * be returned.\n *\n * For reference, with type checking, it is even 7x times faster than the native\n * `JSON.stringify()` function. So, just enjoy the safe and fast JSON conversion\n * with confidence.\n *\n * @template T Type of the input value\n * @param input A value to be checked and converted\n * @return JSON string value when exact type, otherwise null\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function isStringify<T>(input: unknown): string | null;\n/**\n * 5x faster `JSON.stringify()` function with detailed type validation.\n *\n * `typia.validateStringify()` is a combination function of {@link validate} and\n * {@link stringify}. Therefore, it converts an input value to JSON (JavaScript Object\n * Notation) string, with detailed type validation.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * {@link IValidation.IFailure} value with detailed error reasons. Otherwise, there\'s no\n * problem on the `input` value, JSON string would be stored in `data` property of\n * the output {@link IValidation.ISuccess} instance.\n *\n * For reference, with detailed type validation, it is even 5x times faster than the\n * native `JSON.stringify()` function. So, just enjoy the safe and fast JSON conversion\n * with confidence.\n *\n * @template T Type of the input value\n * @param input A value to be checked and converted\n * @returns Validation result with JSON string value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function validateStringify<T>(input: T): IValidation<string>;\n/**\n * 5x faster `JSON.stringify()` function with detailed type validation.\n *\n * `typia.validateStringify()` is a combination function of {@link validate} and\n * {@link stringify}. Therefore, it converts an input value to JSON (JavaScript Object\n * Notation) string, with detailed type validation.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * {@link IValidation.IFailure} value with detailed error reasons. Otherwise, there\'s no\n * problem on the `input` value, JSON string would be stored in `data` property of\n * the output {@link IValidation.ISuccess} instance.\n *\n * For reference, with detailed type validation, it is even 5x times faster than the\n * native `JSON.stringify()` function. So, just enjoy the safe and fast JSON conversion\n * with confidence.\n *\n * @template T Type of the input value\n * @param input A value to be checked and converted\n * @returns Validation result with JSON string value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function validateStringify<T>(input: unknown): IValidation<string>;\n/**\n * > You must configure the generic argument `T`.\n *\n * Generate random data.\n *\n * Generates a random data following type the `T`.\n *\n * For reference, this `typia.random()` function generates only primitive type.\n * If there\'re some methods in the type `T` or its nested instances, those would\n * be ignored. Also, when the type `T` has a `toJSON()` method, its return type\n * would be generated instead.\n *\n * @template T Type of data to generate\n * @param generator Random data generator\n * @return Randomly generated data\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function random(generator?: Partial<IRandomGenerator>): never;\n/**\n * Generate random data.\n *\n * Generates a random data following type the `T`.\n *\n * For reference, this `typia.random()` function generates only primitive type.\n * If there\'re some methods in the type `T` or its nested instances, those would\n * be ignored. Also, when the type `T` has a `toJSON()` method, its return type\n * would be generated instead.\n *\n * @template T Type of data to generate\n * @param generator Random data generator\n * @return Randomly generated data\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function random<T>(generator?: Partial<IRandomGenerator>): Primitive<T>;\n/**\n * > You must configure the generic argument `T`.\n *\n * Union literal type to array.\n *\n * Converts a union literal type to an array of its members.\n *\n * ```typescript\n * literals<"A" | "B" | 1>; // ["A", "B", 1]\n * ```\n *\n * @template T Union literal type\n * @return Array of union literal type\'s members\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function literals(): never;\n/**\n * Union literal type to array.\n *\n * Converts a union literal type to an array of its members.\n *\n * ```typescript\n * literals<"A" | "B" | 1>; // ["A", "B", 1]\n * ```\n *\n * @template T Union literal type\n * @return Array of union literal type\'s members\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function literals<T extends Atomic.Type>(): T[];\n/**\n * Clone a data.\n *\n * Clones an instance following type `T`. If the target *input* value or its member\n * variable contains a class instance that is having a `toJSON()` method, its return\n * value would be cloned.\n *\n * For reference, this `typia.clone()` function does not validate the input value type.\n * It just believes that the input value is following the type `T`. Therefore, if you\n * can\'t ensure the input value type, it would be better to call {@link assertClone}\n * function instead.\n *\n * @template T Type of the input value\n * @param input A value to be cloned\n * @return Cloned data\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function clone<T>(input: T): Primitive<T>;\n/**\n * Clone a data with type assertion.\n *\n * Clones an instance following type `T`, with type assertion. If the target `input`\n * value or its member variable contains a class instance that is having a `toJSON()`\n * method, its return value would be cloned.\n *\n * In such reason, when `input` value is not matched with the type `T`, it throws an\n * {@link TypeGuardError}. Otherwise, there\'s no problem on the `input` value, cloned\n * data would be returned.\n *\n * @template T Type of the input value\n * @param input A value to be cloned\n * @return Cloned data\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function assertClone<T>(input: T): Primitive<T>;\n/**\n * Clone a data with type assertion.\n *\n * Clones an instance following type `T`, with type assertion. If the target `input`\n * value or its member variable contains a class instance that is having a `toJSON()`\n * method, its return value would be cloned.\n *\n * In such reason, when `input` value is not matched with the type `T`, it throws an\n * {@link TypeGuardError}. Otherwise, there\'s no problem on the `input` value, cloned\n * data would be returned.\n *\n * @template T Type of the input value\n * @param input A value to be cloned\n * @return Cloned data\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function assertClone<T>(input: unknown): Primitive<T>;\n/**\n * Clone a data with type checking.\n *\n * Clones an instance following type `T`, with type checking. If the target `input`\n * value or its member variable contains a class instance that is having a `toJSON()`\n * method, its return value would be cloned.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * `null` value instead. Otherwise, there\'s no problem on the `input` value, cloned\n * data would be returned.\n *\n * @template T Type of the input value\n * @param input A value to be cloned\n * @return Cloned data when exact type, otherwise null\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function isClone<T>(input: T): Primitive<T> | null;\n/**\n * Clone a data with type checking.\n *\n * Clones an instance following type `T`, with type checking. If the target `input`\n * value or its member variable contains a class instance that is having a `toJSON()`\n * method, its return value would be cloned.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * `null` value instead. Otherwise, there\'s no problem on the `input` value, cloned\n * data would be returned.\n *\n * @template T Type of the input value\n * @param input A value to be cloned\n * @return Cloned data when exact type, otherwise null\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function isClone<T>(input: unknown): Primitive<T> | null;\n/**\n * Clone a data with detailed type validation.\n *\n * Clones an instance following type `T`, with detailed type validation. If the target\n * `input` value or its member variable contains a class instance that is having a\n * `toJSON()` method, its return value would be cloned.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * {@link IValidation.Failure} value. Otherwise, there\'s no problem on the `input`\n * value, cloned data would be stored in `data` property of the output\n * {@link IValidation.Success} instance.\n *\n * @template T Type of the input value\n * @param input A value to be cloned\n * @returns Validation result with cloned value\n */\nexport declare function validateClone<T>(input: T): IValidation<Primitive<T>>;\n/**\n * Clone a data with detailed type validation.\n *\n * Clones an instance following type `T`, with detailed type validation. If the target\n * `input` value or its member variable contains a class instance that is having a\n * `toJSON()` method, its return value would be cloned.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * {@link IValidation.Failure} value. Otherwise, there\'s no problem on the `input`\n * value, cloned data would be stored in `data` property of the output\n * {@link IValidation.Success} instance.\n *\n * @template T Type of the input value\n * @param input A value to be cloned\n * @returns Validation result with cloned value\n */\nexport declare function validateClone<T>(input: unknown): IValidation<Primitive<T>>;\n/**\n * Prune, erase superfluous properties.\n *\n * Remove every superfluous properties from the `input` object, even including nested\n * objects. Note that, as every superfluous properties would be deleted, you never can\n * read those superfluous properties after calling this `prune()` function.\n *\n * For reference, this `typia.prune()` function does not validate the input value type.\n * It just believes that the input value is following the type `T`. Therefore, if you\n * can\'t ensure the input value type, it would better to call one of below functions\n * instead.\n *\n *   - {@link assertPrune}\n *   - {@link isPrune}\n *   - {@link validatePrune}\n *\n * @template T Type of the input value\n * @param input Target instance to prune\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function prune<T extends object>(input: T): void;\n/**\n * Prune, erase superfluous properties, with type assertion.\n *\n * `typia.assertPrune()` is a combination function of {@link assert} and {@link prune}.\n * Therefore, it removes every superfluous properties from the `input` object including\n * nested objects, with type assertion.\n *\n * In such reason, when `input` value is not matched with the type `T`, it throws an\n * {@link TypeGuardError}. Otherwise, there\'s no problem on the `input` value, its\n * every superfluous properties would be removed, including nested objects.\n *\n * @template T Type of the input value\n * @param input Target instance to assert and prune\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function assertPrune<T>(input: T): T;\n/**\n * Prune, erase superfluous properties, with type assertion.\n *\n * `typia.assertPrune()` is a combination function of {@link assert} and {@link prune}.\n * Therefore, it removes every superfluous properties from the `input` object including\n * nested objects, with type assertion.\n *\n * In such reason, when `input` value is not matched with the type `T`, it throws an\n * {@link TypeGuardError}. Otherwise, there\'s no problem on the `input` value, its\n * every superfluous properties would be removed, including nested objects.\n *\n * @template T Type of the input value\n * @param input Target instance to assert and prune\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function assertPrune<T>(input: unknown): T;\n/**\n * Prune, erase superfluous properties, with type checking.\n *\n * `typia.assertPrune()` is a combination function of {@link is} and {@link prune}.\n * Therefore, it removes every superfluous properties from the `input` object including\n * nested objects, with type checking.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * `false` value. Otherwise, there\'s no problem on the `input` value, it returns\n * `true` after removing every superfluous properties, including nested objects.\n *\n * @template T Type of the input value\n * @param input Target instance to check and prune\n * @returns Whether the parametric value is following the type `T` or not\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function isPrune<T>(input: T): input is T;\n/**\n * Prune, erase superfluous properties, with type checking.\n *\n * `typia.assertPrune()` is a combination function of {@link is} and {@link prune}.\n * Therefore, it removes every superfluous properties from the `input` object including\n * nested objects, with type checking.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * `false` value. Otherwise, there\'s no problem on the `input` value, it returns\n * `true` after removing every superfluous properties, including nested objects.\n *\n * @template T Type of the input value\n * @param input Target instance to check and prune\n * @returns Whether the parametric value is following the type `T` or not\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function isPrune<T>(input: unknown): input is T;\n/**\n * Prune, erase superfluous properties, with type validation.\n *\n * `typia.validatePrune()` is a combination function of {@link validate} and {@link prune}.\n * Therefore, it removes every superfluous properties from the `input` object including\n * nested objects, with type validation.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * {@link IValidation.IFailure} value with detailed error reasons. Otherwise, there\'s\n * no problem on the `input` value, it returns {@link IValidation.ISucess} value after\n * removing every superfluous properties, including nested objects.\n *\n * @template T Type of the input value\n * @param input Target instance to validate and prune\n * @returns Validation result\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function validatePrune<T>(input: T): IValidation<T>;\n/**\n * Prune, erase superfluous properties, with type validation.\n *\n * `typia.validatePrune()` is a combination function of {@link validate} and {@link prune}.\n * Therefore, it removes every superfluous properties from the `input` object including\n * nested objects, with type validation.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * {@link IValidation.IFailure} value with detailed error reasons. Otherwise, there\'s\n * no problem on the `input` value, it returns {@link IValidation.ISucess} value after\n * removing every superfluous properties, including nested objects.\n *\n * @template T Type of the input value\n * @param input Target instance to validate and prune\n * @returns Validation result\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function validatePrune<T>(input: unknown): IValidation<T>;\n/**\n * Creates a reusable {@link assert} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createAssert(): never;\n/**\n * Creates a reusable {@link assert} function.\n *\n * @template T Type of the input value\n * @returns A reusable `assert` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createAssert<T>(): (input: unknown) => T;\n/**\n * Creates a reusable {@link assertType} function.\n *\n * Duplicated function of {@link createAssert} for `typescript-is` users.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n * @deprecated\n */\nexport declare function createAssertType(): never;\n/**\n * Creates a reusable {@link assertType} function.\n *\n * Duplicated function of {@link createAssert} for `typescript-is` users.\n *\n * @template T Type of the input value\n * @returns A reusable `assert` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n * @deprecated\n */\nexport declare function createAssertType<T>(): (input: unknown) => T;\n/**\n * Creates a reusable {@link is} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createIs(): never;\n/**\n * Creates a reusable {@link is} function.\n *\n * @template T Type of the input value\n * @returns A reusable `is` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createIs<T>(): (input: unknown) => input is T;\n/**\n * Creates a reusable {@link validate} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createValidate(): never;\n/**\n * Creates a reusable {@link validate} function.\n *\n * @template T Type of the input value\n * @returns A reusable `validate` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createValidate<T>(): (input: unknown) => IValidation<T>;\n/**\n * Creates a reusable {@link assertEquals} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createAssertEquals(): never;\n/**\n * Creates a reusable {@link assertEquals} function.\n *\n * @template T Type of the input value\n * @returns A reusable `assertEquals` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createAssertEquals<T>(): (input: unknown) => T;\n/**\n * Creates a reusable {@link equals} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createEquals(): never;\n/**\n * Creates a reusable {@link equals} function.\n *\n * @template T Type of the input value\n * @returns A reusable `equals` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createEquals<T>(): (input: unknown) => input is T;\n/**\n * Creates a reusable {@link validateEquals} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createValidateEquals(): never;\n/**\n * Creates a reusable {@link validateEquals} function.\n *\n * @template T Type of the input value\n * @returns A reusable `validateEquals` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createValidateEquals<T>(): (input: unknown) => IValidation<T>;\n/**\n * Creates a reusable {@link isParse} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createIsParse(): never;\n/**\n * Creates a reusable {@link isParse} function.\n *\n * @template T Expected type of parsed value\n * @returns A reusable `isParse` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createIsParse<T>(): (input: string) => Primitive<T> | null;\n/**\n * Creates a reusable {@link assertParse} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createAssertParse(): never;\n/**\n * Creates a reusable {@link assertParse} function.\n *\n * @template T Expected type of parsed value\n * @returns A reusable `assertParse` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createAssertParse<T>(): (input: string) => Primitive<T>;\n/**\n * Creates a reusable {@link validateParse} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createValidateParse(): never;\n/**\n * Creates a reusable {@link validateParse} function.\n *\n * @template T Expected type of parsed value\n * @returns A reusable `validateParse` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createValidateParse<T>(): (input: string) => IValidation<Primitive<T>>;\n/**\n * Creates a reusable {@link stringify} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createStringify(): never;\n/**\n * Creates a reusable {@link stringify} function.\n *\n * @template T Type of the input value\n * @returns A reusable `stringify` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createStringify<T>(): (input: T) => string;\n/**\n * Creates a reusable {@link assertStringify} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createAssertStringify(): never;\n/**\n * Creates a reusable {@link assertStringify} function.\n *\n * @template T Type of the input value\n * @returns A reusable `assertStringify` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createAssertStringify<T>(): (input: unknown) => string;\n/**\n * Creates a reusable {@link isStringify} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createIsStringify(): never;\n/**\n * Creates a reusable {@link isStringify} function.\n *\n * @template T Type of the input value\n * @returns A reusable `isStringify` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createIsStringify<T>(): (input: unknown) => string | null;\n/**\n * Creates a reusable {@link validateStringify} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createValidateStringify(): never;\n/**\n * Creates a reusable {@link validateStringify} function.\n *\n * @template T Type of the input value\n * @returns A reusable `validateStringify` function\n\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createValidateStringify<T>(): (input: unknown) => IValidation<string>;\n/**\n * Creates a reusable {@link random} function.\n *\n * @danger You have to specify the generic argument `T`\n * @param generator Random data generator\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createRandom(generator?: Partial<IRandomGenerator>): never;\n/**\n * Creates a resuable {@link random} function.\n *\n * @template T Type of the input value\n * @param generator Random data generator\n * @returns A reusable `random` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createRandom<T>(generator?: Partial<IRandomGenerator>): () => Primitive<T>;\n/**\n * Creates a reusable {@link clone} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createClone(): never;\n/**\n * Creates a resuable {@link clone} function.\n *\n * @template T Type of the input value\n * @returns A reusable `clone` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createClone<T>(): (input: T) => Primitive<T>;\n/**\n * Creates a reusable {@link assertClone} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createAssertClone(): never;\n/**\n * Creates a resuable {@link assertClone} function.\n *\n * @template T Type of the input value\n * @returns A reusable `clone` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createAssertClone<T>(): (input: unknown) => Primitive<T>;\n/**\n * Creates a reusable {@link isClone} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createIsClone(): never;\n/**\n * Creates a resuable {@link isClone} function.\n *\n * @template T Type of the input value\n * @returns A reusable `clone` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createIsClone<T>(): (input: unknown) => Primitive<T> | null;\n/**\n * Creates a reusable {@link validateClone} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createValidateClone(): never;\n/**\n * Creates a resuable {@link validateClone} function.\n *\n * @template T Type of the input value\n * @returns A reusable `clone` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createValidateClone<T>(): (input: unknown) => IValidation<Primitive<T>>;\n/**\n * Creates a reusable {@link prune} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createPrune(): never;\n/**\n * Creates a resuable {@link prune} function.\n *\n * @template T Type of the input value\n * @returns A reusable `prune` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createPrune<T extends object>(): (input: T) => void;\n/**\n * Creates a reusable {@link assertPrune} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createAssertPrune(): never;\n/**\n * Creates a resuable {@link assertPrune} function.\n *\n * @template T Type of the input value\n * @returns A reusable `isPrune` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createAssertPrune<T extends object>(): (input: T) => T;\n/**\n * Creates a reusable {@link isPrune} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createIsPrune(): never;\n/**\n * Creates a resuable {@link isPrune} function.\n *\n * @template T Type of the input value\n * @returns A reusable `isPrune` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createIsPrune<T extends object>(): (input: T) => input is T;\n/**\n * Creates a reusable {@link validatePrune} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createValidatePrune(): never;\n/**\n * Creates a resuable {@link validatePrune} function.\n *\n * @template T Type of the input value\n * @returns A reusable `validatePrune` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport declare function createValidatePrune<T extends object>(): (input: T) => IValidation<T>;\n'],["file:///node_modules/typia/lib/Primitive.d.ts",'/**\n * Primitive type.\n *\n * `Primitive` is a type of TMP (Type Meta Programming) type who converts its argument as a\n * primitive type.\n *\n * If the target argument is a built-in class who returns its origin primitive type through\n * the `valueOf()` method like the `String` or `Number`, its return type would be the\n * `string` or `number`.\n *\n * Otherwise, the target argument is a type of custom class, all of its custom method would\n * be erased and its prototype would be changed to the primitive `object`. Therefore, return\n * type of the TMP type finally be the primitive object.\n *\n * In addition, if the target argument is a type of custom class and it has a special\n * method `toJSON()`, return type of this `Primitive` would be not `Primitive<Instance>`\n * but `Primitive<ReturnType<Instance.toJSON>>`.\n *\n * Before                  | After\n * ------------------------|----------------------------------------\n * `Boolean`               | `boolean`\n * `Number`                | `number`\n * `String`                | `string`\n * `Class`                 | `object`\n * `Class` with `toJSON()` | `Primitive<ReturnType<Class.toJSON>>`\n * Others                  | No change\n *\n * @template Instance Target argument type.\n * @author Jenogho Nam - https://github.com/samchon\n * @author Kyungsu Kang - https://github.com/kakasoo\n * @author Michael - https://github.com/8471919\n */\nexport type Primitive<T> = Equal<T, PrimitiveMain<T>> extends true ? T : PrimitiveMain<T>;\ntype Equal<X, Y> = X extends Y ? (Y extends X ? true : false) : false;\ntype PrimitiveMain<Instance> = Instance extends [never] ? never : ValueOf<Instance> extends boolean | number | bigint | string ? ValueOf<Instance> : ValueOf<Instance> extends object ? Instance extends object ? Instance extends NativeClass ? {} : Instance extends IJsonable<infer Raw> ? ValueOf<Raw> extends object ? Raw extends object ? PrimitiveObject<Raw> : never : ValueOf<Raw> : PrimitiveObject<Instance> : never : ValueOf<Instance>;\ntype PrimitiveObject<Instance extends object> = Instance extends Array<infer T> ? IsTuple<Instance> extends true ? PrimitiveTuple<Instance> : PrimitiveMain<T>[] : {\n    [P in keyof Instance]: Instance[P] extends Function ? never : PrimitiveMain<Instance[P]>;\n};\ntype PrimitiveTuple<T extends readonly any[]> = T extends [] ? [] : T extends [infer F] ? [PrimitiveMain<F>] : T extends [infer F, ...infer Rest extends readonly any[]] ? [PrimitiveMain<F>, ...PrimitiveTuple<Rest>] : T extends [(infer F)?] ? [PrimitiveMain<F>?] : T extends [(infer F)?, ...infer Rest extends readonly any[]] ? [PrimitiveMain<F>?, ...PrimitiveTuple<Rest>] : [];\ntype ValueOf<Instance> = IsValueOf<Instance, Boolean> extends true ? boolean : IsValueOf<Instance, Number> extends true ? number : IsValueOf<Instance, String> extends true ? string : Instance;\ntype NativeClass = Set<any> | Map<any, any> | WeakSet<any> | WeakMap<any, any> | Uint8Array | Uint8ClampedArray | Uint16Array | Uint32Array | BigUint64Array | Int8Array | Int16Array | Int32Array | BigInt64Array | Float32Array | Float64Array | ArrayBuffer | SharedArrayBuffer | DataView;\ntype IsTuple<T extends readonly any[] | {\n    length: number;\n}> = [T] extends [\n    never\n] ? false : T extends readonly any[] ? number extends T["length"] ? false : true : false;\ntype IsValueOf<Instance, Object extends IValueOf<any>> = Instance extends Object ? Object extends IValueOf<infer Primitive> ? Instance extends Primitive ? false : true : false : false;\ninterface IValueOf<T> {\n    valueOf(): T;\n}\ninterface IJsonable<T> {\n    toJSON(): T;\n}\nexport {};\n'],["file:///node_modules/typia/lib/programmers/ApplicationProgrammer.d.ts",'import { Metadata } from "../metadata/Metadata";\nimport { IJsonApplication } from "../schemas/IJsonApplication";\nexport declare namespace ApplicationProgrammer {\n    interface IOptions {\n        purpose: "ajv" | "swagger";\n    }\n    const write: (options?: Partial<IOptions>) => (metadatas: Array<Metadata>) => IJsonApplication;\n}\n'],["file:///node_modules/typia/lib/programmers/AssertCloneProgrammer.d.ts",'import ts from "typescript";\nimport { IProject } from "../transformers/IProject";\nexport declare namespace AssertCloneProgrammer {\n    const write: (project: IProject) => (modulo: ts.LeftHandSideExpression) => (type: ts.Type, name?: string) => ts.ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/programmers/AssertParseProgrammer.d.ts",'import ts from "typescript";\nimport { IProject } from "../transformers/IProject";\nexport declare namespace AssertParseProgrammer {\n    const write: (project: IProject) => (modulo: ts.LeftHandSideExpression) => (type: ts.Type, name?: string) => ts.ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/programmers/AssertProgrammer.d.ts",'import ts from "typescript";\nimport { IProject } from "../transformers/IProject";\nexport declare namespace AssertProgrammer {\n    const write: (project: IProject) => (modulo: ts.LeftHandSideExpression) => (equals: boolean) => (type: ts.Type, name?: string) => ts.ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/programmers/AssertPruneProgrammer.d.ts",'import ts from "typescript";\nimport { IProject } from "../transformers/IProject";\nexport declare namespace AssertPruneProgrammer {\n    const write: (project: IProject) => (modulo: ts.LeftHandSideExpression) => (type: ts.Type, name?: string) => ts.ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/programmers/AssertStringifyProgrammer.d.ts",'import ts from "typescript";\nimport { IProject } from "../transformers/IProject";\nexport declare namespace AssertStringifyProgrammer {\n    const write: (project: IProject) => (modulo: ts.LeftHandSideExpression) => (type: ts.Type, name?: string) => ts.ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/programmers/CheckerProgrammer.d.ts",'import ts from "typescript";\nimport { MetadataCollection } from "../factories/MetadataCollection";\nimport { Metadata } from "../metadata/Metadata";\nimport { MetadataObject } from "../metadata/MetadataObject";\nimport { IProject } from "../transformers/IProject";\nimport { FeatureProgrammer } from "./FeatureProgrammer";\nimport { FunctionImporter } from "./helpers/FunctionImporeter";\nimport { ICheckEntry } from "./helpers/ICheckEntry";\nimport { IExpressionEntry } from "./helpers/IExpressionEntry";\nexport declare namespace CheckerProgrammer {\n    interface IConfig {\n        prefix: string;\n        path: boolean;\n        trace: boolean;\n        equals: boolean;\n        numeric: boolean;\n        addition?: () => ts.Statement[];\n        decoder?: () => FeatureProgrammer.Decoder<Metadata, ts.Expression>;\n        combiner: IConfig.Combiner;\n        atomist: (explore: IExplore) => (check: ICheckEntry) => (input: ts.Expression) => ts.Expression;\n        joiner: IConfig.IJoiner;\n        success: ts.Expression;\n    }\n    namespace IConfig {\n        interface Combiner {\n            (explorer: IExplore): {\n                (logic: "and" | "or"): {\n                    (input: ts.Expression, binaries: IBinary[], expected: string): ts.Expression;\n                };\n            };\n        }\n        interface IJoiner {\n            object(input: ts.Expression, entries: IExpressionEntry[]): ts.Expression;\n            array(input: ts.Expression, arrow: ts.ArrowFunction): ts.Expression;\n            tuple?(exprs: ts.Expression[]): ts.Expression;\n            failure(value: ts.Expression, expected: string, explore?: FeatureProgrammer.IExplore): ts.Expression;\n            is?(expression: ts.Expression): ts.Expression;\n            required?(exp: ts.Expression): ts.Expression;\n            full?: (condition: ts.Expression) => (input: ts.Expression, expected: string, explore: IExplore) => ts.Expression;\n        }\n    }\n    type IExplore = FeatureProgrammer.IExplore;\n    interface IBinary {\n        expression: ts.Expression;\n        combined: boolean;\n    }\n    const write: (project: IProject) => (config: IConfig) => (importer: FunctionImporter) => (type: ts.Type, name?: string | undefined) => ts.ArrowFunction;\n    const write_object_functions: (project: IProject) => (config: IConfig) => (importer: FunctionImporter) => (collection: MetadataCollection) => ts.VariableStatement[];\n    const write_union_functions: (project: IProject) => (config: IConfig) => (importer: FunctionImporter) => (collection: MetadataCollection) => ts.VariableStatement[];\n    const write_array_functions: (project: IProject) => (config: IConfig) => (importer: FunctionImporter) => (collection: MetadataCollection) => ts.VariableStatement[];\n    const write_tuple_functions: (project: IProject) => (config: IConfig) => (importer: FunctionImporter) => (collection: MetadataCollection) => ts.VariableStatement[];\n    const decode_object: (config: IConfig) => (importer: FunctionImporter) => (input: ts.Expression, obj: MetadataObject, explore: IExplore) => ts.CallExpression;\n}\n'],["file:///node_modules/typia/lib/programmers/CloneProgrammer.d.ts",'import ts from "typescript";\nimport { IProject } from "../transformers/IProject";\nexport declare namespace CloneProgrammer {\n    const write: (project: IProject) => (modulo: ts.LeftHandSideExpression) => (type: ts.Type, name?: string | undefined) => ts.ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/programmers/FeatureProgrammer.d.ts",'import ts from "typescript";\nimport { MetadataCollection } from "../factories/MetadataCollection";\nimport { IJsDocTagInfo } from "../metadata/IJsDocTagInfo";\nimport { IMetadataTag } from "../metadata/IMetadataTag";\nimport { Metadata } from "../metadata/Metadata";\nimport { MetadataArray } from "../metadata/MetadataArray";\nimport { MetadataObject } from "../metadata/MetadataObject";\nimport { IProject } from "../transformers/IProject";\nimport { CheckerProgrammer } from "./CheckerProgrammer";\nimport { FunctionImporter } from "./helpers/FunctionImporeter";\nimport { IExpressionEntry } from "./helpers/IExpressionEntry";\nexport declare namespace FeatureProgrammer {\n    interface IConfig<Output extends ts.ConciseBody = ts.ConciseBody> {\n        types: IConfig.ITypes;\n        /**\n         * Prefix name of internal functions for specific types.\n         */\n        prefix: string;\n        /**\n         * Whether to archive access path or not.\n         */\n        path: boolean;\n        /**\n         * Whether to trace exception or not.\n         */\n        trace: boolean;\n        addition?(collection: MetadataCollection): ts.Statement[];\n        /**\n         * Initializer of metadata.\n         */\n        initializer: (project: IProject) => (type: ts.Type) => [MetadataCollection, Metadata];\n        /**\n         * Decoder, station of every types.\n         */\n        decoder: () => Decoder<Metadata, Output>;\n        /**\n         * Object configurator.\n         */\n        objector: IConfig.IObjector;\n        /**\n         * Generator of functions for object types.\n         */\n        generator: IConfig.IGenerator;\n    }\n    namespace IConfig {\n        interface ITypes {\n            input: (type: ts.Type, name?: string) => ts.TypeNode;\n            output: (type: ts.Type, name?: string) => ts.TypeNode;\n        }\n        interface IObjector {\n            /**\n             * Type checker when union object type comes.\n             */\n            checker: () => Decoder<Metadata, ts.Expression>;\n            /**\n             * Decoder, function call expression generator of specific typed objects.\n             */\n            decoder: () => Decoder<MetadataObject, ts.Expression>;\n            /**\n             * Joiner of expressions from properties.\n             */\n            joiner(input: ts.Expression, entries: IExpressionEntry[], parent: MetadataObject): ts.ConciseBody;\n            /**\n             * Union type specificator.\n             *\n             * Expression of an algorithm specifying object type and calling\n             * the `decoder` function of the specified object type.\n             */\n            unionizer: Decoder<MetadataObject[], ts.Expression>;\n            /**\n             * Handler of union type specification failure.\n             *\n             * @param value Expression of input parameter\n             * @param expected Expected type name\n             * @param explore Exploration info\n             * @returns Statement of failure\n             */\n            failure(value: ts.Expression, expected: string, explore?: IExplore): ts.Statement;\n            /**\n             * Transformer of type checking expression by discrimination.\n             *\n             * When an object type has been specified by a discrimination without full\n             * iteration, the `unionizer` will decode the object instance after\n             * the last type checking.\n             *\n             * In such circumtance, you can transform the last type checking function.\n             *\n             * @param exp Current expression about type checking\n             * @returns Transformed expression\n             * @deprecated\n             */\n            is?(exp: ts.Expression): ts.Expression;\n            /**\n             * Transformer of non-undefined type checking by discrimination.\n             *\n             * When specifying an union type of objects, `typia` tries to find\n             * descrimination way just by checking only one property type.\n             * If succeeded to find the discrimination way, `typia` will check the target\n             * property type and in the checking, non-undefined type checking would be\n             * done.\n             *\n             * In such process, you can transform the non-undefined type checking.\n             *\n             * @param exp\n             * @returns Transformed expression\n             * @deprecated\n             */\n            required?(exp: ts.Expression): ts.Expression;\n            /**\n             * Conditon wrapper when unable to specify any object type.\n             *\n             * When failed to specify an object type through discrimination, full\n             * iteration type checking would be happend. In such circumstance, you\n             * can wrap the condition with additional function.\n             *\n             * @param condition Current condition\n             * @returns A function wrapped current condition\n             */\n            full?: (condition: ts.Expression) => (input: ts.Expression, expected: string, explore: IExplore) => ts.Expression;\n            /**\n             * Return type.\n             */\n            type?: ts.TypeNode;\n        }\n        interface IGenerator {\n            objects?(): (col: MetadataCollection) => ts.VariableStatement[];\n            unions?(): (col: MetadataCollection) => ts.VariableStatement[];\n            arrays(): (col: MetadataCollection) => ts.VariableStatement[];\n            tuples(): (col: MetadataCollection) => ts.VariableStatement[];\n        }\n    }\n    interface IExplore {\n        tracable: boolean;\n        source: "top" | "function";\n        from: "top" | "array" | "object";\n        postfix: string;\n        start?: number;\n    }\n    interface Decoder<T, Output extends ts.ConciseBody = ts.ConciseBody> {\n        (input: ts.Expression, target: T, explore: IExplore, metaTags: IMetadataTag[], jsDocTags: ts.JSDocTagInfo[]): Output;\n    }\n    const write: (project: IProject) => (config: IConfig) => (importer: FunctionImporter) => (type: ts.Type, name?: string) => ts.ArrowFunction;\n    const write_object_functions: (config: IConfig) => (importer: FunctionImporter) => (collection: MetadataCollection) => ts.VariableStatement[];\n    const write_union_functions: (config: IConfig) => (collection: MetadataCollection) => ts.VariableStatement[];\n    const decode_array: (config: Pick<IConfig, "trace" | "path" | "decoder" | "prefix">) => (importer: FunctionImporter) => (combiner: (input: ts.Expression, arrow: ts.ArrowFunction, metaTags: IMetadataTag[], jsDocTags: ts.JSDocTagInfo[]) => ts.Expression) => (input: ts.Expression, array: MetadataArray, explore: IExplore, metaTags: IMetadataTag[], jsDocTags: IJsDocTagInfo[]) => ts.Expression;\n    const decode_object: (config: Pick<IConfig, "trace" | "path" | "prefix">) => (importer: FunctionImporter) => (input: ts.Expression, obj: MetadataObject, explore: IExplore) => ts.CallExpression;\n    const index: (start: number | null) => (prev: string) => (rand: string) => string;\n    const argumentsArray: (config: Pick<IConfig, "path" | "trace">) => (explore: FeatureProgrammer.IExplore) => (input: ts.Expression) => ts.Expression[];\n    const parameterDeclarations: (props: Pick<CheckerProgrammer.IConfig, "path" | "trace">) => (type: ts.TypeNode) => (input: ts.Identifier) => ts.ParameterDeclaration[];\n}\n'],["file:///node_modules/typia/lib/programmers/helpers/AtomicPredicator.d.ts",'import { Metadata } from "../../metadata/Metadata";\nimport { Atomic } from "../../typings/Atomic";\nexport declare namespace AtomicPredicator {\n    const constant: (meta: Metadata) => (name: Atomic.Literal) => boolean;\n    const atomic: (meta: Metadata) => (name: Atomic.Literal) => boolean;\n    const native: (name: string) => boolean;\n    const template: (meta: Metadata) => boolean;\n}\n'],["file:///node_modules/typia/lib/programmers/helpers/CloneJoiner.d.ts",'import ts from "typescript";\nimport { IExpressionEntry } from "./IExpressionEntry";\nexport declare namespace CloneJoiner {\n    const object: (input: ts.Expression, entries: IExpressionEntry<ts.Expression>[]) => ts.ConciseBody;\n    const tuple: (children: ts.Expression[], rest: ts.Expression | null) => ts.Expression;\n    const array: (input: ts.Expression, arrow: ts.Expression) => ts.CallExpression;\n}\n'],["file:///node_modules/typia/lib/programmers/helpers/disable_function_importer_declare.d.ts",'import { FunctionImporter } from "./FunctionImporeter";\nexport declare const disable_function_importer_declare: (importer: FunctionImporter) => FunctionImporter;\n'],["file:///node_modules/typia/lib/programmers/helpers/FunctionImporeter.d.ts",'import ts from "typescript";\nexport declare class FunctionImporter {\n    private readonly used_;\n    private readonly local_;\n    private readonly unions_;\n    private sequence_;\n    empty(): boolean;\n    use(name: string): ts.Identifier;\n    useLocal(name: string): string;\n    hasLocal(name: string): boolean;\n    declare(modulo: ts.LeftHandSideExpression): ts.Statement[];\n    increment(): number;\n    emplaceUnion(prefix: string, name: string, factory: () => ts.ArrowFunction): string;\n    trace(): void;\n}\n'],["file:///node_modules/typia/lib/programmers/helpers/ICheckEntry.d.ts",'import ts from "typescript";\nexport interface ICheckEntry {\n    expression: ts.Expression;\n    tags: ICheckEntry.ITag[];\n}\nexport declare namespace ICheckEntry {\n    interface ITag {\n        expected: string;\n        expression: ts.Expression;\n    }\n}\n'],["file:///node_modules/typia/lib/programmers/helpers/IExpressionEntry.d.ts",'import ts from "typescript";\nimport { Metadata } from "../../metadata/Metadata";\nexport interface IExpressionEntry<Expression extends ts.ConciseBody = ts.ConciseBody> {\n    input: ts.Expression;\n    key: Metadata;\n    meta: Metadata;\n    expression: Expression;\n}\n'],["file:///node_modules/typia/lib/programmers/helpers/OptionPredicator.d.ts",'import { ITransformOptions } from "../../transformers/ITransformOptions";\nexport declare namespace OptionPredicator {\n    const numeric: (options: ITransformOptions) => boolean;\n    const functional: (options: ITransformOptions) => boolean;\n    const finite: (options: ITransformOptions) => boolean;\n    const undefined: (options: ITransformOptions) => boolean;\n}\n'],["file:///node_modules/typia/lib/programmers/helpers/PruneJoiner.d.ts",'import ts from "typescript";\nimport { MetadataObject } from "../../metadata/MetadataObject";\nimport { IExpressionEntry } from "./IExpressionEntry";\nexport declare namespace PruneJoiner {\n    const object: (input: ts.Expression, entries: IExpressionEntry[], obj: MetadataObject) => ts.ConciseBody;\n    const array: (input: ts.Expression, arrow: ts.ArrowFunction) => ts.CallExpression;\n    const tuple: (children: ts.ConciseBody[], rest: ts.ConciseBody | null) => ts.Block;\n}\n'],["file:///node_modules/typia/lib/programmers/helpers/RandomJoiner.d.ts",'import ts from "typescript";\nimport { ICommentTag } from "../../metadata/ICommentTag";\nimport { IMetadataTag } from "../../metadata/IMetadataTag";\nimport { Metadata } from "../../metadata/Metadata";\nimport { MetadataObject } from "../../metadata/MetadataObject";\nexport declare namespace RandomJoiner {\n    type Decoder = (meta: Metadata, tags: IMetadataTag[], comments: ICommentTag[]) => ts.Expression;\n    const array: (coalesce: (method: string) => ts.Expression) => (decoder: Decoder) => (explore: IExplore) => (length: ts.Expression | undefined) => (item: Metadata, tags: IMetadataTag[], comments: ICommentTag[]) => ts.Expression;\n    const tuple: (decoder: Decoder) => (items: Metadata[], tags: IMetadataTag[], comments: ICommentTag[]) => ts.ArrayLiteralExpression;\n    const object: (coalesce: (method: string) => ts.Expression) => (decoder: Decoder) => (obj: MetadataObject) => ts.ConciseBody;\n}\ninterface IExplore {\n    function: boolean;\n    recursive: boolean;\n}\nexport {};\n'],["file:///node_modules/typia/lib/programmers/helpers/RandomRanger.d.ts",'import ts from "typescript";\nimport { IMetadataTag } from "../../metadata/IMetadataTag";\nexport declare namespace RandomRanger {\n    interface IDefaults {\n        minimum: number;\n        maximum: number;\n        gap: number;\n    }\n    const length: (coalesce: (method: string) => ts.Expression) => (defs: IDefaults) => (acc: length.IAccessors) => (tags: IMetadataTag[]) => ts.Expression | undefined;\n    namespace length {\n        interface IAccessors {\n            minimum: IMetadataTag["kind"];\n            maximum: IMetadataTag["kind"];\n            fixed: IMetadataTag["kind"];\n        }\n    }\n    const number: (config: number.IConfig) => (defs: IDefaults) => (tags: IMetadataTag[]) => ts.Expression;\n    namespace number {\n        interface IConfig {\n            setter: (args: number[]) => ts.Expression;\n            transform: (value: number) => ts.Expression;\n            type: "int" | "uint" | "double";\n        }\n    }\n}\n'],["file:///node_modules/typia/lib/programmers/helpers/StringifyJoinder.d.ts",'import ts from "typescript";\nimport { FunctionImporter } from "./FunctionImporeter";\nimport { IExpressionEntry } from "./IExpressionEntry";\nexport declare namespace StringifyJoiner {\n    const object: (importer: FunctionImporter) => (_input: ts.Expression, entries: IExpressionEntry<ts.Expression>[]) => ts.Expression;\n    const array: (input: ts.Expression, arrow: ts.ArrowFunction) => ts.Expression;\n    const tuple: (children: ts.Expression[], rest: ts.Expression | null) => ts.Expression;\n}\n'],["file:///node_modules/typia/lib/programmers/helpers/StringifyPredicator.d.ts",'import { Metadata } from "../../metadata/Metadata";\nexport declare namespace StringifyPredicator {\n    const require_escape: (value: string) => boolean;\n    const undefindable: (meta: Metadata) => boolean;\n}\n'],["file:///node_modules/typia/lib/programmers/helpers/UnionExplorer.d.ts",'import ts from "typescript";\nimport { IMetadataTag } from "../../metadata/IMetadataTag";\nimport { Metadata } from "../../metadata/Metadata";\nimport { MetadataArray } from "../../metadata/MetadataArray";\nimport { MetadataObject } from "../../metadata/MetadataObject";\nimport { MetadataTuple } from "../../metadata/MetadataTuple";\nimport { FeatureProgrammer } from "../FeatureProgrammer";\nimport { check_union_array_like } from "../internal/check_union_array_like";\nexport declare namespace UnionExplorer {\n    interface Decoder<T> {\n        (input: ts.Expression, target: T, explore: FeatureProgrammer.IExplore, tags: IMetadataTag[], jsDocTags: ts.JSDocTagInfo[]): ts.Expression;\n    }\n    type ObjectCombiner = Decoder<MetadataObject[]>;\n    const object: (config: FeatureProgrammer.IConfig, level?: number) => (input: ts.Expression, targets: MetadataObject[], explore: FeatureProgrammer.IExplore, tags: IMetadataTag[], jsDocTags: ts.JSDocTagInfo[]) => ts.Expression;\n    const tuple: (props: check_union_array_like.IProps<MetadataTuple, MetadataTuple>) => (parameters: ts.ParameterDeclaration[]) => (input: ts.Expression, origins: MetadataTuple[], explore: FeatureProgrammer.IExplore, tags: IMetadataTag[], jsDocTags: ts.JSDocTagInfo[]) => ts.ArrowFunction;\n    namespace tuple {\n        type IProps = check_union_array_like.IProps<MetadataTuple, MetadataTuple>;\n    }\n    const array: (props: array.IProps) => (parameters: ts.ParameterDeclaration[]) => (input: ts.Expression, origins: MetadataArray[], explore: FeatureProgrammer.IExplore, tags: IMetadataTag[], jsDocTags: ts.JSDocTagInfo[]) => ts.ArrowFunction;\n    namespace array {\n        type IProps = check_union_array_like.IProps<MetadataArray, Metadata>;\n    }\n    const array_or_tuple: (props: array_or_tuple.IProps) => (parameters: ts.ParameterDeclaration[]) => (input: ts.Expression, origins: (MetadataArray | MetadataTuple)[], explore: FeatureProgrammer.IExplore, tags: IMetadataTag[], jsDocTags: ts.JSDocTagInfo[]) => ts.ArrowFunction;\n    namespace array_or_tuple {\n        type IProps = check_union_array_like.IProps<MetadataArray | MetadataTuple, Metadata>;\n    }\n    const set: (props: set.IProps) => (parameters: ts.ParameterDeclaration[]) => (input: ts.Expression, origins: Metadata[], explore: FeatureProgrammer.IExplore, tags: IMetadataTag[], jsDocTags: ts.JSDocTagInfo[]) => ts.ArrowFunction;\n    namespace set {\n        type IProps = check_union_array_like.IProps<MetadataArray, Metadata>;\n    }\n    const map: (props: map.IProps) => (parameters: ts.ParameterDeclaration[]) => (input: ts.Expression, origins: Metadata.Entry[], explore: FeatureProgrammer.IExplore, tags: IMetadataTag[], jsDocTags: ts.JSDocTagInfo[]) => ts.ArrowFunction;\n    namespace map {\n        type IProps = check_union_array_like.IProps<MetadataArray, [\n            Metadata,\n            Metadata\n        ]>;\n    }\n}\n'],["file:///node_modules/typia/lib/programmers/helpers/UnionPredicator.d.ts",'import { MetadataObject } from "../../metadata/MetadataObject";\nimport { MetadataProperty } from "../../metadata/MetadataProperty";\nexport declare namespace UnionPredicator {\n    interface ISpecialized {\n        index: number;\n        object: MetadataObject;\n        property: MetadataProperty;\n        neighbour: boolean;\n    }\n    const object: (targets: MetadataObject[]) => Array<ISpecialized>;\n}\n'],["file:///node_modules/typia/lib/programmers/internal/application_alias.d.ts",'import { MetadataAlias } from "../../metadata/MetadataAlias";\nimport { IJsonComponents } from "../../schemas/IJsonComponents";\nimport { IJsonSchema } from "../../module";\nimport { ApplicationProgrammer } from "../ApplicationProgrammer";\nexport declare const application_alias: (options: ApplicationProgrammer.IOptions) => <BlockNever extends boolean>(blockNever: BlockNever) => (components: IJsonComponents) => (alias: MetadataAlias) => (nullable: boolean) => IJsonSchema.IReference;\n'],["file:///node_modules/typia/lib/programmers/internal/application_array.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/application_boolean.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/application_constant.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/application_default.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/application_default_string.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/application_native.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/application_number.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/application_object.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/application_resolved.d.ts",'import { MetadataResolved } from "../../metadata/MetadataResolved";\nimport { IJsonComponents, IJsonSchema } from "../../module";\nimport { ApplicationProgrammer } from "../ApplicationProgrammer";\nexport declare const application_resolved: (options: ApplicationProgrammer.IOptions) => <BlockNever extends boolean>(blockNever: BlockNever) => (components: IJsonComponents) => (resolved: MetadataResolved) => (attribute: IJsonSchema.IAttribute) => IJsonSchema[];\n'],["file:///node_modules/typia/lib/programmers/internal/application_schema.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/application_string.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/application_templates.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/application_tuple.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/check_array.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/check_array_length.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/check_bigint.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/check_custom.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/check_dynamic_properties.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/check_everything.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/check_native.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/check_number.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/check_object.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/check_string.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/check_string_tags.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/check_template.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/check_union_array_like.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/decode_union_object.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/feature_object_entries.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/get_comment_tags.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/JSON_SCHEMA_PREFIX.d.ts",'export declare const JSON_COMPONENTS_PREFIX = "#/components";\n'],["file:///node_modules/typia/lib/programmers/internal/metadata_to_pattern.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/prune_object_properties.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/random_custom.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/stringify_dynamic_properties.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/stringify_native.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/stringify_regular_properties.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/template_to_pattern.d.ts","export {};\n"],["file:///node_modules/typia/lib/programmers/internal/wrap_metadata_rest_tuple.d.ts",'import { Metadata } from "../../metadata/Metadata";\nexport declare const wrap_metadata_rest_tuple: (rest: Metadata) => Metadata;\n'],["file:///node_modules/typia/lib/programmers/IsCloneProgrammer.d.ts",'import ts from "typescript";\nimport { IProject } from "../transformers/IProject";\nexport declare namespace IsCloneProgrammer {\n    const write: (project: IProject) => (modulo: ts.LeftHandSideExpression) => (type: ts.Type, name?: string) => ts.ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/programmers/IsParseProgrammer.d.ts",'import ts from "typescript";\nimport { IProject } from "../transformers/IProject";\nexport declare namespace IsParseProgrammer {\n    const write: (project: IProject) => (modulo: ts.LeftHandSideExpression) => (type: ts.Type, name?: string) => ts.ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/programmers/IsProgrammer.d.ts",'import ts from "typescript";\nimport { MetadataCollection } from "../factories/MetadataCollection";\nimport { MetadataObject } from "../metadata/MetadataObject";\nimport { IProject } from "../transformers/IProject";\nimport { CheckerProgrammer } from "./CheckerProgrammer";\nimport { FunctionImporter } from "./helpers/FunctionImporeter";\nimport { IExpressionEntry } from "./helpers/IExpressionEntry";\nexport declare namespace IsProgrammer {\n    const configure: (options?: Partial<CONFIG.IOptions>) => (importer: FunctionImporter) => CheckerProgrammer.IConfig;\n    namespace CONFIG {\n        interface IOptions {\n            numeric: boolean;\n            undefined: boolean;\n            object: (input: ts.Expression, entries: IExpressionEntry<ts.Expression>[]) => ts.Expression;\n        }\n    }\n    const write: (project: IProject) => (modulo: ts.LeftHandSideExpression, disable?: boolean) => (equals: boolean) => (type: ts.Type, name?: string | undefined) => ts.ArrowFunction;\n    const write_function_statements: (project: IProject) => (importer: FunctionImporter) => (collection: MetadataCollection) => ts.VariableStatement[];\n    const decode: (project: IProject) => (importer: FunctionImporter) => (input: ts.Expression, meta: import("../metadata/Metadata").Metadata, explore: import("./FeatureProgrammer").FeatureProgrammer.IExplore, metaTags: import("../metadata/IMetadataTag").IMetadataTag[], jsDocTags: ts.JSDocTagInfo[]) => ts.Expression;\n    const decode_object: (importer: FunctionImporter) => (input: ts.Expression, obj: MetadataObject, explore: import("./FeatureProgrammer").FeatureProgrammer.IExplore) => ts.CallExpression;\n    const decode_to_json: (checkNull: boolean) => (input: ts.Expression) => ts.Expression;\n    const decode_functional: (input: ts.Expression) => ts.BinaryExpression;\n}\n'],["file:///node_modules/typia/lib/programmers/IsPruneProgrammer.d.ts",'import ts from "typescript";\nimport { IProject } from "../transformers/IProject";\nexport declare namespace IsPruneProgrammer {\n    const write: (project: IProject) => (modulo: ts.LeftHandSideExpression) => (type: ts.Type, name?: string) => ts.ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/programmers/IsStringifyProgrammer.d.ts",'import ts from "typescript";\nimport { IProject } from "../transformers/IProject";\nexport declare namespace IsStringifyProgrammer {\n    const write: (project: IProject) => (modulo: ts.LeftHandSideExpression) => (type: ts.Type, name?: string) => ts.ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/programmers/LiteralsProgrammer.d.ts",'import ts from "typescript";\nimport { IProject } from "../transformers/IProject";\nexport declare namespace LiteralsProgrammer {\n    const write: (project: IProject) => (type: ts.Type) => ts.AsExpression;\n}\n'],["file:///node_modules/typia/lib/programmers/PruneProgrammer.d.ts",'import ts from "typescript";\nimport { IProject } from "../transformers/IProject";\nexport declare namespace PruneProgrammer {\n    const write: (project: IProject) => (modulo: ts.LeftHandSideExpression) => (type: ts.Type, name?: string | undefined) => ts.ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/programmers/RandomProgrammer.d.ts",'import ts from "typescript";\nimport { IProject } from "../transformers/IProject";\nexport declare namespace RandomProgrammer {\n    const write: (project: IProject) => (modulo: ts.LeftHandSideExpression) => (init?: ts.Expression) => (type: ts.Type, name?: string) => ts.ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/programmers/StringifyProgrammer.d.ts",'import ts from "typescript";\nimport { IProject } from "../transformers/IProject";\nexport declare namespace StringifyProgrammer {\n    const write: (project: IProject) => (modulo: ts.LeftHandSideExpression) => (type: ts.Type, name?: string | undefined) => ts.ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/programmers/TypiaProgrammer.d.ts","export declare namespace TypiaProgrammer {\n    interface IProps {\n        input: string;\n        output: string;\n        project: string;\n    }\n    const build: (props: TypiaProgrammer.IProps) => Promise<void>;\n}\n"],["file:///node_modules/typia/lib/programmers/ValidateCloneProgrammer.d.ts",'import ts from "typescript";\nimport { IProject } from "../transformers/IProject";\nexport declare namespace ValidateCloneProgrammer {\n    const write: (project: IProject) => (modulo: ts.LeftHandSideExpression) => (type: ts.Type, name?: string) => ts.ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/programmers/ValidateParseProgrammer.d.ts",'import ts from "typescript";\nimport { IProject } from "../transformers/IProject";\nexport declare namespace ValidateParseProgrammer {\n    const write: (project: IProject) => (modulo: ts.LeftHandSideExpression) => (type: ts.Type, name?: string) => ts.ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/programmers/ValidateProgrammer.d.ts",'import ts from "typescript";\nimport { IProject } from "../transformers/IProject";\nexport declare namespace ValidateProgrammer {\n    const write: (project: IProject) => (modulo: ts.LeftHandSideExpression) => (equals: boolean) => (type: ts.Type, name?: string) => ts.ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/programmers/ValidatePruneProgrammer.d.ts",'import ts from "typescript";\nimport { IProject } from "../transformers/IProject";\nexport declare namespace ValidatePruneProgrammer {\n    const write: (project: IProject) => (modulo: ts.LeftHandSideExpression) => (type: ts.Type, name?: string) => ts.ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/programmers/ValidateStringifyProgrammer.d.ts",'import ts from "typescript";\nimport { IProject } from "../transformers/IProject";\nexport declare namespace ValidateStringifyProgrammer {\n    const write: (project: IProject) => (modulo: ts.LeftHandSideExpression) => (type: ts.Type, name?: string) => ts.ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/schemas/IJsonApplication.d.ts",'import { IJsonComponents } from "./IJsonComponents";\nimport { IJsonSchema } from "./IJsonSchema";\nexport interface IJsonApplication {\n    schemas: IJsonSchema[];\n    components: IJsonComponents;\n    purpose: "swagger" | "ajv";\n}\n'],["file:///node_modules/typia/lib/schemas/IJsonComponents.d.ts",'import { IJsDocTagInfo } from "../metadata/IJsDocTagInfo";\nimport { IJsonSchema } from "./IJsonSchema";\nexport interface IJsonComponents {\n    schemas?: Record<string, IJsonComponents.IObject | IJsonComponents.IAlias>;\n}\nexport declare namespace IJsonComponents {\n    interface IObject {\n        $id?: string;\n        type: "object";\n        /**\n         * Only when swagger mode.\n         */\n        nullable?: boolean;\n        properties: Record<string, IJsonSchema>;\n        patternProperties?: Record<string, IJsonSchema>;\n        additionalProperties?: IJsonSchema;\n        required?: string[];\n        description?: string;\n        "x-typia-jsDocTags"?: IJsDocTagInfo[];\n        "x-typia-patternProperties"?: Record<string, IJsonSchema>;\n        "x-typia-additionalProperties"?: IJsonSchema;\n    }\n    type IAlias = IJsonSchema & {\n        $id?: string;\n        $recursiveAnchor?: boolean;\n    };\n}\n'],["file:///node_modules/typia/lib/schemas/IJsonSchema.d.ts",'import { IJsDocTagInfo } from "../metadata/IJsDocTagInfo";\nimport { IMetadataTag } from "../metadata/IMetadataTag";\nimport { Atomic } from "../typings/Atomic";\nexport type IJsonSchema = IJsonSchema.Known | IJsonSchema.IUnknown;\nexport declare namespace IJsonSchema {\n    type Known = IEnumeration<"boolean"> | IEnumeration<"number"> | IEnumeration<"string"> | IBoolean | IInteger | INumber | IString | IArray | ITuple | IOneOf | IReference | INullOnly;\n    interface IUnknown extends IAttribute {\n        type?: undefined;\n    }\n    interface IEnumeration<Literal extends Exclude<Atomic.Literal, "bigint">> extends IAtomic<Literal> {\n        enum: Array<Atomic.Mapper[Literal]>;\n    }\n    interface IAtomic<Literal extends Exclude<Atomic.Literal, "bigint">> extends ISignificant<Literal> {\n        default?: Atomic.Mapper[Literal];\n    }\n    interface IString extends IAtomic<"string"> {\n        /**\n         * @type uint\n         */\n        minLength?: number;\n        /**\n         * @type uint\n         */\n        maxLength?: number;\n        pattern?: string;\n        format?: string;\n    }\n    interface INumber extends IAtomic<"number"> {\n        minimum?: number;\n        maximum?: number;\n        exclusiveMinimum?: boolean;\n        exclusiveMaximum?: boolean;\n        multipleOf?: number;\n    }\n    interface IInteger extends IAtomic<"integer"> {\n        /**\n         * @type int\n         */\n        minimum?: number;\n        /**\n         * @type int\n         */\n        maximum?: number;\n        exclusiveMinimum?: boolean;\n        exclusiveMaximum?: boolean;\n        /**\n         * @type int\n         */\n        multipleOf?: number;\n    }\n    interface IBoolean extends IAtomic<"boolean"> {\n    }\n    interface IArray extends ISignificant<"array"> {\n        items: IJsonSchema;\n        /**\n         * @type uint\n         */\n        minItems?: number;\n        /**\n         * @type uint\n         */\n        maxItems?: number;\n        "x-typia-tuple"?: ITuple;\n    }\n    interface ITuple extends ISignificant<"array"> {\n        items: IJsonSchema[];\n        /**\n         * @type uint\n         */\n        minItems: number;\n        /**\n         * @type uint\n         */\n        maxItems?: number;\n    }\n    interface IReference extends IAttribute {\n        $ref: string;\n    }\n    interface INullOnly extends IAttribute {\n        type: "null";\n    }\n    interface IOneOf extends IAttribute {\n        oneOf: IJsonSchema[];\n    }\n    interface ISignificant<Literal extends string> extends IAttribute {\n        type: Literal;\n        /**\n         * Only when swagger mode.\n         */\n        nullable?: boolean;\n    }\n    interface IAttribute {\n        deprecated?: boolean;\n        title?: string;\n        description?: string;\n        "x-typia-metaTags"?: IMetadataTag[];\n        "x-typia-jsDocTags"?: IJsDocTagInfo[];\n        "x-typia-required"?: boolean;\n        "x-typia-optional"?: boolean;\n        "x-typia-rest"?: boolean;\n    }\n}\n'],["file:///node_modules/typia/lib/transform.d.ts",'import ts from "typescript";\nimport { ITransformOptions } from "./transformers/ITransformOptions";\nexport declare const transform: (program: ts.Program, options?: ITransformOptions) => ts.TransformerFactory<ts.SourceFile>;\nexport default transform;\n'],["file:///node_modules/typia/lib/transformers/CallExpressionTransformer.d.ts",'import ts from "typescript";\nimport { IProject } from "./IProject";\nexport declare namespace CallExpressionTransformer {\n    const transform: (project: IProject) => (expression: ts.CallExpression) => ts.Expression;\n}\n'],["file:///node_modules/typia/lib/transformers/features/miscellaneous/ApplicationTransformer.d.ts",'import ts from "typescript";\nimport { IProject } from "../../IProject";\nexport declare namespace ApplicationTransformer {\n    const transform: ({ checker }: IProject) => (expression: ts.CallExpression) => ts.Expression;\n}\n'],["file:///node_modules/typia/lib/transformers/features/miscellaneous/AssertCloneTransformer.d.ts",'export declare namespace AssertCloneTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").CallExpression;\n}\n'],["file:///node_modules/typia/lib/transformers/features/miscellaneous/AssertPruneTransformer.d.ts",'export declare namespace AssertPruneTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").CallExpression;\n}\n'],["file:///node_modules/typia/lib/transformers/features/miscellaneous/CloneTransformer.d.ts",'export declare namespace CloneTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").CallExpression;\n}\n'],["file:///node_modules/typia/lib/transformers/features/miscellaneous/CreateAssertCloneTransformer.d.ts",'export declare namespace CreateAssertCloneTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/transformers/features/miscellaneous/CreateAssertPruneTransformer.d.ts",'export declare namespace CreateAssertPruneTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/transformers/features/miscellaneous/CreateCloneTransformer.d.ts",'export declare namespace CreateCloneTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/transformers/features/miscellaneous/CreateIsCloneTransformer.d.ts",'export declare namespace CreateIsCloneTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/transformers/features/miscellaneous/CreateIsPruneTransformer.d.ts",'export declare namespace CreateIsPruneTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/transformers/features/miscellaneous/CreatePruneTransformer.d.ts",'export declare namespace CreatePruneTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/transformers/features/miscellaneous/CreateRandomTransformer.d.ts",'import ts from "typescript";\nimport { IProject } from "../../IProject";\nexport declare namespace CreateRandomTransformer {\n    const transform: (project: IProject) => (modulo: ts.LeftHandSideExpression) => (expression: ts.CallExpression) => ts.Expression;\n}\n'],["file:///node_modules/typia/lib/transformers/features/miscellaneous/CreateValidateCloneTransformer.d.ts",'export declare namespace CreateValidateCloneTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/transformers/features/miscellaneous/CreateValidatePruneTransformer.d.ts",'export declare namespace CreateValidatePruneTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/transformers/features/miscellaneous/IsCloneTransformer.d.ts",'export declare namespace IsCloneTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").CallExpression;\n}\n'],["file:///node_modules/typia/lib/transformers/features/miscellaneous/IsPruneTransformer.d.ts",'export declare namespace IsPruneTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").CallExpression;\n}\n'],["file:///node_modules/typia/lib/transformers/features/miscellaneous/LiteralsTransformer.d.ts",'import ts from "typescript";\nimport { IProject } from "../../IProject";\nexport declare namespace LiteralsTransformer {\n    const transform: (project: IProject) => (expression: ts.CallExpression) => ts.Expression;\n}\n'],["file:///node_modules/typia/lib/transformers/features/miscellaneous/MetadataTransformer.d.ts",'import ts from "typescript";\nimport { IProject } from "../../IProject";\nexport declare namespace MetadataTransformer {\n    const transform: ({ checker }: IProject) => (expression: ts.CallExpression) => ts.Expression;\n}\n'],["file:///node_modules/typia/lib/transformers/features/miscellaneous/PruneTransformer.d.ts",'export declare namespace PruneTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").CallExpression;\n}\n'],["file:///node_modules/typia/lib/transformers/features/miscellaneous/RandomTransformer.d.ts",'import ts from "typescript";\nimport { IProject } from "../../IProject";\nexport declare namespace RandomTransformer {\n    const transform: (project: IProject) => (modulo: ts.LeftHandSideExpression) => (expression: ts.CallExpression) => ts.Expression;\n}\n'],["file:///node_modules/typia/lib/transformers/features/miscellaneous/ValidateCloneTransformer.d.ts",'export declare namespace ValidateCloneTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").CallExpression;\n}\n'],["file:///node_modules/typia/lib/transformers/features/miscellaneous/ValidatePruneTransformer.d.ts",'export declare namespace ValidatePruneTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").CallExpression;\n}\n'],["file:///node_modules/typia/lib/transformers/features/parsers/AssertParseTransformer.d.ts",'export declare namespace AssertParseTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").CallExpression;\n}\n'],["file:///node_modules/typia/lib/transformers/features/parsers/CreateAssertParseTransformer.d.ts",'export declare namespace CreateAssertParseTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/transformers/features/parsers/CreateIsParseTransformer.d.ts",'export declare namespace CreateIsParseTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/transformers/features/parsers/CreateValidateParseTransformer.d.ts",'export declare namespace CreateValidateParseTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/transformers/features/parsers/IsParseTransformer.d.ts",'export declare namespace IsParseTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").CallExpression;\n}\n'],["file:///node_modules/typia/lib/transformers/features/parsers/ValidateParseTransformer.d.ts",'export declare namespace ValidateParseTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").CallExpression;\n}\n'],["file:///node_modules/typia/lib/transformers/features/stringifiers/AssertStringifyTransformer.d.ts",'export declare namespace AssertStringifyTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").CallExpression;\n}\n'],["file:///node_modules/typia/lib/transformers/features/stringifiers/CreateAssertStringifyTransformer.d.ts",'export declare namespace CreateAssertStringifyTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/transformers/features/stringifiers/CreateIsStringifyTransformer.d.ts",'export declare namespace CreateIsStringifyTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/transformers/features/stringifiers/CreateStringifyTransformer.d.ts",'export declare namespace CreateStringifyTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/transformers/features/stringifiers/CreateValidateStringifyProgrammer.d.ts",'export declare namespace CreateValidateStringifyTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/transformers/features/stringifiers/IsStringifyTransformer.d.ts",'export declare namespace IsStringifyTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").CallExpression;\n}\n'],["file:///node_modules/typia/lib/transformers/features/stringifiers/StringifyTransformer.d.ts",'export declare namespace StringifyTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").CallExpression;\n}\n'],["file:///node_modules/typia/lib/transformers/features/stringifiers/ValidateStringifyTransformer.d.ts",'export declare namespace ValidateStringifyTransformer {\n    const transform: (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").CallExpression;\n}\n'],["file:///node_modules/typia/lib/transformers/features/validators/AssertTransformer.d.ts",'export declare namespace AssertTransformer {\n    const transform: (equals: boolean) => (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").CallExpression;\n}\n'],["file:///node_modules/typia/lib/transformers/features/validators/CreateAssertTransformer.d.ts",'export declare namespace CreateAssertTransformer {\n    const transform: (equals: boolean) => (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/transformers/features/validators/CreateIsTransformer.d.ts",'export declare namespace CreateIsTransformer {\n    const transform: (equals: boolean) => (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/transformers/features/validators/CreateValidateTransformer.d.ts",'export declare namespace CreateValidateTransformer {\n    const transform: (equals: boolean) => (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/transformers/features/validators/IsTransformer.d.ts",'export declare namespace IsTransformer {\n    const transform: (equals: boolean) => (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").CallExpression;\n}\n'],["file:///node_modules/typia/lib/transformers/features/validators/ValidateTransformer.d.ts",'export declare namespace ValidateTransformer {\n    const transform: (equals: boolean) => (project: import("../../IProject").IProject) => (modulo: import("typescript").LeftHandSideExpression) => (expression: import("typescript").CallExpression) => import("typescript").CallExpression;\n}\n'],["file:///node_modules/typia/lib/transformers/FileTransformer.d.ts",'import ts from "typescript";\nimport { IProject } from "./IProject";\nexport declare namespace FileTransformer {\n    const transform: (project: IProject) => (context: ts.TransformationContext) => (file: ts.SourceFile) => ts.SourceFile;\n}\n'],["file:///node_modules/typia/lib/transformers/ImportTransformer.d.ts",'import ts from "typescript";\nexport declare namespace ImportTransformer {\n    const transform: (from: string) => (to: string) => (context: ts.TransformationContext) => (file: ts.SourceFile) => ts.SourceFile;\n}\n'],["file:///node_modules/typia/lib/transformers/internal/GenericTransformer.d.ts",'import ts from "typescript";\nimport { IProject } from "../IProject";\nexport declare namespace GenericTransformer {\n    const scalar: (method: string) => (programmer: (project: IProject) => (modulo: ts.LeftHandSideExpression) => (type: ts.Type, name: string) => ts.ArrowFunction) => (project: IProject) => (modulo: ts.LeftHandSideExpression) => (expression: ts.CallExpression) => ts.CallExpression;\n    const factory: (method: string) => (programmer: (project: IProject) => (modulo: ts.LeftHandSideExpression) => (type: ts.Type, name: string) => ts.ArrowFunction) => (project: IProject) => (modulo: ts.LeftHandSideExpression) => (expression: ts.CallExpression) => ts.ArrowFunction;\n}\n'],["file:///node_modules/typia/lib/transformers/IProject.d.ts",'import ts from "typescript";\nimport { ITransformOptions } from "./ITransformOptions";\nexport interface IProject {\n    program: ts.Program;\n    compilerOptions: ts.CompilerOptions;\n    checker: ts.TypeChecker;\n    printer: ts.Printer;\n    options: ITransformOptions;\n}\n'],["file:///node_modules/typia/lib/transformers/ITransformOptions.d.ts","export interface ITransformOptions {\n    /**\n     * Whether to validate finite number or not.\n     *\n     * If configured true, number typed values would be validated by Number.isNaN().\n     *\n     * However, whatever you configure, it would be ignored when marshaling or parsing.\n     *\n     *   - when marshaling, always be true\n     *     - assertStringify()\n     *     - validateEncode()\n     *   - when parsing, always be false\n     *     - assertParse()\n     *     - isDecode()\n     *\n     * @default false\n     */\n    finite?: boolean;\n    /**\n     * Whether to validate finite number or not.\n     *\n     * If configured true, number typed values would be validated by Number.isFinite().\n     *\n     * However, whatever you configure, it can be ignored in below case.\n     *\n     *   - when `finite` option is true, this option would be ignored\n     *   - when marshaling, always be true\n     *     - assertStringify()\n     *     - validateEncode()\n     *   - when parsing, always be false\n     *     - assertParse()\n     *     - isDecode()\n     *\n     * @default false\n     */\n    numeric?: boolean;\n    /**\n     * Whether to validate functional type or not.\n     *\n     * However, whatever you configure, it becomes false when marshaling or parsing.\n     *\n     * @default false\n     */\n    functional?: boolean;\n    /**\n     * Whether to check undefined value or not.\n     *\n     * JavaScript can assign `undefined` value to a specific property and it is an\n     * issue when validating without allowing superfluous properties. Should undefined\n     * value assigned superfluous property be allowed or not?\n     *\n     * Note that, this option only works on {@link equals} function. Other function\n     * like {@link assertEquals} or {@link validateEquals} would ignore this option\n     * value and always allow the `undefined` value.\n     *\n     * @default true\n     */\n    undefined?: boolean;\n}\n"],["file:///node_modules/typia/lib/transformers/NodeTransformer.d.ts",'import ts from "typescript";\nimport { IProject } from "./IProject";\nexport declare namespace NodeTransformer {\n    const transform: (project: IProject) => (expression: ts.Node) => ts.Node;\n}\n'],["file:///node_modules/typia/lib/TypeGuardError.d.ts","export declare class TypeGuardError extends Error {\n    readonly method: string;\n    readonly path: string | undefined;\n    readonly expected: string;\n    readonly value: any;\n    constructor(props: TypeGuardError.IProps);\n}\nexport declare namespace TypeGuardError {\n    interface IProps {\n        method: string;\n        path?: string;\n        expected: string;\n        value: any;\n        message?: string;\n    }\n}\n"],["file:///node_modules/typia/lib/typings/Atomic.d.ts",'export declare namespace Atomic {\n    type Type = boolean | number | string | bigint;\n    type Literal = "boolean" | "integer" | "number" | "string" | "bigint";\n    type Mapper = {\n        boolean: boolean;\n        integer: number;\n        number: number;\n        string: string;\n        bigint: bigint;\n    };\n}\n'],["file:///node_modules/typia/lib/typings/ClassProperties.d.ts",'import { OmitNever } from "./OmitNever";\nexport type ClassProperties<T extends object> = OmitNever<{\n    [K in keyof T]: T[K] extends Function ? never : T[K];\n}>;\n'],["file:///node_modules/typia/lib/typings/Customizable.d.ts","export type Customizable = {\n    number: number;\n    string: string;\n    bigint: bigint;\n};\n"],["file:///node_modules/typia/lib/typings/OmitNever.d.ts",'import { SpecialFields } from "./SpecialFields";\nexport type OmitNever<T extends object> = Omit<T, SpecialFields<T, never>>;\n'],["file:///node_modules/typia/lib/typings/SpecialFields.d.ts","export type SpecialFields<Instance extends object, Target> = {\n    [P in keyof Instance]: Instance[P] extends Target ? P : never;\n}[keyof Instance & string];\n"],["file:///node_modules/typia/lib/typings/Writable.d.ts",'import { ClassProperties } from "./ClassProperties";\nexport type Writable<T extends object> = {\n    -readonly [P in keyof T]: T[P];\n};\nexport declare function Writable<T extends object>(elem: T): Writable<ClassProperties<T>>;\n'],["file:///node_modules/typia/lib/utils/ArrayUtil.d.ts","export declare namespace ArrayUtil {\n    const has: <T>(array: T[], pred: (elem: T) => boolean) => boolean;\n    const add: <T>(array: T[], value: T, pred?: (x: T, y: T) => boolean) => boolean;\n    const set: <Key, T>(array: T[], value: T, key: (elem: T) => Key) => void;\n    const take: <T>(array: T[], pred: (elem: T) => boolean, init: () => T) => T;\n    const repeat: <T>(count: number, closure: (index: number, count: number) => T) => T[];\n    const flat: <T>(matrix: T[][]) => T[];\n}\n"],["file:///node_modules/typia/lib/utils/Escaper.d.ts","export declare namespace Escaper {\n    const variable: (str: string) => boolean;\n}\n"],["file:///node_modules/typia/lib/utils/MapUtil.d.ts","export declare namespace MapUtil {\n    const take: <Key, T>(dict: Map<Key, T>) => (key: Key, generator: () => T) => T;\n}\n"],["file:///node_modules/typia/lib/utils/PatternUtil.d.ts",'export declare namespace PatternUtil {\n    const fix: (str: string) => string;\n    const escape: (str: string) => string;\n    const NUMBER = "-?\\d+\\.?\\d*";\n    const BOOLEAN = "true|false";\n    const STRING = "(.*)";\n}\n'],["file:///node_modules/typia/lib/utils/RandomGenerator.d.ts","export {};\n"],["file:///node_modules/typia/lib/utils/Singleton.d.ts","export declare class Singleton<T, Args extends any[] = []> {\n    private readonly closure_;\n    private value_;\n    constructor(closure: (...args: Args) => T);\n    get(...args: Args): T;\n}\n"],["file:///node_modules/typescript/lib/lib.es5.d.ts",'/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the "License"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n/// <reference no-default-lib="true"/>\n\n/// <reference lib="decorators" />\n/// <reference lib="decorators.legacy" />\n\n/////////////////////////////\n/// ECMAScript APIs\n/////////////////////////////\n\ndeclare var NaN: number;\ndeclare var Infinity: number;\n\n/**\n * Evaluates JavaScript code and executes it.\n * @param x A String value that contains valid JavaScript code.\n */\ndeclare function eval(x: string): any;\n\n/**\n * Converts a string to an integer.\n * @param string A string to convert into a number.\n * @param radix A value between 2 and 36 that specifies the base of the number in `string`.\n * If this argument is not supplied, strings with a prefix of \'0x\' are considered hexadecimal.\n * All other strings are considered decimal.\n */\ndeclare function parseInt(string: string, radix?: number): number;\n\n/**\n * Converts a string to a floating-point number.\n * @param string A string that contains a floating-point number.\n */\ndeclare function parseFloat(string: string): number;\n\n/**\n * Returns a Boolean value that indicates whether a value is the reserved value NaN (not a number).\n * @param number A numeric value.\n */\ndeclare function isNaN(number: number): boolean;\n\n/**\n * Determines whether a supplied number is finite.\n * @param number Any numeric value.\n */\ndeclare function isFinite(number: number): boolean;\n\n/**\n * Gets the unencoded version of an encoded Uniform Resource Identifier (URI).\n * @param encodedURI A value representing an encoded URI.\n */\ndeclare function decodeURI(encodedURI: string): string;\n\n/**\n * Gets the unencoded version of an encoded component of a Uniform Resource Identifier (URI).\n * @param encodedURIComponent A value representing an encoded URI component.\n */\ndeclare function decodeURIComponent(encodedURIComponent: string): string;\n\n/**\n * Encodes a text string as a valid Uniform Resource Identifier (URI)\n * @param uri A value representing an unencoded URI.\n */\ndeclare function encodeURI(uri: string): string;\n\n/**\n * Encodes a text string as a valid component of a Uniform Resource Identifier (URI).\n * @param uriComponent A value representing an unencoded URI component.\n */\ndeclare function encodeURIComponent(uriComponent: string | number | boolean): string;\n\n/**\n * Computes a new string in which certain characters have been replaced by a hexadecimal escape sequence.\n * @deprecated A legacy feature for browser compatibility\n * @param string A string value\n */\ndeclare function escape(string: string): string;\n\n/**\n * Computes a new string in which hexadecimal escape sequences are replaced with the character that it represents.\n * @deprecated A legacy feature for browser compatibility\n * @param string A string value\n */\ndeclare function unescape(string: string): string;\n\ninterface Symbol {\n    /** Returns a string representation of an object. */\n    toString(): string;\n\n    /** Returns the primitive value of the specified object. */\n    valueOf(): symbol;\n}\n\ndeclare type PropertyKey = string | number | symbol;\n\ninterface PropertyDescriptor {\n    configurable?: boolean;\n    enumerable?: boolean;\n    value?: any;\n    writable?: boolean;\n    get?(): any;\n    set?(v: any): void;\n}\n\ninterface PropertyDescriptorMap {\n    [key: PropertyKey]: PropertyDescriptor;\n}\n\ninterface Object {\n    /** The initial value of Object.prototype.constructor is the standard built-in Object constructor. */\n    constructor: Function;\n\n    /** Returns a string representation of an object. */\n    toString(): string;\n\n    /** Returns a date converted to a string using the current locale. */\n    toLocaleString(): string;\n\n    /** Returns the primitive value of the specified object. */\n    valueOf(): Object;\n\n    /**\n     * Determines whether an object has a property with the specified name.\n     * @param v A property name.\n     */\n    hasOwnProperty(v: PropertyKey): boolean;\n\n    /**\n     * Determines whether an object exists in another object\'s prototype chain.\n     * @param v Another object whose prototype chain is to be checked.\n     */\n    isPrototypeOf(v: Object): boolean;\n\n    /**\n     * Determines whether a specified property is enumerable.\n     * @param v A property name.\n     */\n    propertyIsEnumerable(v: PropertyKey): boolean;\n}\n\ninterface ObjectConstructor {\n    new(value?: any): Object;\n    (): any;\n    (value: any): any;\n\n    /** A reference to the prototype for a class of objects. */\n    readonly prototype: Object;\n\n    /**\n     * Returns the prototype of an object.\n     * @param o The object that references the prototype.\n     */\n    getPrototypeOf(o: any): any;\n\n    /**\n     * Gets the own property descriptor of the specified object.\n     * An own property descriptor is one that is defined directly on the object and is not inherited from the object\'s prototype.\n     * @param o Object that contains the property.\n     * @param p Name of the property.\n     */\n    getOwnPropertyDescriptor(o: any, p: PropertyKey): PropertyDescriptor | undefined;\n\n    /**\n     * Returns the names of the own properties of an object. The own properties of an object are those that are defined directly\n     * on that object, and are not inherited from the object\'s prototype. The properties of an object include both fields (objects) and functions.\n     * @param o Object that contains the own properties.\n     */\n    getOwnPropertyNames(o: any): string[];\n\n    /**\n     * Creates an object that has the specified prototype or that has null prototype.\n     * @param o Object to use as a prototype. May be null.\n     */\n    create(o: object | null): any;\n\n    /**\n     * Creates an object that has the specified prototype, and that optionally contains specified properties.\n     * @param o Object to use as a prototype. May be null\n     * @param properties JavaScript object that contains one or more property descriptors.\n     */\n    create(o: object | null, properties: PropertyDescriptorMap & ThisType<any>): any;\n\n    /**\n     * Adds a property to an object, or modifies attributes of an existing property.\n     * @param o Object on which to add or modify the property. This can be a native JavaScript object (that is, a user-defined object or a built in object) or a DOM object.\n     * @param p The property name.\n     * @param attributes Descriptor for the property. It can be for a data property or an accessor property.\n     */\n    defineProperty<T>(o: T, p: PropertyKey, attributes: PropertyDescriptor & ThisType<any>): T;\n\n    /**\n     * Adds one or more properties to an object, and/or modifies attributes of existing properties.\n     * @param o Object on which to add or modify the properties. This can be a native JavaScript object or a DOM object.\n     * @param properties JavaScript object that contains one or more descriptor objects. Each descriptor object describes a data property or an accessor property.\n     */\n    defineProperties<T>(o: T, properties: PropertyDescriptorMap & ThisType<any>): T;\n\n    /**\n     * Prevents the modification of attributes of existing properties, and prevents the addition of new properties.\n     * @param o Object on which to lock the attributes.\n     */\n    seal<T>(o: T): T;\n\n    /**\n     * Prevents the modification of existing property attributes and values, and prevents the addition of new properties.\n     * @param f Object on which to lock the attributes.\n     */\n    freeze<T extends Function>(f: T): T;\n\n    /**\n     * Prevents the modification of existing property attributes and values, and prevents the addition of new properties.\n     * @param o Object on which to lock the attributes.\n     */\n    freeze<T extends {[idx: string]: U | null | undefined | object}, U extends string | bigint | number | boolean | symbol>(o: T): Readonly<T>;\n\n    /**\n     * Prevents the modification of existing property attributes and values, and prevents the addition of new properties.\n     * @param o Object on which to lock the attributes.\n     */\n    freeze<T>(o: T): Readonly<T>;\n\n    /**\n     * Prevents the addition of new properties to an object.\n     * @param o Object to make non-extensible.\n     */\n    preventExtensions<T>(o: T): T;\n\n    /**\n     * Returns true if existing property attributes cannot be modified in an object and new properties cannot be added to the object.\n     * @param o Object to test.\n     */\n    isSealed(o: any): boolean;\n\n    /**\n     * Returns true if existing property attributes and values cannot be modified in an object, and new properties cannot be added to the object.\n     * @param o Object to test.\n     */\n    isFrozen(o: any): boolean;\n\n    /**\n     * Returns a value that indicates whether new properties can be added to an object.\n     * @param o Object to test.\n     */\n    isExtensible(o: any): boolean;\n\n    /**\n     * Returns the names of the enumerable string properties and methods of an object.\n     * @param o Object that contains the properties and methods. This can be an object that you created or an existing Document Object Model (DOM) object.\n     */\n    keys(o: object): string[];\n}\n\n/**\n * Provides functionality common to all JavaScript objects.\n */\ndeclare var Object: ObjectConstructor;\n\n/**\n * Creates a new function.\n */\ninterface Function {\n    /**\n     * Calls the function, substituting the specified object for the this value of the function, and the specified array for the arguments of the function.\n     * @param thisArg The object to be used as the this object.\n     * @param argArray A set of arguments to be passed to the function.\n     */\n    apply(this: Function, thisArg: any, argArray?: any): any;\n\n    /**\n     * Calls a method of an object, substituting another object for the current object.\n     * @param thisArg The object to be used as the current object.\n     * @param argArray A list of arguments to be passed to the method.\n     */\n    call(this: Function, thisArg: any, ...argArray: any[]): any;\n\n    /**\n     * For a given function, creates a bound function that has the same body as the original function.\n     * The this object of the bound function is associated with the specified object, and has the specified initial parameters.\n     * @param thisArg An object to which the this keyword can refer inside the new function.\n     * @param argArray A list of arguments to be passed to the new function.\n     */\n    bind(this: Function, thisArg: any, ...argArray: any[]): any;\n\n    /** Returns a string representation of a function. */\n    toString(): string;\n\n    prototype: any;\n    readonly length: number;\n\n    // Non-standard extensions\n    arguments: any;\n    caller: Function;\n}\n\ninterface FunctionConstructor {\n    /**\n     * Creates a new function.\n     * @param args A list of arguments the function accepts.\n     */\n    new(...args: string[]): Function;\n    (...args: string[]): Function;\n    readonly prototype: Function;\n}\n\ndeclare var Function: FunctionConstructor;\n\n/**\n * Extracts the type of the \'this\' parameter of a function type, or \'unknown\' if the function type has no \'this\' parameter.\n */\ntype ThisParameterType<T> = T extends (this: infer U, ...args: never) => any ? U : unknown;\n\n/**\n * Removes the \'this\' parameter from a function type.\n */\ntype OmitThisParameter<T> = unknown extends ThisParameterType<T> ? T : T extends (...args: infer A) => infer R ? (...args: A) => R : T;\n\ninterface CallableFunction extends Function {\n    /**\n     * Calls the function with the specified object as the this value and the elements of specified array as the arguments.\n     * @param thisArg The object to be used as the this object.\n     */\n    apply<T, R>(this: (this: T) => R, thisArg: T): R;\n\n    /**\n     * Calls the function with the specified object as the this value and the elements of specified array as the arguments.\n     * @param thisArg The object to be used as the this object.\n     * @param args An array of argument values to be passed to the function.\n     */\n    apply<T, A extends any[], R>(this: (this: T, ...args: A) => R, thisArg: T, args: A): R;\n\n    /**\n     * Calls the function with the specified object as the this value and the specified rest arguments as the arguments.\n     * @param thisArg The object to be used as the this object.\n     * @param args Argument values to be passed to the function.\n     */\n    call<T, A extends any[], R>(this: (this: T, ...args: A) => R, thisArg: T, ...args: A): R;\n\n    /**\n     * For a given function, creates a bound function that has the same body as the original function.\n     * The this object of the bound function is associated with the specified object, and has the specified initial parameters.\n     * @param thisArg The object to be used as the this object.\n     */\n    bind<T>(this: T, thisArg: ThisParameterType<T>): OmitThisParameter<T>;\n\n    /**\n     * For a given function, creates a bound function that has the same body as the original function.\n     * The this object of the bound function is associated with the specified object, and has the specified initial parameters.\n     * @param thisArg The object to be used as the this object.\n     * @param args Arguments to bind to the parameters of the function.\n     */\n    bind<T, A extends any[], B extends any[], R>(this: (this: T, ...args: [...A, ...B]) => R, thisArg: T, ...args: A): (...args: B) => R;\n}\n\ninterface NewableFunction extends Function {\n    /**\n     * Calls the function with the specified object as the this value and the elements of specified array as the arguments.\n     * @param thisArg The object to be used as the this object.\n     */\n    apply<T>(this: new () => T, thisArg: T): void;\n    /**\n     * Calls the function with the specified object as the this value and the elements of specified array as the arguments.\n     * @param thisArg The object to be used as the this object.\n     * @param args An array of argument values to be passed to the function.\n     */\n    apply<T, A extends any[]>(this: new (...args: A) => T, thisArg: T, args: A): void;\n\n    /**\n     * Calls the function with the specified object as the this value and the specified rest arguments as the arguments.\n     * @param thisArg The object to be used as the this object.\n     * @param args Argument values to be passed to the function.\n     */\n    call<T, A extends any[]>(this: new (...args: A) => T, thisArg: T, ...args: A): void;\n\n    /**\n     * For a given function, creates a bound function that has the same body as the original function.\n     * The this object of the bound function is associated with the specified object, and has the specified initial parameters.\n     * @param thisArg The object to be used as the this object.\n     */\n    bind<T>(this: T, thisArg: any): T;\n\n    /**\n     * For a given function, creates a bound function that has the same body as the original function.\n     * The this object of the bound function is associated with the specified object, and has the specified initial parameters.\n     * @param thisArg The object to be used as the this object.\n     * @param args Arguments to bind to the parameters of the function.\n     */\n    bind<A extends any[], B extends any[], R>(this: new (...args: [...A, ...B]) => R, thisArg: any, ...args: A): new (...args: B) => R;\n}\n\ninterface IArguments {\n    [index: number]: any;\n    length: number;\n    callee: Function;\n}\n\ninterface String {\n    /** Returns a string representation of a string. */\n    toString(): string;\n\n    /**\n     * Returns the character at the specified index.\n     * @param pos The zero-based index of the desired character.\n     */\n    charAt(pos: number): string;\n\n    /**\n     * Returns the Unicode value of the character at the specified location.\n     * @param index The zero-based index of the desired character. If there is no character at the specified index, NaN is returned.\n     */\n    charCodeAt(index: number): number;\n\n    /**\n     * Returns a string that contains the concatenation of two or more strings.\n     * @param strings The strings to append to the end of the string.\n     */\n    concat(...strings: string[]): string;\n\n    /**\n     * Returns the position of the first occurrence of a substring.\n     * @param searchString The substring to search for in the string\n     * @param position The index at which to begin searching the String object. If omitted, search starts at the beginning of the string.\n     */\n    indexOf(searchString: string, position?: number): number;\n\n    /**\n     * Returns the last occurrence of a substring in the string.\n     * @param searchString The substring to search for.\n     * @param position The index at which to begin searching. If omitted, the search begins at the end of the string.\n     */\n    lastIndexOf(searchString: string, position?: number): number;\n\n    /**\n     * Determines whether two strings are equivalent in the current locale.\n     * @param that String to compare to target string\n     */\n    localeCompare(that: string): number;\n\n    /**\n     * Matches a string with a regular expression, and returns an array containing the results of that search.\n     * @param regexp A variable name or string literal containing the regular expression pattern and flags.\n     */\n    match(regexp: string | RegExp): RegExpMatchArray | null;\n\n    /**\n     * Replaces text in a string, using a regular expression or search string.\n     * @param searchValue A string or regular expression to search for.\n     * @param replaceValue A string containing the text to replace. When the {@linkcode searchValue} is a `RegExp`, all matches are replaced if the `g` flag is set (or only those matches at the beginning, if the `y` flag is also present). Otherwise, only the first match of {@linkcode searchValue} is replaced.\n     */\n    replace(searchValue: string | RegExp, replaceValue: string): string;\n\n    /**\n     * Replaces text in a string, using a regular expression or search string.\n     * @param searchValue A string to search for.\n     * @param replacer A function that returns the replacement text.\n     */\n    replace(searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string;\n\n    /**\n     * Finds the first substring match in a regular expression search.\n     * @param regexp The regular expression pattern and applicable flags.\n     */\n    search(regexp: string | RegExp): number;\n\n    /**\n     * Returns a section of a string.\n     * @param start The index to the beginning of the specified portion of stringObj.\n     * @param end The index to the end of the specified portion of stringObj. The substring includes the characters up to, but not including, the character indicated by end.\n     * If this value is not specified, the substring continues to the end of stringObj.\n     */\n    slice(start?: number, end?: number): string;\n\n    /**\n     * Split a string into substrings using the specified separator and return them as an array.\n     * @param separator A string that identifies character or characters to use in separating the string. If omitted, a single-element array containing the entire string is returned.\n     * @param limit A value used to limit the number of elements returned in the array.\n     */\n    split(separator: string | RegExp, limit?: number): string[];\n\n    /**\n     * Returns the substring at the specified location within a String object.\n     * @param start The zero-based index number indicating the beginning of the substring.\n     * @param end Zero-based index number indicating the end of the substring. The substring includes the characters up to, but not including, the character indicated by end.\n     * If end is omitted, the characters from start through the end of the original string are returned.\n     */\n    substring(start: number, end?: number): string;\n\n    /** Converts all the alphabetic characters in a string to lowercase. */\n    toLowerCase(): string;\n\n    /** Converts all alphabetic characters to lowercase, taking into account the host environment\'s current locale. */\n    toLocaleLowerCase(locales?: string | string[]): string;\n\n    /** Converts all the alphabetic characters in a string to uppercase. */\n    toUpperCase(): string;\n\n    /** Returns a string where all alphabetic characters have been converted to uppercase, taking into account the host environment\'s current locale. */\n    toLocaleUpperCase(locales?: string | string[]): string;\n\n    /** Removes the leading and trailing white space and line terminator characters from a string. */\n    trim(): string;\n\n    /** Returns the length of a String object. */\n    readonly length: number;\n\n    // IE extensions\n    /**\n     * Gets a substring beginning at the specified location and having the specified length.\n     * @deprecated A legacy feature for browser compatibility\n     * @param from The starting position of the desired substring. The index of the first character in the string is zero.\n     * @param length The number of characters to include in the returned substring.\n     */\n    substr(from: number, length?: number): string;\n\n    /** Returns the primitive value of the specified object. */\n    valueOf(): string;\n\n    readonly [index: number]: string;\n}\n\ninterface StringConstructor {\n    new(value?: any): String;\n    (value?: any): string;\n    readonly prototype: String;\n    fromCharCode(...codes: number[]): string;\n}\n\n/**\n * Allows manipulation and formatting of text strings and determination and location of substrings within strings.\n */\ndeclare var String: StringConstructor;\n\ninterface Boolean {\n    /** Returns the primitive value of the specified object. */\n    valueOf(): boolean;\n}\n\ninterface BooleanConstructor {\n    new(value?: any): Boolean;\n    <T>(value?: T): boolean;\n    readonly prototype: Boolean;\n}\n\ndeclare var Boolean: BooleanConstructor;\n\ninterface Number {\n    /**\n     * Returns a string representation of an object.\n     * @param radix Specifies a radix for converting numeric values to strings. This value is only used for numbers.\n     */\n    toString(radix?: number): string;\n\n    /**\n     * Returns a string representing a number in fixed-point notation.\n     * @param fractionDigits Number of digits after the decimal point. Must be in the range 0 - 20, inclusive.\n     */\n    toFixed(fractionDigits?: number): string;\n\n    /**\n     * Returns a string containing a number represented in exponential notation.\n     * @param fractionDigits Number of digits after the decimal point. Must be in the range 0 - 20, inclusive.\n     */\n    toExponential(fractionDigits?: number): string;\n\n    /**\n     * Returns a string containing a number represented either in exponential or fixed-point notation with a specified number of digits.\n     * @param precision Number of significant digits. Must be in the range 1 - 21, inclusive.\n     */\n    toPrecision(precision?: number): string;\n\n    /** Returns the primitive value of the specified object. */\n    valueOf(): number;\n}\n\ninterface NumberConstructor {\n    new(value?: any): Number;\n    (value?: any): number;\n    readonly prototype: Number;\n\n    /** The largest number that can be represented in JavaScript. Equal to approximately 1.79E+308. */\n    readonly MAX_VALUE: number;\n\n    /** The closest number to zero that can be represented in JavaScript. Equal to approximately 5.00E-324. */\n    readonly MIN_VALUE: number;\n\n    /**\n     * A value that is not a number.\n     * In equality comparisons, NaN does not equal any value, including itself. To test whether a value is equivalent to NaN, use the isNaN function.\n     */\n    readonly NaN: number;\n\n    /**\n     * A value that is less than the largest negative number that can be represented in JavaScript.\n     * JavaScript displays NEGATIVE_INFINITY values as -infinity.\n     */\n    readonly NEGATIVE_INFINITY: number;\n\n    /**\n     * A value greater than the largest number that can be represented in JavaScript.\n     * JavaScript displays POSITIVE_INFINITY values as infinity.\n     */\n    readonly POSITIVE_INFINITY: number;\n}\n\n/** An object that represents a number of any kind. All JavaScript numbers are 64-bit floating-point numbers. */\ndeclare var Number: NumberConstructor;\n\ninterface TemplateStringsArray extends ReadonlyArray<string> {\n    readonly raw: readonly string[];\n}\n\n/**\n * The type of `import.meta`.\n *\n * If you need to declare that a given property exists on `import.meta`,\n * this type may be augmented via interface merging.\n */\ninterface ImportMeta {\n}\n\n/**\n * The type for the optional second argument to `import()`.\n *\n * If your host environment supports additional options, this type may be\n * augmented via interface merging.\n */\ninterface ImportCallOptions {\n    assert?: ImportAssertions;\n}\n\n/**\n * The type for the `assert` property of the optional second argument to `import()`.\n */\ninterface ImportAssertions {\n    [key: string]: string;\n}\n\ninterface Math {\n    /** The mathematical constant e. This is Euler\'s number, the base of natural logarithms. */\n    readonly E: number;\n    /** The natural logarithm of 10. */\n    readonly LN10: number;\n    /** The natural logarithm of 2. */\n    readonly LN2: number;\n    /** The base-2 logarithm of e. */\n    readonly LOG2E: number;\n    /** The base-10 logarithm of e. */\n    readonly LOG10E: number;\n    /** Pi. This is the ratio of the circumference of a circle to its diameter. */\n    readonly PI: number;\n    /** The square root of 0.5, or, equivalently, one divided by the square root of 2. */\n    readonly SQRT1_2: number;\n    /** The square root of 2. */\n    readonly SQRT2: number;\n    /**\n     * Returns the absolute value of a number (the value without regard to whether it is positive or negative).\n     * For example, the absolute value of -5 is the same as the absolute value of 5.\n     * @param x A numeric expression for which the absolute value is needed.\n     */\n    abs(x: number): number;\n    /**\n     * Returns the arc cosine (or inverse cosine) of a number.\n     * @param x A numeric expression.\n     */\n    acos(x: number): number;\n    /**\n     * Returns the arcsine of a number.\n     * @param x A numeric expression.\n     */\n    asin(x: number): number;\n    /**\n     * Returns the arctangent of a number.\n     * @param x A numeric expression for which the arctangent is needed.\n     */\n    atan(x: number): number;\n    /**\n     * Returns the angle (in radians) from the X axis to a point.\n     * @param y A numeric expression representing the cartesian y-coordinate.\n     * @param x A numeric expression representing the cartesian x-coordinate.\n     */\n    atan2(y: number, x: number): number;\n    /**\n     * Returns the smallest integer greater than or equal to its numeric argument.\n     * @param x A numeric expression.\n     */\n    ceil(x: number): number;\n    /**\n     * Returns the cosine of a number.\n     * @param x A numeric expression that contains an angle measured in radians.\n     */\n    cos(x: number): number;\n    /**\n     * Returns e (the base of natural logarithms) raised to a power.\n     * @param x A numeric expression representing the power of e.\n     */\n    exp(x: number): number;\n    /**\n     * Returns the greatest integer less than or equal to its numeric argument.\n     * @param x A numeric expression.\n     */\n    floor(x: number): number;\n    /**\n     * Returns the natural logarithm (base e) of a number.\n     * @param x A numeric expression.\n     */\n    log(x: number): number;\n    /**\n     * Returns the larger of a set of supplied numeric expressions.\n     * @param values Numeric expressions to be evaluated.\n     */\n    max(...values: number[]): number;\n    /**\n     * Returns the smaller of a set of supplied numeric expressions.\n     * @param values Numeric expressions to be evaluated.\n     */\n    min(...values: number[]): number;\n    /**\n     * Returns the value of a base expression taken to a specified power.\n     * @param x The base value of the expression.\n     * @param y The exponent value of the expression.\n     */\n    pow(x: number, y: number): number;\n    /** Returns a pseudorandom number between 0 and 1. */\n    random(): number;\n    /**\n     * Returns a supplied numeric expression rounded to the nearest integer.\n     * @param x The value to be rounded to the nearest integer.\n     */\n    round(x: number): number;\n    /**\n     * Returns the sine of a number.\n     * @param x A numeric expression that contains an angle measured in radians.\n     */\n    sin(x: number): number;\n    /**\n     * Returns the square root of a number.\n     * @param x A numeric expression.\n     */\n    sqrt(x: number): number;\n    /**\n     * Returns the tangent of a number.\n     * @param x A numeric expression that contains an angle measured in radians.\n     */\n    tan(x: number): number;\n}\n/** An intrinsic object that provides basic mathematics functionality and constants. */\ndeclare var Math: Math;\n\n/** Enables basic storage and retrieval of dates and times. */\ninterface Date {\n    /** Returns a string representation of a date. The format of the string depends on the locale. */\n    toString(): string;\n    /** Returns a date as a string value. */\n    toDateString(): string;\n    /** Returns a time as a string value. */\n    toTimeString(): string;\n    /** Returns a value as a string value appropriate to the host environment\'s current locale. */\n    toLocaleString(): string;\n    /** Returns a date as a string value appropriate to the host environment\'s current locale. */\n    toLocaleDateString(): string;\n    /** Returns a time as a string value appropriate to the host environment\'s current locale. */\n    toLocaleTimeString(): string;\n    /** Returns the stored time value in milliseconds since midnight, January 1, 1970 UTC. */\n    valueOf(): number;\n    /** Returns the stored time value in milliseconds since midnight, January 1, 1970 UTC. */\n    getTime(): number;\n    /** Gets the year, using local time. */\n    getFullYear(): number;\n    /** Gets the year using Universal Coordinated Time (UTC). */\n    getUTCFullYear(): number;\n    /** Gets the month, using local time. */\n    getMonth(): number;\n    /** Gets the month of a Date object using Universal Coordinated Time (UTC). */\n    getUTCMonth(): number;\n    /** Gets the day-of-the-month, using local time. */\n    getDate(): number;\n    /** Gets the day-of-the-month, using Universal Coordinated Time (UTC). */\n    getUTCDate(): number;\n    /** Gets the day of the week, using local time. */\n    getDay(): number;\n    /** Gets the day of the week using Universal Coordinated Time (UTC). */\n    getUTCDay(): number;\n    /** Gets the hours in a date, using local time. */\n    getHours(): number;\n    /** Gets the hours value in a Date object using Universal Coordinated Time (UTC). */\n    getUTCHours(): number;\n    /** Gets the minutes of a Date object, using local time. */\n    getMinutes(): number;\n    /** Gets the minutes of a Date object using Universal Coordinated Time (UTC). */\n    getUTCMinutes(): number;\n    /** Gets the seconds of a Date object, using local time. */\n    getSeconds(): number;\n    /** Gets the seconds of a Date object using Universal Coordinated Time (UTC). */\n    getUTCSeconds(): number;\n    /** Gets the milliseconds of a Date, using local time. */\n    getMilliseconds(): number;\n    /** Gets the milliseconds of a Date object using Universal Coordinated Time (UTC). */\n    getUTCMilliseconds(): number;\n    /** Gets the difference in minutes between the time on the local computer and Universal Coordinated Time (UTC). */\n    getTimezoneOffset(): number;\n    /**\n     * Sets the date and time value in the Date object.\n     * @param time A numeric value representing the number of elapsed milliseconds since midnight, January 1, 1970 GMT.\n     */\n    setTime(time: number): number;\n    /**\n     * Sets the milliseconds value in the Date object using local time.\n     * @param ms A numeric value equal to the millisecond value.\n     */\n    setMilliseconds(ms: number): number;\n    /**\n     * Sets the milliseconds value in the Date object using Universal Coordinated Time (UTC).\n     * @param ms A numeric value equal to the millisecond value.\n     */\n    setUTCMilliseconds(ms: number): number;\n\n    /**\n     * Sets the seconds value in the Date object using local time.\n     * @param sec A numeric value equal to the seconds value.\n     * @param ms A numeric value equal to the milliseconds value.\n     */\n    setSeconds(sec: number, ms?: number): number;\n    /**\n     * Sets the seconds value in the Date object using Universal Coordinated Time (UTC).\n     * @param sec A numeric value equal to the seconds value.\n     * @param ms A numeric value equal to the milliseconds value.\n     */\n    setUTCSeconds(sec: number, ms?: number): number;\n    /**\n     * Sets the minutes value in the Date object using local time.\n     * @param min A numeric value equal to the minutes value.\n     * @param sec A numeric value equal to the seconds value.\n     * @param ms A numeric value equal to the milliseconds value.\n     */\n    setMinutes(min: number, sec?: number, ms?: number): number;\n    /**\n     * Sets the minutes value in the Date object using Universal Coordinated Time (UTC).\n     * @param min A numeric value equal to the minutes value.\n     * @param sec A numeric value equal to the seconds value.\n     * @param ms A numeric value equal to the milliseconds value.\n     */\n    setUTCMinutes(min: number, sec?: number, ms?: number): number;\n    /**\n     * Sets the hour value in the Date object using local time.\n     * @param hours A numeric value equal to the hours value.\n     * @param min A numeric value equal to the minutes value.\n     * @param sec A numeric value equal to the seconds value.\n     * @param ms A numeric value equal to the milliseconds value.\n     */\n    setHours(hours: number, min?: number, sec?: number, ms?: number): number;\n    /**\n     * Sets the hours value in the Date object using Universal Coordinated Time (UTC).\n     * @param hours A numeric value equal to the hours value.\n     * @param min A numeric value equal to the minutes value.\n     * @param sec A numeric value equal to the seconds value.\n     * @param ms A numeric value equal to the milliseconds value.\n     */\n    setUTCHours(hours: number, min?: number, sec?: number, ms?: number): number;\n    /**\n     * Sets the numeric day-of-the-month value of the Date object using local time.\n     * @param date A numeric value equal to the day of the month.\n     */\n    setDate(date: number): number;\n    /**\n     * Sets the numeric day of the month in the Date object using Universal Coordinated Time (UTC).\n     * @param date A numeric value equal to the day of the month.\n     */\n    setUTCDate(date: number): number;\n    /**\n     * Sets the month value in the Date object using local time.\n     * @param month A numeric value equal to the month. The value for January is 0, and other month values follow consecutively.\n     * @param date A numeric value representing the day of the month. If this value is not supplied, the value from a call to the getDate method is used.\n     */\n    setMonth(month: number, date?: number): number;\n    /**\n     * Sets the month value in the Date object using Universal Coordinated Time (UTC).\n     * @param month A numeric value equal to the month. The value for January is 0, and other month values follow consecutively.\n     * @param date A numeric value representing the day of the month. If it is not supplied, the value from a call to the getUTCDate method is used.\n     */\n    setUTCMonth(month: number, date?: number): number;\n    /**\n     * Sets the year of the Date object using local time.\n     * @param year A numeric value for the year.\n     * @param month A zero-based numeric value for the month (0 for January, 11 for December). Must be specified if numDate is specified.\n     * @param date A numeric value equal for the day of the month.\n     */\n    setFullYear(year: number, month?: number, date?: number): number;\n    /**\n     * Sets the year value in the Date object using Universal Coordinated Time (UTC).\n     * @param year A numeric value equal to the year.\n     * @param month A numeric value equal to the month. The value for January is 0, and other month values follow consecutively. Must be supplied if numDate is supplied.\n     * @param date A numeric value equal to the day of the month.\n     */\n    setUTCFullYear(year: number, month?: number, date?: number): number;\n    /** Returns a date converted to a string using Universal Coordinated Time (UTC). */\n    toUTCString(): string;\n    /** Returns a date as a string value in ISO format. */\n    toISOString(): string;\n    /** Used by the JSON.stringify method to enable the transformation of an object\'s data for JavaScript Object Notation (JSON) serialization. */\n    toJSON(key?: any): string;\n}\n\ninterface DateConstructor {\n    new(): Date;\n    new(value: number | string): Date;\n    /**\n     * Creates a new Date.\n     * @param year The full year designation is required for cross-century date accuracy. If year is between 0 and 99 is used, then year is assumed to be 1900 + year.\n     * @param monthIndex The month as a number between 0 and 11 (January to December).\n     * @param date The date as a number between 1 and 31.\n     * @param hours Must be supplied if minutes is supplied. A number from 0 to 23 (midnight to 11pm) that specifies the hour.\n     * @param minutes Must be supplied if seconds is supplied. A number from 0 to 59 that specifies the minutes.\n     * @param seconds Must be supplied if milliseconds is supplied. A number from 0 to 59 that specifies the seconds.\n     * @param ms A number from 0 to 999 that specifies the milliseconds.\n     */\n    new(year: number, monthIndex: number, date?: number, hours?: number, minutes?: number, seconds?: number, ms?: number): Date;\n    (): string;\n    readonly prototype: Date;\n    /**\n     * Parses a string containing a date, and returns the number of milliseconds between that date and midnight, January 1, 1970.\n     * @param s A date string\n     */\n    parse(s: string): number;\n    /**\n     * Returns the number of milliseconds between midnight, January 1, 1970 Universal Coordinated Time (UTC) (or GMT) and the specified date.\n     * @param year The full year designation is required for cross-century date accuracy. If year is between 0 and 99 is used, then year is assumed to be 1900 + year.\n     * @param monthIndex The month as a number between 0 and 11 (January to December).\n     * @param date The date as a number between 1 and 31.\n     * @param hours Must be supplied if minutes is supplied. A number from 0 to 23 (midnight to 11pm) that specifies the hour.\n     * @param minutes Must be supplied if seconds is supplied. A number from 0 to 59 that specifies the minutes.\n     * @param seconds Must be supplied if milliseconds is supplied. A number from 0 to 59 that specifies the seconds.\n     * @param ms A number from 0 to 999 that specifies the milliseconds.\n     */\n    UTC(year: number, monthIndex: number, date?: number, hours?: number, minutes?: number, seconds?: number, ms?: number): number;\n    /** Returns the number of milliseconds elapsed since midnight, January 1, 1970 Universal Coordinated Time (UTC). */\n    now(): number;\n}\n\ndeclare var Date: DateConstructor;\n\ninterface RegExpMatchArray extends Array<string> {\n    /**\n     * The index of the search at which the result was found.\n     */\n    index?: number;\n    /**\n     * A copy of the search string.\n     */\n    input?: string;\n    /**\n     * The first match. This will always be present because `null` will be returned if there are no matches.\n     */\n    0: string;\n}\n\ninterface RegExpExecArray extends Array<string> {\n    /**\n     * The index of the search at which the result was found.\n     */\n    index: number;\n    /**\n     * A copy of the search string.\n     */\n    input: string;\n    /**\n     * The first match. This will always be present because `null` will be returned if there are no matches.\n     */\n    0: string;\n}\n\ninterface RegExp {\n    /**\n     * Executes a search on a string using a regular expression pattern, and returns an array containing the results of that search.\n     * @param string The String object or string literal on which to perform the search.\n     */\n    exec(string: string): RegExpExecArray | null;\n\n    /**\n     * Returns a Boolean value that indicates whether or not a pattern exists in a searched string.\n     * @param string String on which to perform the search.\n     */\n    test(string: string): boolean;\n\n    /** Returns a copy of the text of the regular expression pattern. Read-only. The regExp argument is a Regular expression object. It can be a variable name or a literal. */\n    readonly source: string;\n\n    /** Returns a Boolean value indicating the state of the global flag (g) used with a regular expression. Default is false. Read-only. */\n    readonly global: boolean;\n\n    /** Returns a Boolean value indicating the state of the ignoreCase flag (i) used with a regular expression. Default is false. Read-only. */\n    readonly ignoreCase: boolean;\n\n    /** Returns a Boolean value indicating the state of the multiline flag (m) used with a regular expression. Default is false. Read-only. */\n    readonly multiline: boolean;\n\n    lastIndex: number;\n\n    // Non-standard extensions\n    /** @deprecated A legacy feature for browser compatibility */\n    compile(pattern: string, flags?: string): this;\n}\n\ninterface RegExpConstructor {\n    new(pattern: RegExp | string): RegExp;\n    new(pattern: string, flags?: string): RegExp;\n    (pattern: RegExp | string): RegExp;\n    (pattern: string, flags?: string): RegExp;\n    readonly prototype: RegExp;\n\n    // Non-standard extensions\n    /** @deprecated A legacy feature for browser compatibility */\n    $1: string;\n    /** @deprecated A legacy feature for browser compatibility */\n    $2: string;\n    /** @deprecated A legacy feature for browser compatibility */\n    $3: string;\n    /** @deprecated A legacy feature for browser compatibility */\n    $4: string;\n    /** @deprecated A legacy feature for browser compatibility */\n    $5: string;\n    /** @deprecated A legacy feature for browser compatibility */\n    $6: string;\n    /** @deprecated A legacy feature for browser compatibility */\n    $7: string;\n    /** @deprecated A legacy feature for browser compatibility */\n    $8: string;\n    /** @deprecated A legacy feature for browser compatibility */\n    $9: string;\n    /** @deprecated A legacy feature for browser compatibility */\n    input: string;\n    /** @deprecated A legacy feature for browser compatibility */\n    $_: string;\n    /** @deprecated A legacy feature for browser compatibility */\n    lastMatch: string;\n    /** @deprecated A legacy feature for browser compatibility */\n    "$&": string;\n    /** @deprecated A legacy feature for browser compatibility */\n    lastParen: string;\n    /** @deprecated A legacy feature for browser compatibility */\n    "$+": string;\n    /** @deprecated A legacy feature for browser compatibility */\n    leftContext: string;\n    /** @deprecated A legacy feature for browser compatibility */\n    "$`": string;\n    /** @deprecated A legacy feature for browser compatibility */\n    rightContext: string;\n    /** @deprecated A legacy feature for browser compatibility */\n    "$\'": string;\n}\n\ndeclare var RegExp: RegExpConstructor;\n\ninterface Error {\n    name: string;\n    message: string;\n    stack?: string;\n}\n\ninterface ErrorConstructor {\n    new(message?: string): Error;\n    (message?: string): Error;\n    readonly prototype: Error;\n}\n\ndeclare var Error: ErrorConstructor;\n\ninterface EvalError extends Error {\n}\n\ninterface EvalErrorConstructor extends ErrorConstructor {\n    new(message?: string): EvalError;\n    (message?: string): EvalError;\n    readonly prototype: EvalError;\n}\n\ndeclare var EvalError: EvalErrorConstructor;\n\ninterface RangeError extends Error {\n}\n\ninterface RangeErrorConstructor extends ErrorConstructor {\n    new(message?: string): RangeError;\n    (message?: string): RangeError;\n    readonly prototype: RangeError;\n}\n\ndeclare var RangeError: RangeErrorConstructor;\n\ninterface ReferenceError extends Error {\n}\n\ninterface ReferenceErrorConstructor extends ErrorConstructor {\n    new(message?: string): ReferenceError;\n    (message?: string): ReferenceError;\n    readonly prototype: ReferenceError;\n}\n\ndeclare var ReferenceError: ReferenceErrorConstructor;\n\ninterface SyntaxError extends Error {\n}\n\ninterface SyntaxErrorConstructor extends ErrorConstructor {\n    new(message?: string): SyntaxError;\n    (message?: string): SyntaxError;\n    readonly prototype: SyntaxError;\n}\n\ndeclare var SyntaxError: SyntaxErrorConstructor;\n\ninterface TypeError extends Error {\n}\n\ninterface TypeErrorConstructor extends ErrorConstructor {\n    new(message?: string): TypeError;\n    (message?: string): TypeError;\n    readonly prototype: TypeError;\n}\n\ndeclare var TypeError: TypeErrorConstructor;\n\ninterface URIError extends Error {\n}\n\ninterface URIErrorConstructor extends ErrorConstructor {\n    new(message?: string): URIError;\n    (message?: string): URIError;\n    readonly prototype: URIError;\n}\n\ndeclare var URIError: URIErrorConstructor;\n\ninterface JSON {\n    /**\n     * Converts a JavaScript Object Notation (JSON) string into an object.\n     * @param text A valid JSON string.\n     * @param reviver A function that transforms the results. This function is called for each member of the object.\n     * If a member contains nested objects, the nested objects are transformed before the parent object is.\n     */\n    parse(text: string, reviver?: (this: any, key: string, value: any) => any): any;\n    /**\n     * Converts a JavaScript value to a JavaScript Object Notation (JSON) string.\n     * @param value A JavaScript value, usually an object or array, to be converted.\n     * @param replacer A function that transforms the results.\n     * @param space Adds indentation, white space, and line break characters to the return-value JSON text to make it easier to read.\n     */\n    stringify(value: any, replacer?: (this: any, key: string, value: any) => any, space?: string | number): string;\n    /**\n     * Converts a JavaScript value to a JavaScript Object Notation (JSON) string.\n     * @param value A JavaScript value, usually an object or array, to be converted.\n     * @param replacer An array of strings and numbers that acts as an approved list for selecting the object properties that will be stringified.\n     * @param space Adds indentation, white space, and line break characters to the return-value JSON text to make it easier to read.\n     */\n    stringify(value: any, replacer?: (number | string)[] | null, space?: string | number): string;\n}\n\n/**\n * An intrinsic object that provides functions to convert JavaScript values to and from the JavaScript Object Notation (JSON) format.\n */\ndeclare var JSON: JSON;\n\n\n/////////////////////////////\n/// ECMAScript Array API (specially handled by compiler)\n/////////////////////////////\n\ninterface ReadonlyArray<T> {\n    /**\n     * Gets the length of the array. This is a number one higher than the highest element defined in an array.\n     */\n    readonly length: number;\n    /**\n     * Returns a string representation of an array.\n     */\n    toString(): string;\n    /**\n     * Returns a string representation of an array. The elements are converted to string using their toLocaleString methods.\n     */\n    toLocaleString(): string;\n    /**\n     * Combines two or more arrays.\n     * @param items Additional items to add to the end of array1.\n     */\n    concat(...items: ConcatArray<T>[]): T[];\n    /**\n     * Combines two or more arrays.\n     * @param items Additional items to add to the end of array1.\n     */\n    concat(...items: (T | ConcatArray<T>)[]): T[];\n    /**\n     * Adds all the elements of an array separated by the specified separator string.\n     * @param separator A string used to separate one element of an array from the next in the resulting String. If omitted, the array elements are separated with a comma.\n     */\n    join(separator?: string): string;\n    /**\n     * Returns a section of an array.\n     * @param start The beginning of the specified portion of the array.\n     * @param end The end of the specified portion of the array. This is exclusive of the element at the index \'end\'.\n     */\n    slice(start?: number, end?: number): T[];\n    /**\n     * Returns the index of the first occurrence of a value in an array.\n     * @param searchElement The value to locate in the array.\n     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.\n     */\n    indexOf(searchElement: T, fromIndex?: number): number;\n    /**\n     * Returns the index of the last occurrence of a specified value in an array.\n     * @param searchElement The value to locate in the array.\n     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at the last index in the array.\n     */\n    lastIndexOf(searchElement: T, fromIndex?: number): number;\n    /**\n     * Determines whether all the members of an array satisfy the specified test.\n     * @param predicate A function that accepts up to three arguments. The every method calls\n     * the predicate function for each element in the array until the predicate returns a value\n     * which is coercible to the Boolean value false, or until the end of the array.\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    every<S extends T>(predicate: (value: T, index: number, array: readonly T[]) => value is S, thisArg?: any): this is readonly S[];\n    /**\n     * Determines whether all the members of an array satisfy the specified test.\n     * @param predicate A function that accepts up to three arguments. The every method calls\n     * the predicate function for each element in the array until the predicate returns a value\n     * which is coercible to the Boolean value false, or until the end of the array.\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    every(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): boolean;\n    /**\n     * Determines whether the specified callback function returns true for any element of an array.\n     * @param predicate A function that accepts up to three arguments. The some method calls\n     * the predicate function for each element in the array until the predicate returns a value\n     * which is coercible to the Boolean value true, or until the end of the array.\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    some(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): boolean;\n    /**\n     * Performs the specified action for each element in an array.\n     * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.\n     * @param thisArg  An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n     */\n    forEach(callbackfn: (value: T, index: number, array: readonly T[]) => void, thisArg?: any): void;\n    /**\n     * Calls a defined callback function on each element of an array, and returns an array that contains the results.\n     * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n     */\n    map<U>(callbackfn: (value: T, index: number, array: readonly T[]) => U, thisArg?: any): U[];\n    /**\n     * Returns the elements of an array that meet the condition specified in a callback function.\n     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.\n     */\n    filter<S extends T>(predicate: (value: T, index: number, array: readonly T[]) => value is S, thisArg?: any): S[];\n    /**\n     * Returns the elements of an array that meet the condition specified in a callback function.\n     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.\n     */\n    filter(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): T[];\n    /**\n     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\n     */\n    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T): T;\n    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T, initialValue: T): T;\n    /**\n     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\n     */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: readonly T[]) => U, initialValue: U): U;\n    /**\n     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\n     */\n    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T): T;\n    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: readonly T[]) => T, initialValue: T): T;\n    /**\n     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\n     */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: readonly T[]) => U, initialValue: U): U;\n\n    readonly [n: number]: T;\n}\n\ninterface ConcatArray<T> {\n    readonly length: number;\n    readonly [n: number]: T;\n    join(separator?: string): string;\n    slice(start?: number, end?: number): T[];\n}\n\ninterface Array<T> {\n    /**\n     * Gets or sets the length of the array. This is a number one higher than the highest index in the array.\n     */\n    length: number;\n    /**\n     * Returns a string representation of an array.\n     */\n    toString(): string;\n    /**\n     * Returns a string representation of an array. The elements are converted to string using their toLocaleString methods.\n     */\n    toLocaleString(): string;\n    /**\n     * Removes the last element from an array and returns it.\n     * If the array is empty, undefined is returned and the array is not modified.\n     */\n    pop(): T | undefined;\n    /**\n     * Appends new elements to the end of an array, and returns the new length of the array.\n     * @param items New elements to add to the array.\n     */\n    push(...items: T[]): number;\n    /**\n     * Combines two or more arrays.\n     * This method returns a new array without modifying any existing arrays.\n     * @param items Additional arrays and/or items to add to the end of the array.\n     */\n    concat(...items: ConcatArray<T>[]): T[];\n    /**\n     * Combines two or more arrays.\n     * This method returns a new array without modifying any existing arrays.\n     * @param items Additional arrays and/or items to add to the end of the array.\n     */\n    concat(...items: (T | ConcatArray<T>)[]): T[];\n    /**\n     * Adds all the elements of an array into a string, separated by the specified separator string.\n     * @param separator A string used to separate one element of the array from the next in the resulting string. If omitted, the array elements are separated with a comma.\n     */\n    join(separator?: string): string;\n    /**\n     * Reverses the elements in an array in place.\n     * This method mutates the array and returns a reference to the same array.\n     */\n    reverse(): T[];\n    /**\n     * Removes the first element from an array and returns it.\n     * If the array is empty, undefined is returned and the array is not modified.\n     */\n    shift(): T | undefined;\n    /**\n     * Returns a copy of a section of an array.\n     * For both start and end, a negative index can be used to indicate an offset from the end of the array.\n     * For example, -2 refers to the second to last element of the array.\n     * @param start The beginning index of the specified portion of the array.\n     * If start is undefined, then the slice begins at index 0.\n     * @param end The end index of the specified portion of the array. This is exclusive of the element at the index \'end\'.\n     * If end is undefined, then the slice extends to the end of the array.\n     */\n    slice(start?: number, end?: number): T[];\n    /**\n     * Sorts an array in place.\n     * This method mutates the array and returns a reference to the same array.\n     * @param compareFn Function used to determine the order of the elements. It is expected to return\n     * a negative value if the first argument is less than the second argument, zero if they\'re equal, and a positive\n     * value otherwise. If omitted, the elements are sorted in ascending, ASCII character order.\n     * ```ts\n     * [11,2,22,1].sort((a, b) => a - b)\n     * ```\n     */\n    sort(compareFn?: (a: T, b: T) => number): this;\n    /**\n     * Removes elements from an array and, if necessary, inserts new elements in their place, returning the deleted elements.\n     * @param start The zero-based location in the array from which to start removing elements.\n     * @param deleteCount The number of elements to remove.\n     * @returns An array containing the elements that were deleted.\n     */\n    splice(start: number, deleteCount?: number): T[];\n    /**\n     * Removes elements from an array and, if necessary, inserts new elements in their place, returning the deleted elements.\n     * @param start The zero-based location in the array from which to start removing elements.\n     * @param deleteCount The number of elements to remove.\n     * @param items Elements to insert into the array in place of the deleted elements.\n     * @returns An array containing the elements that were deleted.\n     */\n    splice(start: number, deleteCount: number, ...items: T[]): T[];\n    /**\n     * Inserts new elements at the start of an array, and returns the new length of the array.\n     * @param items Elements to insert at the start of the array.\n     */\n    unshift(...items: T[]): number;\n    /**\n     * Returns the index of the first occurrence of a value in an array, or -1 if it is not present.\n     * @param searchElement The value to locate in the array.\n     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.\n     */\n    indexOf(searchElement: T, fromIndex?: number): number;\n    /**\n     * Returns the index of the last occurrence of a specified value in an array, or -1 if it is not present.\n     * @param searchElement The value to locate in the array.\n     * @param fromIndex The array index at which to begin searching backward. If fromIndex is omitted, the search starts at the last index in the array.\n     */\n    lastIndexOf(searchElement: T, fromIndex?: number): number;\n    /**\n     * Determines whether all the members of an array satisfy the specified test.\n     * @param predicate A function that accepts up to three arguments. The every method calls\n     * the predicate function for each element in the array until the predicate returns a value\n     * which is coercible to the Boolean value false, or until the end of the array.\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    every<S extends T>(predicate: (value: T, index: number, array: T[]) => value is S, thisArg?: any): this is S[];\n    /**\n     * Determines whether all the members of an array satisfy the specified test.\n     * @param predicate A function that accepts up to three arguments. The every method calls\n     * the predicate function for each element in the array until the predicate returns a value\n     * which is coercible to the Boolean value false, or until the end of the array.\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    every(predicate: (value: T, index: number, array: T[]) => unknown, thisArg?: any): boolean;\n    /**\n     * Determines whether the specified callback function returns true for any element of an array.\n     * @param predicate A function that accepts up to three arguments. The some method calls\n     * the predicate function for each element in the array until the predicate returns a value\n     * which is coercible to the Boolean value true, or until the end of the array.\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    some(predicate: (value: T, index: number, array: T[]) => unknown, thisArg?: any): boolean;\n    /**\n     * Performs the specified action for each element in an array.\n     * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.\n     * @param thisArg  An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n     */\n    forEach(callbackfn: (value: T, index: number, array: T[]) => void, thisArg?: any): void;\n    /**\n     * Calls a defined callback function on each element of an array, and returns an array that contains the results.\n     * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n     */\n    map<U>(callbackfn: (value: T, index: number, array: T[]) => U, thisArg?: any): U[];\n    /**\n     * Returns the elements of an array that meet the condition specified in a callback function.\n     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.\n     */\n    filter<S extends T>(predicate: (value: T, index: number, array: T[]) => value is S, thisArg?: any): S[];\n    /**\n     * Returns the elements of an array that meet the condition specified in a callback function.\n     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.\n     */\n    filter(predicate: (value: T, index: number, array: T[]) => unknown, thisArg?: any): T[];\n    /**\n     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\n     */\n    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T): T;\n    reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue: T): T;\n    /**\n     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\n     */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U;\n    /**\n     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\n     */\n    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T): T;\n    reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue: T): T;\n    /**\n     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\n     */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U;\n\n    [n: number]: T;\n}\n\ninterface ArrayConstructor {\n    new(arrayLength?: number): any[];\n    new <T>(arrayLength: number): T[];\n    new <T>(...items: T[]): T[];\n    (arrayLength?: number): any[];\n    <T>(arrayLength: number): T[];\n    <T>(...items: T[]): T[];\n    isArray(arg: any): arg is any[];\n    readonly prototype: any[];\n}\n\ndeclare var Array: ArrayConstructor;\n\ninterface TypedPropertyDescriptor<T> {\n    enumerable?: boolean;\n    configurable?: boolean;\n    writable?: boolean;\n    value?: T;\n    get?: () => T;\n    set?: (value: T) => void;\n}\n\ndeclare type PromiseConstructorLike = new <T>(executor: (resolve: (value: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void) => PromiseLike<T>;\n\ninterface PromiseLike<T> {\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): PromiseLike<TResult1 | TResult2>;\n}\n\n/**\n * Represents the completion of an asynchronous operation\n */\ninterface Promise<T> {\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\n\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\n}\n\n/**\n * Recursively unwraps the "awaited type" of a type. Non-promise "thenables" should resolve to `never`. This emulates the behavior of `await`.\n */\ntype Awaited<T> =\n    T extends null | undefined ? T : // special case for `null | undefined` when not in `--strictNullChecks` mode\n        T extends object & { then(onfulfilled: infer F, ...args: infer _): any } ? // `await` only unwraps object types with a callable `then`. Non-object types are not unwrapped\n            F extends ((value: infer V, ...args: infer _) => any) ? // if the argument to `then` is callable, extracts the first argument\n                Awaited<V> : // recursively unwrap the value\n                never : // the argument to `then` was not callable\n        T; // non-object or non-thenable\n\ninterface ArrayLike<T> {\n    readonly length: number;\n    readonly [n: number]: T;\n}\n\n/**\n * Make all properties in T optional\n */\ntype Partial<T> = {\n    [P in keyof T]?: T[P];\n};\n\n/**\n * Make all properties in T required\n */\ntype Required<T> = {\n    [P in keyof T]-?: T[P];\n};\n\n/**\n * Make all properties in T readonly\n */\ntype Readonly<T> = {\n    readonly [P in keyof T]: T[P];\n};\n\n/**\n * From T, pick a set of properties whose keys are in the union K\n */\ntype Pick<T, K extends keyof T> = {\n    [P in K]: T[P];\n};\n\n/**\n * Construct a type with a set of properties K of type T\n */\ntype Record<K extends keyof any, T> = {\n    [P in K]: T;\n};\n\n/**\n * Exclude from T those types that are assignable to U\n */\ntype Exclude<T, U> = T extends U ? never : T;\n\n/**\n * Extract from T those types that are assignable to U\n */\ntype Extract<T, U> = T extends U ? T : never;\n\n/**\n * Construct a type with the properties of T except for those in type K.\n */\ntype Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>;\n\n/**\n * Exclude null and undefined from T\n */\ntype NonNullable<T> = T & {};\n\n/**\n * Obtain the parameters of a function type in a tuple\n */\ntype Parameters<T extends (...args: any) => any> = T extends (...args: infer P) => any ? P : never;\n\n/**\n * Obtain the parameters of a constructor function type in a tuple\n */\ntype ConstructorParameters<T extends abstract new (...args: any) => any> = T extends abstract new (...args: infer P) => any ? P : never;\n\n/**\n * Obtain the return type of a function type\n */\ntype ReturnType<T extends (...args: any) => any> = T extends (...args: any) => infer R ? R : any;\n\n/**\n * Obtain the return type of a constructor function type\n */\ntype InstanceType<T extends abstract new (...args: any) => any> = T extends abstract new (...args: any) => infer R ? R : any;\n\n/**\n * Convert string literal type to uppercase\n */\ntype Uppercase<S extends string> = intrinsic;\n\n/**\n * Convert string literal type to lowercase\n */\ntype Lowercase<S extends string> = intrinsic;\n\n/**\n * Convert first character of string literal type to uppercase\n */\ntype Capitalize<S extends string> = intrinsic;\n\n/**\n * Convert first character of string literal type to lowercase\n */\ntype Uncapitalize<S extends string> = intrinsic;\n\n/**\n * Marker for contextual \'this\' type\n */\ninterface ThisType<T> { }\n\n/**\n * Represents a raw buffer of binary data, which is used to store data for the\n * different typed arrays. ArrayBuffers cannot be read from or written to directly,\n * but can be passed to a typed array or DataView Object to interpret the raw\n * buffer as needed.\n */\ninterface ArrayBuffer {\n    /**\n     * Read-only. The length of the ArrayBuffer (in bytes).\n     */\n    readonly byteLength: number;\n\n    /**\n     * Returns a section of an ArrayBuffer.\n     */\n    slice(begin: number, end?: number): ArrayBuffer;\n}\n\n/**\n * Allowed ArrayBuffer types for the buffer of an ArrayBufferView and related Typed Arrays.\n */\ninterface ArrayBufferTypes {\n    ArrayBuffer: ArrayBuffer;\n}\ntype ArrayBufferLike = ArrayBufferTypes[keyof ArrayBufferTypes];\n\ninterface ArrayBufferConstructor {\n    readonly prototype: ArrayBuffer;\n    new(byteLength: number): ArrayBuffer;\n    isView(arg: any): arg is ArrayBufferView;\n}\ndeclare var ArrayBuffer: ArrayBufferConstructor;\n\ninterface ArrayBufferView {\n    /**\n     * The ArrayBuffer instance referenced by the array.\n     */\n    buffer: ArrayBufferLike;\n\n    /**\n     * The length in bytes of the array.\n     */\n    byteLength: number;\n\n    /**\n     * The offset in bytes of the array.\n     */\n    byteOffset: number;\n}\n\ninterface DataView {\n    readonly buffer: ArrayBuffer;\n    readonly byteLength: number;\n    readonly byteOffset: number;\n    /**\n     * Gets the Float32 value at the specified byte offset from the start of the view. There is\n     * no alignment constraint; multi-byte values may be fetched from any offset.\n     * @param byteOffset The place in the buffer at which the value should be retrieved.\n     * @param littleEndian If false or undefined, a big-endian value should be read.\n     */\n    getFloat32(byteOffset: number, littleEndian?: boolean): number;\n\n    /**\n     * Gets the Float64 value at the specified byte offset from the start of the view. There is\n     * no alignment constraint; multi-byte values may be fetched from any offset.\n     * @param byteOffset The place in the buffer at which the value should be retrieved.\n     * @param littleEndian If false or undefined, a big-endian value should be read.\n     */\n    getFloat64(byteOffset: number, littleEndian?: boolean): number;\n\n    /**\n     * Gets the Int8 value at the specified byte offset from the start of the view. There is\n     * no alignment constraint; multi-byte values may be fetched from any offset.\n     * @param byteOffset The place in the buffer at which the value should be retrieved.\n     */\n    getInt8(byteOffset: number): number;\n\n    /**\n     * Gets the Int16 value at the specified byte offset from the start of the view. There is\n     * no alignment constraint; multi-byte values may be fetched from any offset.\n     * @param byteOffset The place in the buffer at which the value should be retrieved.\n     * @param littleEndian If false or undefined, a big-endian value should be read.\n     */\n    getInt16(byteOffset: number, littleEndian?: boolean): number;\n    /**\n     * Gets the Int32 value at the specified byte offset from the start of the view. There is\n     * no alignment constraint; multi-byte values may be fetched from any offset.\n     * @param byteOffset The place in the buffer at which the value should be retrieved.\n     * @param littleEndian If false or undefined, a big-endian value should be read.\n     */\n    getInt32(byteOffset: number, littleEndian?: boolean): number;\n\n    /**\n     * Gets the Uint8 value at the specified byte offset from the start of the view. There is\n     * no alignment constraint; multi-byte values may be fetched from any offset.\n     * @param byteOffset The place in the buffer at which the value should be retrieved.\n     */\n    getUint8(byteOffset: number): number;\n\n    /**\n     * Gets the Uint16 value at the specified byte offset from the start of the view. There is\n     * no alignment constraint; multi-byte values may be fetched from any offset.\n     * @param byteOffset The place in the buffer at which the value should be retrieved.\n     * @param littleEndian If false or undefined, a big-endian value should be read.\n     */\n    getUint16(byteOffset: number, littleEndian?: boolean): number;\n\n    /**\n     * Gets the Uint32 value at the specified byte offset from the start of the view. There is\n     * no alignment constraint; multi-byte values may be fetched from any offset.\n     * @param byteOffset The place in the buffer at which the value should be retrieved.\n     * @param littleEndian If false or undefined, a big-endian value should be read.\n     */\n    getUint32(byteOffset: number, littleEndian?: boolean): number;\n\n    /**\n     * Stores an Float32 value at the specified byte offset from the start of the view.\n     * @param byteOffset The place in the buffer at which the value should be set.\n     * @param value The value to set.\n     * @param littleEndian If false or undefined, a big-endian value should be written.\n     */\n    setFloat32(byteOffset: number, value: number, littleEndian?: boolean): void;\n\n    /**\n     * Stores an Float64 value at the specified byte offset from the start of the view.\n     * @param byteOffset The place in the buffer at which the value should be set.\n     * @param value The value to set.\n     * @param littleEndian If false or undefined, a big-endian value should be written.\n     */\n    setFloat64(byteOffset: number, value: number, littleEndian?: boolean): void;\n\n    /**\n     * Stores an Int8 value at the specified byte offset from the start of the view.\n     * @param byteOffset The place in the buffer at which the value should be set.\n     * @param value The value to set.\n     */\n    setInt8(byteOffset: number, value: number): void;\n\n    /**\n     * Stores an Int16 value at the specified byte offset from the start of the view.\n     * @param byteOffset The place in the buffer at which the value should be set.\n     * @param value The value to set.\n     * @param littleEndian If false or undefined, a big-endian value should be written.\n     */\n    setInt16(byteOffset: number, value: number, littleEndian?: boolean): void;\n\n    /**\n     * Stores an Int32 value at the specified byte offset from the start of the view.\n     * @param byteOffset The place in the buffer at which the value should be set.\n     * @param value The value to set.\n     * @param littleEndian If false or undefined, a big-endian value should be written.\n     */\n    setInt32(byteOffset: number, value: number, littleEndian?: boolean): void;\n\n    /**\n     * Stores an Uint8 value at the specified byte offset from the start of the view.\n     * @param byteOffset The place in the buffer at which the value should be set.\n     * @param value The value to set.\n     */\n    setUint8(byteOffset: number, value: number): void;\n\n    /**\n     * Stores an Uint16 value at the specified byte offset from the start of the view.\n     * @param byteOffset The place in the buffer at which the value should be set.\n     * @param value The value to set.\n     * @param littleEndian If false or undefined, a big-endian value should be written.\n     */\n    setUint16(byteOffset: number, value: number, littleEndian?: boolean): void;\n\n    /**\n     * Stores an Uint32 value at the specified byte offset from the start of the view.\n     * @param byteOffset The place in the buffer at which the value should be set.\n     * @param value The value to set.\n     * @param littleEndian If false or undefined, a big-endian value should be written.\n     */\n    setUint32(byteOffset: number, value: number, littleEndian?: boolean): void;\n}\n\ninterface DataViewConstructor {\n    readonly prototype: DataView;\n    new(buffer: ArrayBufferLike & { BYTES_PER_ELEMENT?: never }, byteOffset?: number, byteLength?: number): DataView;\n}\ndeclare var DataView: DataViewConstructor;\n\n/**\n * A typed array of 8-bit integer values. The contents are initialized to 0. If the requested\n * number of bytes could not be allocated an exception is raised.\n */\ninterface Int8Array {\n    /**\n     * The size in bytes of each element in the array.\n     */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n     * The ArrayBuffer instance referenced by the array.\n     */\n    readonly buffer: ArrayBufferLike;\n\n    /**\n     * The length in bytes of the array.\n     */\n    readonly byteLength: number;\n\n    /**\n     * The offset in bytes of the array.\n     */\n    readonly byteOffset: number;\n\n    /**\n     * Returns the this object after copying a section of the array identified by start and end\n     * to the same array starting at position target\n     * @param target If target is negative, it is treated as length+target where length is the\n     * length of the array.\n     * @param start If start is negative, it is treated as length+start. If end is negative, it\n     * is treated as length+end. If start is omitted, `0` is used.\n     * @param end If not specified, length of the this object is used as its default value.\n     */\n    copyWithin(target: number, start?: number, end?: number): this;\n\n    /**\n     * Determines whether all the members of an array satisfy the specified test.\n     * @param predicate A function that accepts up to three arguments. The every method calls\n     * the predicate function for each element in the array until the predicate returns a value\n     * which is coercible to the Boolean value false, or until the end of the array.\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    every(predicate: (value: number, index: number, array: Int8Array) => unknown, thisArg?: any): boolean;\n\n    /**\n     * Changes all array elements from `start` to `end` index to a static `value` and returns the modified array\n     * @param value value to fill array section with\n     * @param start index to start filling the array at. If start is negative, it is treated as\n     * length+start where length is the length of the array.\n     * @param end index to stop filling the array at. If end is negative, it is treated as\n     * length+end.\n     */\n    fill(value: number, start?: number, end?: number): this;\n\n    /**\n     * Returns the elements of an array that meet the condition specified in a callback function.\n     * @param predicate A function that accepts up to three arguments. The filter method calls\n     * the predicate function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    filter(predicate: (value: number, index: number, array: Int8Array) => any, thisArg?: any): Int8Array;\n\n    /**\n     * Returns the value of the first element in the array where predicate is true, and undefined\n     * otherwise.\n     * @param predicate find calls predicate once for each element of the array, in ascending\n     * order, until it finds one where predicate returns true. If such an element is found, find\n     * immediately returns that element value. Otherwise, find returns undefined.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    find(predicate: (value: number, index: number, obj: Int8Array) => boolean, thisArg?: any): number | undefined;\n\n    /**\n     * Returns the index of the first element in the array where predicate is true, and -1\n     * otherwise.\n     * @param predicate find calls predicate once for each element of the array, in ascending\n     * order, until it finds one where predicate returns true. If such an element is found,\n     * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findIndex(predicate: (value: number, index: number, obj: Int8Array) => boolean, thisArg?: any): number;\n\n    /**\n     * Performs the specified action for each element in an array.\n     * @param callbackfn  A function that accepts up to three arguments. forEach calls the\n     * callbackfn function one time for each element in the array.\n     * @param thisArg  An object to which the this keyword can refer in the callbackfn function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    forEach(callbackfn: (value: number, index: number, array: Int8Array) => void, thisArg?: any): void;\n\n    /**\n     * Returns the index of the first occurrence of a value in an array.\n     * @param searchElement The value to locate in the array.\n     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n     *  search starts at index 0.\n     */\n    indexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n     * Adds all the elements of an array separated by the specified separator string.\n     * @param separator A string used to separate one element of an array from the next in the\n     * resulting String. If omitted, the array elements are separated with a comma.\n     */\n    join(separator?: string): string;\n\n    /**\n     * Returns the index of the last occurrence of a value in an array.\n     * @param searchElement The value to locate in the array.\n     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n     * search starts at index 0.\n     */\n    lastIndexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n     * The length of the array.\n     */\n    readonly length: number;\n\n    /**\n     * Calls a defined callback function on each element of an array, and returns an array that\n     * contains the results.\n     * @param callbackfn A function that accepts up to three arguments. The map method calls the\n     * callbackfn function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    map(callbackfn: (value: number, index: number, array: Int8Array) => number, thisArg?: any): Int8Array;\n\n    /**\n     * Calls the specified callback function for all the elements in an array. The return value of\n     * the callback function is the accumulated result, and is provided as an argument in the next\n     * call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n     * callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\n     * instead of an array value.\n     */\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array) => number): number;\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array) => number, initialValue: number): number;\n\n    /**\n     * Calls the specified callback function for all the elements in an array. The return value of\n     * the callback function is the accumulated result, and is provided as an argument in the next\n     * call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n     * callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\n     * instead of an array value.\n     */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int8Array) => U, initialValue: U): U;\n\n    /**\n     * Calls the specified callback function for all the elements in an array, in descending order.\n     * The return value of the callback function is the accumulated result, and is provided as an\n     * argument in the next call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n     * the callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\n     * the accumulation. The first call to the callbackfn function provides this value as an\n     * argument instead of an array value.\n     */\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array) => number): number;\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array) => number, initialValue: number): number;\n\n    /**\n     * Calls the specified callback function for all the elements in an array, in descending order.\n     * The return value of the callback function is the accumulated result, and is provided as an\n     * argument in the next call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n     * the callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\n     * instead of an array value.\n     */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int8Array) => U, initialValue: U): U;\n\n    /**\n     * Reverses the elements in an Array.\n     */\n    reverse(): Int8Array;\n\n    /**\n     * Sets a value or an array of values.\n     * @param array A typed or untyped array of values to set.\n     * @param offset The index in the current array at which the values are to be written.\n     */\n    set(array: ArrayLike<number>, offset?: number): void;\n\n    /**\n     * Returns a section of an array.\n     * @param start The beginning of the specified portion of the array.\n     * @param end The end of the specified portion of the array. This is exclusive of the element at the index \'end\'.\n     */\n    slice(start?: number, end?: number): Int8Array;\n\n    /**\n     * Determines whether the specified callback function returns true for any element of an array.\n     * @param predicate A function that accepts up to three arguments. The some method calls\n     * the predicate function for each element in the array until the predicate returns a value\n     * which is coercible to the Boolean value true, or until the end of the array.\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    some(predicate: (value: number, index: number, array: Int8Array) => unknown, thisArg?: any): boolean;\n\n    /**\n     * Sorts an array.\n     * @param compareFn Function used to determine the order of the elements. It is expected to return\n     * a negative value if first argument is less than second argument, zero if they\'re equal and a positive\n     * value otherwise. If omitted, the elements are sorted in ascending order.\n     * ```ts\n     * [11,2,22,1].sort((a, b) => a - b)\n     * ```\n     */\n    sort(compareFn?: (a: number, b: number) => number): this;\n\n    /**\n     * Gets a new Int8Array view of the ArrayBuffer store for this array, referencing the elements\n     * at begin, inclusive, up to end, exclusive.\n     * @param begin The index of the beginning of the array.\n     * @param end The index of the end of the array.\n     */\n    subarray(begin?: number, end?: number): Int8Array;\n\n    /**\n     * Converts a number to a string by using the current locale.\n     */\n    toLocaleString(): string;\n\n    /**\n     * Returns a string representation of an array.\n     */\n    toString(): string;\n\n    /** Returns the primitive value of the specified object. */\n    valueOf(): Int8Array;\n\n    [index: number]: number;\n}\ninterface Int8ArrayConstructor {\n    readonly prototype: Int8Array;\n    new(length: number): Int8Array;\n    new(array: ArrayLike<number> | ArrayBufferLike): Int8Array;\n    new(buffer: ArrayBufferLike, byteOffset?: number, length?: number): Int8Array;\n\n    /**\n     * The size in bytes of each element in the array.\n     */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n     * Returns a new array from a set of elements.\n     * @param items A set of elements to include in the new array object.\n     */\n    of(...items: number[]): Int8Array;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like or iterable object to convert to an array.\n     */\n    from(arrayLike: ArrayLike<number>): Int8Array;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like or iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of \'this\' used to invoke the mapfn.\n     */\n    from<T>(arrayLike: ArrayLike<T>, mapfn: (v: T, k: number) => number, thisArg?: any): Int8Array;\n\n\n}\ndeclare var Int8Array: Int8ArrayConstructor;\n\n/**\n * A typed array of 8-bit unsigned integer values. The contents are initialized to 0. If the\n * requested number of bytes could not be allocated an exception is raised.\n */\ninterface Uint8Array {\n    /**\n     * The size in bytes of each element in the array.\n     */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n     * The ArrayBuffer instance referenced by the array.\n     */\n    readonly buffer: ArrayBufferLike;\n\n    /**\n     * The length in bytes of the array.\n     */\n    readonly byteLength: number;\n\n    /**\n     * The offset in bytes of the array.\n     */\n    readonly byteOffset: number;\n\n    /**\n     * Returns the this object after copying a section of the array identified by start and end\n     * to the same array starting at position target\n     * @param target If target is negative, it is treated as length+target where length is the\n     * length of the array.\n     * @param start If start is negative, it is treated as length+start. If end is negative, it\n     * is treated as length+end. If start is omitted, `0` is used.\n     * @param end If not specified, length of the this object is used as its default value.\n     */\n    copyWithin(target: number, start?: number, end?: number): this;\n\n    /**\n     * Determines whether all the members of an array satisfy the specified test.\n     * @param predicate A function that accepts up to three arguments. The every method calls\n     * the predicate function for each element in the array until the predicate returns a value\n     * which is coercible to the Boolean value false, or until the end of the array.\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    every(predicate: (value: number, index: number, array: Uint8Array) => unknown, thisArg?: any): boolean;\n\n    /**\n     * Changes all array elements from `start` to `end` index to a static `value` and returns the modified array\n     * @param value value to fill array section with\n     * @param start index to start filling the array at. If start is negative, it is treated as\n     * length+start where length is the length of the array.\n     * @param end index to stop filling the array at. If end is negative, it is treated as\n     * length+end.\n     */\n    fill(value: number, start?: number, end?: number): this;\n\n    /**\n     * Returns the elements of an array that meet the condition specified in a callback function.\n     * @param predicate A function that accepts up to three arguments. The filter method calls\n     * the predicate function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    filter(predicate: (value: number, index: number, array: Uint8Array) => any, thisArg?: any): Uint8Array;\n\n    /**\n     * Returns the value of the first element in the array where predicate is true, and undefined\n     * otherwise.\n     * @param predicate find calls predicate once for each element of the array, in ascending\n     * order, until it finds one where predicate returns true. If such an element is found, find\n     * immediately returns that element value. Otherwise, find returns undefined.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    find(predicate: (value: number, index: number, obj: Uint8Array) => boolean, thisArg?: any): number | undefined;\n\n    /**\n     * Returns the index of the first element in the array where predicate is true, and -1\n     * otherwise.\n     * @param predicate find calls predicate once for each element of the array, in ascending\n     * order, until it finds one where predicate returns true. If such an element is found,\n     * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findIndex(predicate: (value: number, index: number, obj: Uint8Array) => boolean, thisArg?: any): number;\n\n    /**\n     * Performs the specified action for each element in an array.\n     * @param callbackfn  A function that accepts up to three arguments. forEach calls the\n     * callbackfn function one time for each element in the array.\n     * @param thisArg  An object to which the this keyword can refer in the callbackfn function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    forEach(callbackfn: (value: number, index: number, array: Uint8Array) => void, thisArg?: any): void;\n\n    /**\n     * Returns the index of the first occurrence of a value in an array.\n     * @param searchElement The value to locate in the array.\n     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n     *  search starts at index 0.\n     */\n    indexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n     * Adds all the elements of an array separated by the specified separator string.\n     * @param separator A string used to separate one element of an array from the next in the\n     * resulting String. If omitted, the array elements are separated with a comma.\n     */\n    join(separator?: string): string;\n\n    /**\n     * Returns the index of the last occurrence of a value in an array.\n     * @param searchElement The value to locate in the array.\n     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n     * search starts at index 0.\n     */\n    lastIndexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n     * The length of the array.\n     */\n    readonly length: number;\n\n    /**\n     * Calls a defined callback function on each element of an array, and returns an array that\n     * contains the results.\n     * @param callbackfn A function that accepts up to three arguments. The map method calls the\n     * callbackfn function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    map(callbackfn: (value: number, index: number, array: Uint8Array) => number, thisArg?: any): Uint8Array;\n\n    /**\n     * Calls the specified callback function for all the elements in an array. The return value of\n     * the callback function is the accumulated result, and is provided as an argument in the next\n     * call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n     * callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\n     * instead of an array value.\n     */\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array) => number): number;\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array) => number, initialValue: number): number;\n\n    /**\n     * Calls the specified callback function for all the elements in an array. The return value of\n     * the callback function is the accumulated result, and is provided as an argument in the next\n     * call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n     * callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\n     * instead of an array value.\n     */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8Array) => U, initialValue: U): U;\n\n    /**\n     * Calls the specified callback function for all the elements in an array, in descending order.\n     * The return value of the callback function is the accumulated result, and is provided as an\n     * argument in the next call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n     * the callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\n     * the accumulation. The first call to the callbackfn function provides this value as an\n     * argument instead of an array value.\n     */\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array) => number): number;\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8Array) => number, initialValue: number): number;\n\n    /**\n     * Calls the specified callback function for all the elements in an array, in descending order.\n     * The return value of the callback function is the accumulated result, and is provided as an\n     * argument in the next call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n     * the callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\n     * instead of an array value.\n     */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8Array) => U, initialValue: U): U;\n\n    /**\n     * Reverses the elements in an Array.\n     */\n    reverse(): Uint8Array;\n\n    /**\n     * Sets a value or an array of values.\n     * @param array A typed or untyped array of values to set.\n     * @param offset The index in the current array at which the values are to be written.\n     */\n    set(array: ArrayLike<number>, offset?: number): void;\n\n    /**\n     * Returns a section of an array.\n     * @param start The beginning of the specified portion of the array.\n     * @param end The end of the specified portion of the array. This is exclusive of the element at the index \'end\'.\n     */\n    slice(start?: number, end?: number): Uint8Array;\n\n    /**\n     * Determines whether the specified callback function returns true for any element of an array.\n     * @param predicate A function that accepts up to three arguments. The some method calls\n     * the predicate function for each element in the array until the predicate returns a value\n     * which is coercible to the Boolean value true, or until the end of the array.\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    some(predicate: (value: number, index: number, array: Uint8Array) => unknown, thisArg?: any): boolean;\n\n    /**\n     * Sorts an array.\n     * @param compareFn Function used to determine the order of the elements. It is expected to return\n     * a negative value if first argument is less than second argument, zero if they\'re equal and a positive\n     * value otherwise. If omitted, the elements are sorted in ascending order.\n     * ```ts\n     * [11,2,22,1].sort((a, b) => a - b)\n     * ```\n     */\n    sort(compareFn?: (a: number, b: number) => number): this;\n\n    /**\n     * Gets a new Uint8Array view of the ArrayBuffer store for this array, referencing the elements\n     * at begin, inclusive, up to end, exclusive.\n     * @param begin The index of the beginning of the array.\n     * @param end The index of the end of the array.\n     */\n    subarray(begin?: number, end?: number): Uint8Array;\n\n    /**\n     * Converts a number to a string by using the current locale.\n     */\n    toLocaleString(): string;\n\n    /**\n     * Returns a string representation of an array.\n     */\n    toString(): string;\n\n    /** Returns the primitive value of the specified object. */\n    valueOf(): Uint8Array;\n\n    [index: number]: number;\n}\n\ninterface Uint8ArrayConstructor {\n    readonly prototype: Uint8Array;\n    new(length: number): Uint8Array;\n    new(array: ArrayLike<number> | ArrayBufferLike): Uint8Array;\n    new(buffer: ArrayBufferLike, byteOffset?: number, length?: number): Uint8Array;\n\n    /**\n     * The size in bytes of each element in the array.\n     */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n     * Returns a new array from a set of elements.\n     * @param items A set of elements to include in the new array object.\n     */\n    of(...items: number[]): Uint8Array;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like or iterable object to convert to an array.\n     */\n    from(arrayLike: ArrayLike<number>): Uint8Array;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like or iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of \'this\' used to invoke the mapfn.\n     */\n    from<T>(arrayLike: ArrayLike<T>, mapfn: (v: T, k: number) => number, thisArg?: any): Uint8Array;\n\n}\ndeclare var Uint8Array: Uint8ArrayConstructor;\n\n/**\n * A typed array of 8-bit unsigned integer (clamped) values. The contents are initialized to 0.\n * If the requested number of bytes could not be allocated an exception is raised.\n */\ninterface Uint8ClampedArray {\n    /**\n     * The size in bytes of each element in the array.\n     */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n     * The ArrayBuffer instance referenced by the array.\n     */\n    readonly buffer: ArrayBufferLike;\n\n    /**\n     * The length in bytes of the array.\n     */\n    readonly byteLength: number;\n\n    /**\n     * The offset in bytes of the array.\n     */\n    readonly byteOffset: number;\n\n    /**\n     * Returns the this object after copying a section of the array identified by start and end\n     * to the same array starting at position target\n     * @param target If target is negative, it is treated as length+target where length is the\n     * length of the array.\n     * @param start If start is negative, it is treated as length+start. If end is negative, it\n     * is treated as length+end. If start is omitted, `0` is used.\n     * @param end If not specified, length of the this object is used as its default value.\n     */\n    copyWithin(target: number, start?: number, end?: number): this;\n\n    /**\n     * Determines whether all the members of an array satisfy the specified test.\n     * @param predicate A function that accepts up to three arguments. The every method calls\n     * the predicate function for each element in the array until the predicate returns a value\n     * which is coercible to the Boolean value false, or until the end of the array.\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    every(predicate: (value: number, index: number, array: Uint8ClampedArray) => unknown, thisArg?: any): boolean;\n\n    /**\n     * Changes all array elements from `start` to `end` index to a static `value` and returns the modified array\n     * @param value value to fill array section with\n     * @param start index to start filling the array at. If start is negative, it is treated as\n     * length+start where length is the length of the array.\n     * @param end index to stop filling the array at. If end is negative, it is treated as\n     * length+end.\n     */\n    fill(value: number, start?: number, end?: number): this;\n\n    /**\n     * Returns the elements of an array that meet the condition specified in a callback function.\n     * @param predicate A function that accepts up to three arguments. The filter method calls\n     * the predicate function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    filter(predicate: (value: number, index: number, array: Uint8ClampedArray) => any, thisArg?: any): Uint8ClampedArray;\n\n    /**\n     * Returns the value of the first element in the array where predicate is true, and undefined\n     * otherwise.\n     * @param predicate find calls predicate once for each element of the array, in ascending\n     * order, until it finds one where predicate returns true. If such an element is found, find\n     * immediately returns that element value. Otherwise, find returns undefined.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    find(predicate: (value: number, index: number, obj: Uint8ClampedArray) => boolean, thisArg?: any): number | undefined;\n\n    /**\n     * Returns the index of the first element in the array where predicate is true, and -1\n     * otherwise.\n     * @param predicate find calls predicate once for each element of the array, in ascending\n     * order, until it finds one where predicate returns true. If such an element is found,\n     * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findIndex(predicate: (value: number, index: number, obj: Uint8ClampedArray) => boolean, thisArg?: any): number;\n\n    /**\n     * Performs the specified action for each element in an array.\n     * @param callbackfn  A function that accepts up to three arguments. forEach calls the\n     * callbackfn function one time for each element in the array.\n     * @param thisArg  An object to which the this keyword can refer in the callbackfn function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    forEach(callbackfn: (value: number, index: number, array: Uint8ClampedArray) => void, thisArg?: any): void;\n\n    /**\n     * Returns the index of the first occurrence of a value in an array.\n     * @param searchElement The value to locate in the array.\n     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n     *  search starts at index 0.\n     */\n    indexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n     * Adds all the elements of an array separated by the specified separator string.\n     * @param separator A string used to separate one element of an array from the next in the\n     * resulting String. If omitted, the array elements are separated with a comma.\n     */\n    join(separator?: string): string;\n\n    /**\n     * Returns the index of the last occurrence of a value in an array.\n     * @param searchElement The value to locate in the array.\n     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n     * search starts at index 0.\n     */\n    lastIndexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n     * The length of the array.\n     */\n    readonly length: number;\n\n    /**\n     * Calls a defined callback function on each element of an array, and returns an array that\n     * contains the results.\n     * @param callbackfn A function that accepts up to three arguments. The map method calls the\n     * callbackfn function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    map(callbackfn: (value: number, index: number, array: Uint8ClampedArray) => number, thisArg?: any): Uint8ClampedArray;\n\n    /**\n     * Calls the specified callback function for all the elements in an array. The return value of\n     * the callback function is the accumulated result, and is provided as an argument in the next\n     * call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n     * callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\n     * instead of an array value.\n     */\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray) => number): number;\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray) => number, initialValue: number): number;\n\n    /**\n     * Calls the specified callback function for all the elements in an array. The return value of\n     * the callback function is the accumulated result, and is provided as an argument in the next\n     * call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n     * callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\n     * instead of an array value.\n     */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8ClampedArray) => U, initialValue: U): U;\n\n    /**\n     * Calls the specified callback function for all the elements in an array, in descending order.\n     * The return value of the callback function is the accumulated result, and is provided as an\n     * argument in the next call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n     * the callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\n     * the accumulation. The first call to the callbackfn function provides this value as an\n     * argument instead of an array value.\n     */\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray) => number): number;\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint8ClampedArray) => number, initialValue: number): number;\n\n    /**\n     * Calls the specified callback function for all the elements in an array, in descending order.\n     * The return value of the callback function is the accumulated result, and is provided as an\n     * argument in the next call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n     * the callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\n     * instead of an array value.\n     */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint8ClampedArray) => U, initialValue: U): U;\n\n    /**\n     * Reverses the elements in an Array.\n     */\n    reverse(): Uint8ClampedArray;\n\n    /**\n     * Sets a value or an array of values.\n     * @param array A typed or untyped array of values to set.\n     * @param offset The index in the current array at which the values are to be written.\n     */\n    set(array: ArrayLike<number>, offset?: number): void;\n\n    /**\n     * Returns a section of an array.\n     * @param start The beginning of the specified portion of the array.\n     * @param end The end of the specified portion of the array. This is exclusive of the element at the index \'end\'.\n     */\n    slice(start?: number, end?: number): Uint8ClampedArray;\n\n    /**\n     * Determines whether the specified callback function returns true for any element of an array.\n     * @param predicate A function that accepts up to three arguments. The some method calls\n     * the predicate function for each element in the array until the predicate returns a value\n     * which is coercible to the Boolean value true, or until the end of the array.\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    some(predicate: (value: number, index: number, array: Uint8ClampedArray) => unknown, thisArg?: any): boolean;\n\n    /**\n     * Sorts an array.\n     * @param compareFn Function used to determine the order of the elements. It is expected to return\n     * a negative value if first argument is less than second argument, zero if they\'re equal and a positive\n     * value otherwise. If omitted, the elements are sorted in ascending order.\n     * ```ts\n     * [11,2,22,1].sort((a, b) => a - b)\n     * ```\n     */\n    sort(compareFn?: (a: number, b: number) => number): this;\n\n    /**\n     * Gets a new Uint8ClampedArray view of the ArrayBuffer store for this array, referencing the elements\n     * at begin, inclusive, up to end, exclusive.\n     * @param begin The index of the beginning of the array.\n     * @param end The index of the end of the array.\n     */\n    subarray(begin?: number, end?: number): Uint8ClampedArray;\n\n    /**\n     * Converts a number to a string by using the current locale.\n     */\n    toLocaleString(): string;\n\n    /**\n     * Returns a string representation of an array.\n     */\n    toString(): string;\n\n    /** Returns the primitive value of the specified object. */\n    valueOf(): Uint8ClampedArray;\n\n    [index: number]: number;\n}\n\ninterface Uint8ClampedArrayConstructor {\n    readonly prototype: Uint8ClampedArray;\n    new(length: number): Uint8ClampedArray;\n    new(array: ArrayLike<number> | ArrayBufferLike): Uint8ClampedArray;\n    new(buffer: ArrayBufferLike, byteOffset?: number, length?: number): Uint8ClampedArray;\n\n    /**\n     * The size in bytes of each element in the array.\n     */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n     * Returns a new array from a set of elements.\n     * @param items A set of elements to include in the new array object.\n     */\n    of(...items: number[]): Uint8ClampedArray;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like or iterable object to convert to an array.\n     */\n    from(arrayLike: ArrayLike<number>): Uint8ClampedArray;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like or iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of \'this\' used to invoke the mapfn.\n     */\n    from<T>(arrayLike: ArrayLike<T>, mapfn: (v: T, k: number) => number, thisArg?: any): Uint8ClampedArray;\n}\ndeclare var Uint8ClampedArray: Uint8ClampedArrayConstructor;\n\n/**\n * A typed array of 16-bit signed integer values. The contents are initialized to 0. If the\n * requested number of bytes could not be allocated an exception is raised.\n */\ninterface Int16Array {\n    /**\n     * The size in bytes of each element in the array.\n     */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n     * The ArrayBuffer instance referenced by the array.\n     */\n    readonly buffer: ArrayBufferLike;\n\n    /**\n     * The length in bytes of the array.\n     */\n    readonly byteLength: number;\n\n    /**\n     * The offset in bytes of the array.\n     */\n    readonly byteOffset: number;\n\n    /**\n     * Returns the this object after copying a section of the array identified by start and end\n     * to the same array starting at position target\n     * @param target If target is negative, it is treated as length+target where length is the\n     * length of the array.\n     * @param start If start is negative, it is treated as length+start. If end is negative, it\n     * is treated as length+end. If start is omitted, `0` is used.\n     * @param end If not specified, length of the this object is used as its default value.\n     */\n    copyWithin(target: number, start?: number, end?: number): this;\n\n    /**\n     * Determines whether all the members of an array satisfy the specified test.\n     * @param predicate A function that accepts up to three arguments. The every method calls\n     * the predicate function for each element in the array until the predicate returns a value\n     * which is coercible to the Boolean value false, or until the end of the array.\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    every(predicate: (value: number, index: number, array: Int16Array) => unknown, thisArg?: any): boolean;\n\n    /**\n     * Changes all array elements from `start` to `end` index to a static `value` and returns the modified array\n     * @param value value to fill array section with\n     * @param start index to start filling the array at. If start is negative, it is treated as\n     * length+start where length is the length of the array.\n     * @param end index to stop filling the array at. If end is negative, it is treated as\n     * length+end.\n     */\n    fill(value: number, start?: number, end?: number): this;\n\n    /**\n     * Returns the elements of an array that meet the condition specified in a callback function.\n     * @param predicate A function that accepts up to three arguments. The filter method calls\n     * the predicate function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    filter(predicate: (value: number, index: number, array: Int16Array) => any, thisArg?: any): Int16Array;\n\n    /**\n     * Returns the value of the first element in the array where predicate is true, and undefined\n     * otherwise.\n     * @param predicate find calls predicate once for each element of the array, in ascending\n     * order, until it finds one where predicate returns true. If such an element is found, find\n     * immediately returns that element value. Otherwise, find returns undefined.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    find(predicate: (value: number, index: number, obj: Int16Array) => boolean, thisArg?: any): number | undefined;\n\n    /**\n     * Returns the index of the first element in the array where predicate is true, and -1\n     * otherwise.\n     * @param predicate find calls predicate once for each element of the array, in ascending\n     * order, until it finds one where predicate returns true. If such an element is found,\n     * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findIndex(predicate: (value: number, index: number, obj: Int16Array) => boolean, thisArg?: any): number;\n\n    /**\n     * Performs the specified action for each element in an array.\n     * @param callbackfn  A function that accepts up to three arguments. forEach calls the\n     * callbackfn function one time for each element in the array.\n     * @param thisArg  An object to which the this keyword can refer in the callbackfn function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    forEach(callbackfn: (value: number, index: number, array: Int16Array) => void, thisArg?: any): void;\n    /**\n     * Returns the index of the first occurrence of a value in an array.\n     * @param searchElement The value to locate in the array.\n     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n     *  search starts at index 0.\n     */\n    indexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n     * Adds all the elements of an array separated by the specified separator string.\n     * @param separator A string used to separate one element of an array from the next in the\n     * resulting String. If omitted, the array elements are separated with a comma.\n     */\n    join(separator?: string): string;\n\n    /**\n     * Returns the index of the last occurrence of a value in an array.\n     * @param searchElement The value to locate in the array.\n     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n     * search starts at index 0.\n     */\n    lastIndexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n     * The length of the array.\n     */\n    readonly length: number;\n\n    /**\n     * Calls a defined callback function on each element of an array, and returns an array that\n     * contains the results.\n     * @param callbackfn A function that accepts up to three arguments. The map method calls the\n     * callbackfn function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    map(callbackfn: (value: number, index: number, array: Int16Array) => number, thisArg?: any): Int16Array;\n\n    /**\n     * Calls the specified callback function for all the elements in an array. The return value of\n     * the callback function is the accumulated result, and is provided as an argument in the next\n     * call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n     * callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\n     * instead of an array value.\n     */\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array) => number): number;\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array) => number, initialValue: number): number;\n\n    /**\n     * Calls the specified callback function for all the elements in an array. The return value of\n     * the callback function is the accumulated result, and is provided as an argument in the next\n     * call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n     * callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\n     * instead of an array value.\n     */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int16Array) => U, initialValue: U): U;\n\n    /**\n     * Calls the specified callback function for all the elements in an array, in descending order.\n     * The return value of the callback function is the accumulated result, and is provided as an\n     * argument in the next call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n     * the callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\n     * the accumulation. The first call to the callbackfn function provides this value as an\n     * argument instead of an array value.\n     */\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array) => number): number;\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int16Array) => number, initialValue: number): number;\n\n    /**\n     * Calls the specified callback function for all the elements in an array, in descending order.\n     * The return value of the callback function is the accumulated result, and is provided as an\n     * argument in the next call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n     * the callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\n     * instead of an array value.\n     */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int16Array) => U, initialValue: U): U;\n\n    /**\n     * Reverses the elements in an Array.\n     */\n    reverse(): Int16Array;\n\n    /**\n     * Sets a value or an array of values.\n     * @param array A typed or untyped array of values to set.\n     * @param offset The index in the current array at which the values are to be written.\n     */\n    set(array: ArrayLike<number>, offset?: number): void;\n\n    /**\n     * Returns a section of an array.\n     * @param start The beginning of the specified portion of the array.\n     * @param end The end of the specified portion of the array. This is exclusive of the element at the index \'end\'.\n     */\n    slice(start?: number, end?: number): Int16Array;\n\n    /**\n     * Determines whether the specified callback function returns true for any element of an array.\n     * @param predicate A function that accepts up to three arguments. The some method calls\n     * the predicate function for each element in the array until the predicate returns a value\n     * which is coercible to the Boolean value true, or until the end of the array.\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    some(predicate: (value: number, index: number, array: Int16Array) => unknown, thisArg?: any): boolean;\n\n    /**\n     * Sorts an array.\n     * @param compareFn Function used to determine the order of the elements. It is expected to return\n     * a negative value if first argument is less than second argument, zero if they\'re equal and a positive\n     * value otherwise. If omitted, the elements are sorted in ascending order.\n     * ```ts\n     * [11,2,22,1].sort((a, b) => a - b)\n     * ```\n     */\n    sort(compareFn?: (a: number, b: number) => number): this;\n\n    /**\n     * Gets a new Int16Array view of the ArrayBuffer store for this array, referencing the elements\n     * at begin, inclusive, up to end, exclusive.\n     * @param begin The index of the beginning of the array.\n     * @param end The index of the end of the array.\n     */\n    subarray(begin?: number, end?: number): Int16Array;\n\n    /**\n     * Converts a number to a string by using the current locale.\n     */\n    toLocaleString(): string;\n\n    /**\n     * Returns a string representation of an array.\n     */\n    toString(): string;\n\n    /** Returns the primitive value of the specified object. */\n    valueOf(): Int16Array;\n\n    [index: number]: number;\n}\n\ninterface Int16ArrayConstructor {\n    readonly prototype: Int16Array;\n    new(length: number): Int16Array;\n    new(array: ArrayLike<number> | ArrayBufferLike): Int16Array;\n    new(buffer: ArrayBufferLike, byteOffset?: number, length?: number): Int16Array;\n\n    /**\n     * The size in bytes of each element in the array.\n     */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n     * Returns a new array from a set of elements.\n     * @param items A set of elements to include in the new array object.\n     */\n    of(...items: number[]): Int16Array;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like or iterable object to convert to an array.\n     */\n    from(arrayLike: ArrayLike<number>): Int16Array;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like or iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of \'this\' used to invoke the mapfn.\n     */\n    from<T>(arrayLike: ArrayLike<T>, mapfn: (v: T, k: number) => number, thisArg?: any): Int16Array;\n\n\n}\ndeclare var Int16Array: Int16ArrayConstructor;\n\n/**\n * A typed array of 16-bit unsigned integer values. The contents are initialized to 0. If the\n * requested number of bytes could not be allocated an exception is raised.\n */\ninterface Uint16Array {\n    /**\n     * The size in bytes of each element in the array.\n     */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n     * The ArrayBuffer instance referenced by the array.\n     */\n    readonly buffer: ArrayBufferLike;\n\n    /**\n     * The length in bytes of the array.\n     */\n    readonly byteLength: number;\n\n    /**\n     * The offset in bytes of the array.\n     */\n    readonly byteOffset: number;\n\n    /**\n     * Returns the this object after copying a section of the array identified by start and end\n     * to the same array starting at position target\n     * @param target If target is negative, it is treated as length+target where length is the\n     * length of the array.\n     * @param start If start is negative, it is treated as length+start. If end is negative, it\n     * is treated as length+end. If start is omitted, `0` is used.\n     * @param end If not specified, length of the this object is used as its default value.\n     */\n    copyWithin(target: number, start?: number, end?: number): this;\n\n    /**\n     * Determines whether all the members of an array satisfy the specified test.\n     * @param predicate A function that accepts up to three arguments. The every method calls\n     * the predicate function for each element in the array until the predicate returns a value\n     * which is coercible to the Boolean value false, or until the end of the array.\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    every(predicate: (value: number, index: number, array: Uint16Array) => unknown, thisArg?: any): boolean;\n\n    /**\n     * Changes all array elements from `start` to `end` index to a static `value` and returns the modified array\n     * @param value value to fill array section with\n     * @param start index to start filling the array at. If start is negative, it is treated as\n     * length+start where length is the length of the array.\n     * @param end index to stop filling the array at. If end is negative, it is treated as\n     * length+end.\n     */\n    fill(value: number, start?: number, end?: number): this;\n\n    /**\n     * Returns the elements of an array that meet the condition specified in a callback function.\n     * @param predicate A function that accepts up to three arguments. The filter method calls\n     * the predicate function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    filter(predicate: (value: number, index: number, array: Uint16Array) => any, thisArg?: any): Uint16Array;\n\n    /**\n     * Returns the value of the first element in the array where predicate is true, and undefined\n     * otherwise.\n     * @param predicate find calls predicate once for each element of the array, in ascending\n     * order, until it finds one where predicate returns true. If such an element is found, find\n     * immediately returns that element value. Otherwise, find returns undefined.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    find(predicate: (value: number, index: number, obj: Uint16Array) => boolean, thisArg?: any): number | undefined;\n\n    /**\n     * Returns the index of the first element in the array where predicate is true, and -1\n     * otherwise.\n     * @param predicate find calls predicate once for each element of the array, in ascending\n     * order, until it finds one where predicate returns true. If such an element is found,\n     * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findIndex(predicate: (value: number, index: number, obj: Uint16Array) => boolean, thisArg?: any): number;\n\n    /**\n     * Performs the specified action for each element in an array.\n     * @param callbackfn  A function that accepts up to three arguments. forEach calls the\n     * callbackfn function one time for each element in the array.\n     * @param thisArg  An object to which the this keyword can refer in the callbackfn function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    forEach(callbackfn: (value: number, index: number, array: Uint16Array) => void, thisArg?: any): void;\n\n    /**\n     * Returns the index of the first occurrence of a value in an array.\n     * @param searchElement The value to locate in the array.\n     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n     *  search starts at index 0.\n     */\n    indexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n     * Adds all the elements of an array separated by the specified separator string.\n     * @param separator A string used to separate one element of an array from the next in the\n     * resulting String. If omitted, the array elements are separated with a comma.\n     */\n    join(separator?: string): string;\n\n    /**\n     * Returns the index of the last occurrence of a value in an array.\n     * @param searchElement The value to locate in the array.\n     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n     * search starts at index 0.\n     */\n    lastIndexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n     * The length of the array.\n     */\n    readonly length: number;\n\n    /**\n     * Calls a defined callback function on each element of an array, and returns an array that\n     * contains the results.\n     * @param callbackfn A function that accepts up to three arguments. The map method calls the\n     * callbackfn function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    map(callbackfn: (value: number, index: number, array: Uint16Array) => number, thisArg?: any): Uint16Array;\n\n    /**\n     * Calls the specified callback function for all the elements in an array. The return value of\n     * the callback function is the accumulated result, and is provided as an argument in the next\n     * call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n     * callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\n     * instead of an array value.\n     */\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array) => number): number;\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array) => number, initialValue: number): number;\n\n    /**\n     * Calls the specified callback function for all the elements in an array. The return value of\n     * the callback function is the accumulated result, and is provided as an argument in the next\n     * call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n     * callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\n     * instead of an array value.\n     */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint16Array) => U, initialValue: U): U;\n\n    /**\n     * Calls the specified callback function for all the elements in an array, in descending order.\n     * The return value of the callback function is the accumulated result, and is provided as an\n     * argument in the next call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n     * the callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\n     * the accumulation. The first call to the callbackfn function provides this value as an\n     * argument instead of an array value.\n     */\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array) => number): number;\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint16Array) => number, initialValue: number): number;\n\n    /**\n     * Calls the specified callback function for all the elements in an array, in descending order.\n     * The return value of the callback function is the accumulated result, and is provided as an\n     * argument in the next call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n     * the callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\n     * instead of an array value.\n     */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint16Array) => U, initialValue: U): U;\n\n    /**\n     * Reverses the elements in an Array.\n     */\n    reverse(): Uint16Array;\n\n    /**\n     * Sets a value or an array of values.\n     * @param array A typed or untyped array of values to set.\n     * @param offset The index in the current array at which the values are to be written.\n     */\n    set(array: ArrayLike<number>, offset?: number): void;\n\n    /**\n     * Returns a section of an array.\n     * @param start The beginning of the specified portion of the array.\n     * @param end The end of the specified portion of the array. This is exclusive of the element at the index \'end\'.\n     */\n    slice(start?: number, end?: number): Uint16Array;\n\n    /**\n     * Determines whether the specified callback function returns true for any element of an array.\n     * @param predicate A function that accepts up to three arguments. The some method calls\n     * the predicate function for each element in the array until the predicate returns a value\n     * which is coercible to the Boolean value true, or until the end of the array.\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    some(predicate: (value: number, index: number, array: Uint16Array) => unknown, thisArg?: any): boolean;\n\n    /**\n     * Sorts an array.\n     * @param compareFn Function used to determine the order of the elements. It is expected to return\n     * a negative value if first argument is less than second argument, zero if they\'re equal and a positive\n     * value otherwise. If omitted, the elements are sorted in ascending order.\n     * ```ts\n     * [11,2,22,1].sort((a, b) => a - b)\n     * ```\n     */\n    sort(compareFn?: (a: number, b: number) => number): this;\n\n    /**\n     * Gets a new Uint16Array view of the ArrayBuffer store for this array, referencing the elements\n     * at begin, inclusive, up to end, exclusive.\n     * @param begin The index of the beginning of the array.\n     * @param end The index of the end of the array.\n     */\n    subarray(begin?: number, end?: number): Uint16Array;\n\n    /**\n     * Converts a number to a string by using the current locale.\n     */\n    toLocaleString(): string;\n\n    /**\n     * Returns a string representation of an array.\n     */\n    toString(): string;\n\n    /** Returns the primitive value of the specified object. */\n    valueOf(): Uint16Array;\n\n    [index: number]: number;\n}\n\ninterface Uint16ArrayConstructor {\n    readonly prototype: Uint16Array;\n    new(length: number): Uint16Array;\n    new(array: ArrayLike<number> | ArrayBufferLike): Uint16Array;\n    new(buffer: ArrayBufferLike, byteOffset?: number, length?: number): Uint16Array;\n\n    /**\n     * The size in bytes of each element in the array.\n     */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n     * Returns a new array from a set of elements.\n     * @param items A set of elements to include in the new array object.\n     */\n    of(...items: number[]): Uint16Array;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like or iterable object to convert to an array.\n     */\n    from(arrayLike: ArrayLike<number>): Uint16Array;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like or iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of \'this\' used to invoke the mapfn.\n     */\n    from<T>(arrayLike: ArrayLike<T>, mapfn: (v: T, k: number) => number, thisArg?: any): Uint16Array;\n\n\n}\ndeclare var Uint16Array: Uint16ArrayConstructor;\n/**\n * A typed array of 32-bit signed integer values. The contents are initialized to 0. If the\n * requested number of bytes could not be allocated an exception is raised.\n */\ninterface Int32Array {\n    /**\n     * The size in bytes of each element in the array.\n     */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n     * The ArrayBuffer instance referenced by the array.\n     */\n    readonly buffer: ArrayBufferLike;\n\n    /**\n     * The length in bytes of the array.\n     */\n    readonly byteLength: number;\n\n    /**\n     * The offset in bytes of the array.\n     */\n    readonly byteOffset: number;\n\n    /**\n     * Returns the this object after copying a section of the array identified by start and end\n     * to the same array starting at position target\n     * @param target If target is negative, it is treated as length+target where length is the\n     * length of the array.\n     * @param start If start is negative, it is treated as length+start. If end is negative, it\n     * is treated as length+end. If start is omitted, `0` is used.\n     * @param end If not specified, length of the this object is used as its default value.\n     */\n    copyWithin(target: number, start?: number, end?: number): this;\n\n    /**\n     * Determines whether all the members of an array satisfy the specified test.\n     * @param predicate A function that accepts up to three arguments. The every method calls\n     * the predicate function for each element in the array until the predicate returns a value\n     * which is coercible to the Boolean value false, or until the end of the array.\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    every(predicate: (value: number, index: number, array: Int32Array) => unknown, thisArg?: any): boolean;\n\n    /**\n     * Changes all array elements from `start` to `end` index to a static `value` and returns the modified array\n     * @param value value to fill array section with\n     * @param start index to start filling the array at. If start is negative, it is treated as\n     * length+start where length is the length of the array.\n     * @param end index to stop filling the array at. If end is negative, it is treated as\n     * length+end.\n     */\n    fill(value: number, start?: number, end?: number): this;\n\n    /**\n     * Returns the elements of an array that meet the condition specified in a callback function.\n     * @param predicate A function that accepts up to three arguments. The filter method calls\n     * the predicate function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    filter(predicate: (value: number, index: number, array: Int32Array) => any, thisArg?: any): Int32Array;\n\n    /**\n     * Returns the value of the first element in the array where predicate is true, and undefined\n     * otherwise.\n     * @param predicate find calls predicate once for each element of the array, in ascending\n     * order, until it finds one where predicate returns true. If such an element is found, find\n     * immediately returns that element value. Otherwise, find returns undefined.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    find(predicate: (value: number, index: number, obj: Int32Array) => boolean, thisArg?: any): number | undefined;\n\n    /**\n     * Returns the index of the first element in the array where predicate is true, and -1\n     * otherwise.\n     * @param predicate find calls predicate once for each element of the array, in ascending\n     * order, until it finds one where predicate returns true. If such an element is found,\n     * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findIndex(predicate: (value: number, index: number, obj: Int32Array) => boolean, thisArg?: any): number;\n\n    /**\n     * Performs the specified action for each element in an array.\n     * @param callbackfn  A function that accepts up to three arguments. forEach calls the\n     * callbackfn function one time for each element in the array.\n     * @param thisArg  An object to which the this keyword can refer in the callbackfn function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    forEach(callbackfn: (value: number, index: number, array: Int32Array) => void, thisArg?: any): void;\n\n    /**\n     * Returns the index of the first occurrence of a value in an array.\n     * @param searchElement The value to locate in the array.\n     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n     *  search starts at index 0.\n     */\n    indexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n     * Adds all the elements of an array separated by the specified separator string.\n     * @param separator A string used to separate one element of an array from the next in the\n     * resulting String. If omitted, the array elements are separated with a comma.\n     */\n    join(separator?: string): string;\n\n    /**\n     * Returns the index of the last occurrence of a value in an array.\n     * @param searchElement The value to locate in the array.\n     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n     * search starts at index 0.\n     */\n    lastIndexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n     * The length of the array.\n     */\n    readonly length: number;\n\n    /**\n     * Calls a defined callback function on each element of an array, and returns an array that\n     * contains the results.\n     * @param callbackfn A function that accepts up to three arguments. The map method calls the\n     * callbackfn function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    map(callbackfn: (value: number, index: number, array: Int32Array) => number, thisArg?: any): Int32Array;\n\n    /**\n     * Calls the specified callback function for all the elements in an array. The return value of\n     * the callback function is the accumulated result, and is provided as an argument in the next\n     * call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n     * callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\n     * instead of an array value.\n     */\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array) => number): number;\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array) => number, initialValue: number): number;\n\n    /**\n     * Calls the specified callback function for all the elements in an array. The return value of\n     * the callback function is the accumulated result, and is provided as an argument in the next\n     * call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n     * callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\n     * instead of an array value.\n     */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int32Array) => U, initialValue: U): U;\n\n    /**\n     * Calls the specified callback function for all the elements in an array, in descending order.\n     * The return value of the callback function is the accumulated result, and is provided as an\n     * argument in the next call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n     * the callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\n     * the accumulation. The first call to the callbackfn function provides this value as an\n     * argument instead of an array value.\n     */\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array) => number): number;\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int32Array) => number, initialValue: number): number;\n\n    /**\n     * Calls the specified callback function for all the elements in an array, in descending order.\n     * The return value of the callback function is the accumulated result, and is provided as an\n     * argument in the next call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n     * the callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\n     * instead of an array value.\n     */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Int32Array) => U, initialValue: U): U;\n\n    /**\n     * Reverses the elements in an Array.\n     */\n    reverse(): Int32Array;\n\n    /**\n     * Sets a value or an array of values.\n     * @param array A typed or untyped array of values to set.\n     * @param offset The index in the current array at which the values are to be written.\n     */\n    set(array: ArrayLike<number>, offset?: number): void;\n\n    /**\n     * Returns a section of an array.\n     * @param start The beginning of the specified portion of the array.\n     * @param end The end of the specified portion of the array. This is exclusive of the element at the index \'end\'.\n     */\n    slice(start?: number, end?: number): Int32Array;\n\n    /**\n     * Determines whether the specified callback function returns true for any element of an array.\n     * @param predicate A function that accepts up to three arguments. The some method calls\n     * the predicate function for each element in the array until the predicate returns a value\n     * which is coercible to the Boolean value true, or until the end of the array.\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    some(predicate: (value: number, index: number, array: Int32Array) => unknown, thisArg?: any): boolean;\n\n    /**\n     * Sorts an array.\n     * @param compareFn Function used to determine the order of the elements. It is expected to return\n     * a negative value if first argument is less than second argument, zero if they\'re equal and a positive\n     * value otherwise. If omitted, the elements are sorted in ascending order.\n     * ```ts\n     * [11,2,22,1].sort((a, b) => a - b)\n     * ```\n     */\n    sort(compareFn?: (a: number, b: number) => number): this;\n\n    /**\n     * Gets a new Int32Array view of the ArrayBuffer store for this array, referencing the elements\n     * at begin, inclusive, up to end, exclusive.\n     * @param begin The index of the beginning of the array.\n     * @param end The index of the end of the array.\n     */\n    subarray(begin?: number, end?: number): Int32Array;\n\n    /**\n     * Converts a number to a string by using the current locale.\n     */\n    toLocaleString(): string;\n\n    /**\n     * Returns a string representation of an array.\n     */\n    toString(): string;\n\n    /** Returns the primitive value of the specified object. */\n    valueOf(): Int32Array;\n\n    [index: number]: number;\n}\n\ninterface Int32ArrayConstructor {\n    readonly prototype: Int32Array;\n    new(length: number): Int32Array;\n    new(array: ArrayLike<number> | ArrayBufferLike): Int32Array;\n    new(buffer: ArrayBufferLike, byteOffset?: number, length?: number): Int32Array;\n\n    /**\n     * The size in bytes of each element in the array.\n     */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n     * Returns a new array from a set of elements.\n     * @param items A set of elements to include in the new array object.\n     */\n    of(...items: number[]): Int32Array;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like or iterable object to convert to an array.\n     */\n    from(arrayLike: ArrayLike<number>): Int32Array;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like or iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of \'this\' used to invoke the mapfn.\n     */\n    from<T>(arrayLike: ArrayLike<T>, mapfn: (v: T, k: number) => number, thisArg?: any): Int32Array;\n\n}\ndeclare var Int32Array: Int32ArrayConstructor;\n\n/**\n * A typed array of 32-bit unsigned integer values. The contents are initialized to 0. If the\n * requested number of bytes could not be allocated an exception is raised.\n */\ninterface Uint32Array {\n    /**\n     * The size in bytes of each element in the array.\n     */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n     * The ArrayBuffer instance referenced by the array.\n     */\n    readonly buffer: ArrayBufferLike;\n\n    /**\n     * The length in bytes of the array.\n     */\n    readonly byteLength: number;\n\n    /**\n     * The offset in bytes of the array.\n     */\n    readonly byteOffset: number;\n\n    /**\n     * Returns the this object after copying a section of the array identified by start and end\n     * to the same array starting at position target\n     * @param target If target is negative, it is treated as length+target where length is the\n     * length of the array.\n     * @param start If start is negative, it is treated as length+start. If end is negative, it\n     * is treated as length+end. If start is omitted, `0` is used.\n     * @param end If not specified, length of the this object is used as its default value.\n     */\n    copyWithin(target: number, start?: number, end?: number): this;\n\n    /**\n     * Determines whether all the members of an array satisfy the specified test.\n     * @param predicate A function that accepts up to three arguments. The every method calls\n     * the predicate function for each element in the array until the predicate returns a value\n     * which is coercible to the Boolean value false, or until the end of the array.\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    every(predicate: (value: number, index: number, array: Uint32Array) => unknown, thisArg?: any): boolean;\n\n    /**\n     * Changes all array elements from `start` to `end` index to a static `value` and returns the modified array\n     * @param value value to fill array section with\n     * @param start index to start filling the array at. If start is negative, it is treated as\n     * length+start where length is the length of the array.\n     * @param end index to stop filling the array at. If end is negative, it is treated as\n     * length+end.\n     */\n    fill(value: number, start?: number, end?: number): this;\n\n    /**\n     * Returns the elements of an array that meet the condition specified in a callback function.\n     * @param predicate A function that accepts up to three arguments. The filter method calls\n     * the predicate function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    filter(predicate: (value: number, index: number, array: Uint32Array) => any, thisArg?: any): Uint32Array;\n\n    /**\n     * Returns the value of the first element in the array where predicate is true, and undefined\n     * otherwise.\n     * @param predicate find calls predicate once for each element of the array, in ascending\n     * order, until it finds one where predicate returns true. If such an element is found, find\n     * immediately returns that element value. Otherwise, find returns undefined.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    find(predicate: (value: number, index: number, obj: Uint32Array) => boolean, thisArg?: any): number | undefined;\n\n    /**\n     * Returns the index of the first element in the array where predicate is true, and -1\n     * otherwise.\n     * @param predicate find calls predicate once for each element of the array, in ascending\n     * order, until it finds one where predicate returns true. If such an element is found,\n     * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findIndex(predicate: (value: number, index: number, obj: Uint32Array) => boolean, thisArg?: any): number;\n\n    /**\n     * Performs the specified action for each element in an array.\n     * @param callbackfn  A function that accepts up to three arguments. forEach calls the\n     * callbackfn function one time for each element in the array.\n     * @param thisArg  An object to which the this keyword can refer in the callbackfn function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    forEach(callbackfn: (value: number, index: number, array: Uint32Array) => void, thisArg?: any): void;\n    /**\n     * Returns the index of the first occurrence of a value in an array.\n     * @param searchElement The value to locate in the array.\n     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n     *  search starts at index 0.\n     */\n    indexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n     * Adds all the elements of an array separated by the specified separator string.\n     * @param separator A string used to separate one element of an array from the next in the\n     * resulting String. If omitted, the array elements are separated with a comma.\n     */\n    join(separator?: string): string;\n\n    /**\n     * Returns the index of the last occurrence of a value in an array.\n     * @param searchElement The value to locate in the array.\n     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n     * search starts at index 0.\n     */\n    lastIndexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n     * The length of the array.\n     */\n    readonly length: number;\n\n    /**\n     * Calls a defined callback function on each element of an array, and returns an array that\n     * contains the results.\n     * @param callbackfn A function that accepts up to three arguments. The map method calls the\n     * callbackfn function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    map(callbackfn: (value: number, index: number, array: Uint32Array) => number, thisArg?: any): Uint32Array;\n\n    /**\n     * Calls the specified callback function for all the elements in an array. The return value of\n     * the callback function is the accumulated result, and is provided as an argument in the next\n     * call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n     * callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\n     * instead of an array value.\n     */\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array) => number): number;\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array) => number, initialValue: number): number;\n\n    /**\n     * Calls the specified callback function for all the elements in an array. The return value of\n     * the callback function is the accumulated result, and is provided as an argument in the next\n     * call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n     * callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\n     * instead of an array value.\n     */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint32Array) => U, initialValue: U): U;\n\n    /**\n     * Calls the specified callback function for all the elements in an array, in descending order.\n     * The return value of the callback function is the accumulated result, and is provided as an\n     * argument in the next call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n     * the callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\n     * the accumulation. The first call to the callbackfn function provides this value as an\n     * argument instead of an array value.\n     */\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array) => number): number;\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Uint32Array) => number, initialValue: number): number;\n\n    /**\n     * Calls the specified callback function for all the elements in an array, in descending order.\n     * The return value of the callback function is the accumulated result, and is provided as an\n     * argument in the next call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n     * the callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\n     * instead of an array value.\n     */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Uint32Array) => U, initialValue: U): U;\n\n    /**\n     * Reverses the elements in an Array.\n     */\n    reverse(): Uint32Array;\n\n    /**\n     * Sets a value or an array of values.\n     * @param array A typed or untyped array of values to set.\n     * @param offset The index in the current array at which the values are to be written.\n     */\n    set(array: ArrayLike<number>, offset?: number): void;\n\n    /**\n     * Returns a section of an array.\n     * @param start The beginning of the specified portion of the array.\n     * @param end The end of the specified portion of the array. This is exclusive of the element at the index \'end\'.\n     */\n    slice(start?: number, end?: number): Uint32Array;\n\n    /**\n     * Determines whether the specified callback function returns true for any element of an array.\n     * @param predicate A function that accepts up to three arguments. The some method calls\n     * the predicate function for each element in the array until the predicate returns a value\n     * which is coercible to the Boolean value true, or until the end of the array.\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    some(predicate: (value: number, index: number, array: Uint32Array) => unknown, thisArg?: any): boolean;\n\n    /**\n     * Sorts an array.\n     * @param compareFn Function used to determine the order of the elements. It is expected to return\n     * a negative value if first argument is less than second argument, zero if they\'re equal and a positive\n     * value otherwise. If omitted, the elements are sorted in ascending order.\n     * ```ts\n     * [11,2,22,1].sort((a, b) => a - b)\n     * ```\n     */\n    sort(compareFn?: (a: number, b: number) => number): this;\n\n    /**\n     * Gets a new Uint32Array view of the ArrayBuffer store for this array, referencing the elements\n     * at begin, inclusive, up to end, exclusive.\n     * @param begin The index of the beginning of the array.\n     * @param end The index of the end of the array.\n     */\n    subarray(begin?: number, end?: number): Uint32Array;\n\n    /**\n     * Converts a number to a string by using the current locale.\n     */\n    toLocaleString(): string;\n\n    /**\n     * Returns a string representation of an array.\n     */\n    toString(): string;\n\n    /** Returns the primitive value of the specified object. */\n    valueOf(): Uint32Array;\n\n    [index: number]: number;\n}\n\ninterface Uint32ArrayConstructor {\n    readonly prototype: Uint32Array;\n    new(length: number): Uint32Array;\n    new(array: ArrayLike<number> | ArrayBufferLike): Uint32Array;\n    new(buffer: ArrayBufferLike, byteOffset?: number, length?: number): Uint32Array;\n\n    /**\n     * The size in bytes of each element in the array.\n     */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n     * Returns a new array from a set of elements.\n     * @param items A set of elements to include in the new array object.\n     */\n    of(...items: number[]): Uint32Array;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like or iterable object to convert to an array.\n     */\n    from(arrayLike: ArrayLike<number>): Uint32Array;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like or iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of \'this\' used to invoke the mapfn.\n     */\n    from<T>(arrayLike: ArrayLike<T>, mapfn: (v: T, k: number) => number, thisArg?: any): Uint32Array;\n\n}\ndeclare var Uint32Array: Uint32ArrayConstructor;\n\n/**\n * A typed array of 32-bit float values. The contents are initialized to 0. If the requested number\n * of bytes could not be allocated an exception is raised.\n */\ninterface Float32Array {\n    /**\n     * The size in bytes of each element in the array.\n     */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n     * The ArrayBuffer instance referenced by the array.\n     */\n    readonly buffer: ArrayBufferLike;\n\n    /**\n     * The length in bytes of the array.\n     */\n    readonly byteLength: number;\n\n    /**\n     * The offset in bytes of the array.\n     */\n    readonly byteOffset: number;\n\n    /**\n     * Returns the this object after copying a section of the array identified by start and end\n     * to the same array starting at position target\n     * @param target If target is negative, it is treated as length+target where length is the\n     * length of the array.\n     * @param start If start is negative, it is treated as length+start. If end is negative, it\n     * is treated as length+end. If start is omitted, `0` is used.\n     * @param end If not specified, length of the this object is used as its default value.\n     */\n    copyWithin(target: number, start?: number, end?: number): this;\n\n    /**\n     * Determines whether all the members of an array satisfy the specified test.\n     * @param predicate A function that accepts up to three arguments. The every method calls\n     * the predicate function for each element in the array until the predicate returns a value\n     * which is coercible to the Boolean value false, or until the end of the array.\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    every(predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): boolean;\n\n    /**\n     * Changes all array elements from `start` to `end` index to a static `value` and returns the modified array\n     * @param value value to fill array section with\n     * @param start index to start filling the array at. If start is negative, it is treated as\n     * length+start where length is the length of the array.\n     * @param end index to stop filling the array at. If end is negative, it is treated as\n     * length+end.\n     */\n    fill(value: number, start?: number, end?: number): this;\n\n    /**\n     * Returns the elements of an array that meet the condition specified in a callback function.\n     * @param predicate A function that accepts up to three arguments. The filter method calls\n     * the predicate function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    filter(predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any): Float32Array;\n\n    /**\n     * Returns the value of the first element in the array where predicate is true, and undefined\n     * otherwise.\n     * @param predicate find calls predicate once for each element of the array, in ascending\n     * order, until it finds one where predicate returns true. If such an element is found, find\n     * immediately returns that element value. Otherwise, find returns undefined.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    find(predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any): number | undefined;\n\n    /**\n     * Returns the index of the first element in the array where predicate is true, and -1\n     * otherwise.\n     * @param predicate find calls predicate once for each element of the array, in ascending\n     * order, until it finds one where predicate returns true. If such an element is found,\n     * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findIndex(predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any): number;\n\n    /**\n     * Performs the specified action for each element in an array.\n     * @param callbackfn  A function that accepts up to three arguments. forEach calls the\n     * callbackfn function one time for each element in the array.\n     * @param thisArg  An object to which the this keyword can refer in the callbackfn function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    forEach(callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any): void;\n\n    /**\n     * Returns the index of the first occurrence of a value in an array.\n     * @param searchElement The value to locate in the array.\n     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n     *  search starts at index 0.\n     */\n    indexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n     * Adds all the elements of an array separated by the specified separator string.\n     * @param separator A string used to separate one element of an array from the next in the\n     * resulting String. If omitted, the array elements are separated with a comma.\n     */\n    join(separator?: string): string;\n\n    /**\n     * Returns the index of the last occurrence of a value in an array.\n     * @param searchElement The value to locate in the array.\n     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n     * search starts at index 0.\n     */\n    lastIndexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n     * The length of the array.\n     */\n    readonly length: number;\n\n    /**\n     * Calls a defined callback function on each element of an array, and returns an array that\n     * contains the results.\n     * @param callbackfn A function that accepts up to three arguments. The map method calls the\n     * callbackfn function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    map(callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any): Float32Array;\n\n    /**\n     * Calls the specified callback function for all the elements in an array. The return value of\n     * the callback function is the accumulated result, and is provided as an argument in the next\n     * call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n     * callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\n     * instead of an array value.\n     */\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;\n\n    /**\n     * Calls the specified callback function for all the elements in an array. The return value of\n     * the callback function is the accumulated result, and is provided as an argument in the next\n     * call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n     * callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\n     * instead of an array value.\n     */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;\n\n    /**\n     * Calls the specified callback function for all the elements in an array, in descending order.\n     * The return value of the callback function is the accumulated result, and is provided as an\n     * argument in the next call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n     * the callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\n     * the accumulation. The first call to the callbackfn function provides this value as an\n     * argument instead of an array value.\n     */\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;\n\n    /**\n     * Calls the specified callback function for all the elements in an array, in descending order.\n     * The return value of the callback function is the accumulated result, and is provided as an\n     * argument in the next call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n     * the callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\n     * instead of an array value.\n     */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;\n\n    /**\n     * Reverses the elements in an Array.\n     */\n    reverse(): Float32Array;\n\n    /**\n     * Sets a value or an array of values.\n     * @param array A typed or untyped array of values to set.\n     * @param offset The index in the current array at which the values are to be written.\n     */\n    set(array: ArrayLike<number>, offset?: number): void;\n\n    /**\n     * Returns a section of an array.\n     * @param start The beginning of the specified portion of the array.\n     * @param end The end of the specified portion of the array. This is exclusive of the element at the index \'end\'.\n     */\n    slice(start?: number, end?: number): Float32Array;\n\n    /**\n     * Determines whether the specified callback function returns true for any element of an array.\n     * @param predicate A function that accepts up to three arguments. The some method calls\n     * the predicate function for each element in the array until the predicate returns a value\n     * which is coercible to the Boolean value true, or until the end of the array.\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    some(predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): boolean;\n\n    /**\n     * Sorts an array.\n     * @param compareFn Function used to determine the order of the elements. It is expected to return\n     * a negative value if first argument is less than second argument, zero if they\'re equal and a positive\n     * value otherwise. If omitted, the elements are sorted in ascending order.\n     * ```ts\n     * [11,2,22,1].sort((a, b) => a - b)\n     * ```\n     */\n    sort(compareFn?: (a: number, b: number) => number): this;\n\n    /**\n     * Gets a new Float32Array view of the ArrayBuffer store for this array, referencing the elements\n     * at begin, inclusive, up to end, exclusive.\n     * @param begin The index of the beginning of the array.\n     * @param end The index of the end of the array.\n     */\n    subarray(begin?: number, end?: number): Float32Array;\n\n    /**\n     * Converts a number to a string by using the current locale.\n     */\n    toLocaleString(): string;\n\n    /**\n     * Returns a string representation of an array.\n     */\n    toString(): string;\n\n    /** Returns the primitive value of the specified object. */\n    valueOf(): Float32Array;\n\n    [index: number]: number;\n}\n\ninterface Float32ArrayConstructor {\n    readonly prototype: Float32Array;\n    new(length: number): Float32Array;\n    new(array: ArrayLike<number> | ArrayBufferLike): Float32Array;\n    new(buffer: ArrayBufferLike, byteOffset?: number, length?: number): Float32Array;\n\n    /**\n     * The size in bytes of each element in the array.\n     */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n     * Returns a new array from a set of elements.\n     * @param items A set of elements to include in the new array object.\n     */\n    of(...items: number[]): Float32Array;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like or iterable object to convert to an array.\n     */\n    from(arrayLike: ArrayLike<number>): Float32Array;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like or iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of \'this\' used to invoke the mapfn.\n     */\n    from<T>(arrayLike: ArrayLike<T>, mapfn: (v: T, k: number) => number, thisArg?: any): Float32Array;\n\n\n}\ndeclare var Float32Array: Float32ArrayConstructor;\n\n/**\n * A typed array of 64-bit float values. The contents are initialized to 0. If the requested\n * number of bytes could not be allocated an exception is raised.\n */\ninterface Float64Array {\n    /**\n     * The size in bytes of each element in the array.\n     */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n     * The ArrayBuffer instance referenced by the array.\n     */\n    readonly buffer: ArrayBufferLike;\n\n    /**\n     * The length in bytes of the array.\n     */\n    readonly byteLength: number;\n\n    /**\n     * The offset in bytes of the array.\n     */\n    readonly byteOffset: number;\n\n    /**\n     * Returns the this object after copying a section of the array identified by start and end\n     * to the same array starting at position target\n     * @param target If target is negative, it is treated as length+target where length is the\n     * length of the array.\n     * @param start If start is negative, it is treated as length+start. If end is negative, it\n     * is treated as length+end. If start is omitted, `0` is used.\n     * @param end If not specified, length of the this object is used as its default value.\n     */\n    copyWithin(target: number, start?: number, end?: number): this;\n\n    /**\n     * Determines whether all the members of an array satisfy the specified test.\n     * @param predicate A function that accepts up to three arguments. The every method calls\n     * the predicate function for each element in the array until the predicate returns a value\n     * which is coercible to the Boolean value false, or until the end of the array.\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    every(predicate: (value: number, index: number, array: Float64Array) => unknown, thisArg?: any): boolean;\n\n    /**\n     * Changes all array elements from `start` to `end` index to a static `value` and returns the modified array\n     * @param value value to fill array section with\n     * @param start index to start filling the array at. If start is negative, it is treated as\n     * length+start where length is the length of the array.\n     * @param end index to stop filling the array at. If end is negative, it is treated as\n     * length+end.\n     */\n    fill(value: number, start?: number, end?: number): this;\n\n    /**\n     * Returns the elements of an array that meet the condition specified in a callback function.\n     * @param predicate A function that accepts up to three arguments. The filter method calls\n     * the predicate function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    filter(predicate: (value: number, index: number, array: Float64Array) => any, thisArg?: any): Float64Array;\n\n    /**\n     * Returns the value of the first element in the array where predicate is true, and undefined\n     * otherwise.\n     * @param predicate find calls predicate once for each element of the array, in ascending\n     * order, until it finds one where predicate returns true. If such an element is found, find\n     * immediately returns that element value. Otherwise, find returns undefined.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    find(predicate: (value: number, index: number, obj: Float64Array) => boolean, thisArg?: any): number | undefined;\n\n    /**\n     * Returns the index of the first element in the array where predicate is true, and -1\n     * otherwise.\n     * @param predicate find calls predicate once for each element of the array, in ascending\n     * order, until it finds one where predicate returns true. If such an element is found,\n     * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findIndex(predicate: (value: number, index: number, obj: Float64Array) => boolean, thisArg?: any): number;\n\n    /**\n     * Performs the specified action for each element in an array.\n     * @param callbackfn  A function that accepts up to three arguments. forEach calls the\n     * callbackfn function one time for each element in the array.\n     * @param thisArg  An object to which the this keyword can refer in the callbackfn function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    forEach(callbackfn: (value: number, index: number, array: Float64Array) => void, thisArg?: any): void;\n\n    /**\n     * Returns the index of the first occurrence of a value in an array.\n     * @param searchElement The value to locate in the array.\n     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n     *  search starts at index 0.\n     */\n    indexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n     * Adds all the elements of an array separated by the specified separator string.\n     * @param separator A string used to separate one element of an array from the next in the\n     * resulting String. If omitted, the array elements are separated with a comma.\n     */\n    join(separator?: string): string;\n\n    /**\n     * Returns the index of the last occurrence of a value in an array.\n     * @param searchElement The value to locate in the array.\n     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the\n     * search starts at index 0.\n     */\n    lastIndexOf(searchElement: number, fromIndex?: number): number;\n\n    /**\n     * The length of the array.\n     */\n    readonly length: number;\n\n    /**\n     * Calls a defined callback function on each element of an array, and returns an array that\n     * contains the results.\n     * @param callbackfn A function that accepts up to three arguments. The map method calls the\n     * callbackfn function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    map(callbackfn: (value: number, index: number, array: Float64Array) => number, thisArg?: any): Float64Array;\n\n    /**\n     * Calls the specified callback function for all the elements in an array. The return value of\n     * the callback function is the accumulated result, and is provided as an argument in the next\n     * call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n     * callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\n     * instead of an array value.\n     */\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array) => number): number;\n    reduce(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array) => number, initialValue: number): number;\n\n    /**\n     * Calls the specified callback function for all the elements in an array. The return value of\n     * the callback function is the accumulated result, and is provided as an argument in the next\n     * call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the\n     * callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\n     * instead of an array value.\n     */\n    reduce<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float64Array) => U, initialValue: U): U;\n\n    /**\n     * Calls the specified callback function for all the elements in an array, in descending order.\n     * The return value of the callback function is the accumulated result, and is provided as an\n     * argument in the next call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n     * the callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\n     * the accumulation. The first call to the callbackfn function provides this value as an\n     * argument instead of an array value.\n     */\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array) => number): number;\n    reduceRight(callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float64Array) => number, initialValue: number): number;\n\n    /**\n     * Calls the specified callback function for all the elements in an array, in descending order.\n     * The return value of the callback function is the accumulated result, and is provided as an\n     * argument in the next call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls\n     * the callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start\n     * the accumulation. The first call to the callbackfn function provides this value as an argument\n     * instead of an array value.\n     */\n    reduceRight<U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float64Array) => U, initialValue: U): U;\n\n    /**\n     * Reverses the elements in an Array.\n     */\n    reverse(): Float64Array;\n\n    /**\n     * Sets a value or an array of values.\n     * @param array A typed or untyped array of values to set.\n     * @param offset The index in the current array at which the values are to be written.\n     */\n    set(array: ArrayLike<number>, offset?: number): void;\n\n    /**\n     * Returns a section of an array.\n     * @param start The beginning of the specified portion of the array.\n     * @param end The end of the specified portion of the array. This is exclusive of the element at the index \'end\'.\n     */\n    slice(start?: number, end?: number): Float64Array;\n\n    /**\n     * Determines whether the specified callback function returns true for any element of an array.\n     * @param predicate A function that accepts up to three arguments. The some method calls\n     * the predicate function for each element in the array until the predicate returns a value\n     * which is coercible to the Boolean value true, or until the end of the array.\n     * @param thisArg An object to which the this keyword can refer in the predicate function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    some(predicate: (value: number, index: number, array: Float64Array) => unknown, thisArg?: any): boolean;\n\n    /**\n     * Sorts an array.\n     * @param compareFn Function used to determine the order of the elements. It is expected to return\n     * a negative value if first argument is less than second argument, zero if they\'re equal and a positive\n     * value otherwise. If omitted, the elements are sorted in ascending order.\n     * ```ts\n     * [11,2,22,1].sort((a, b) => a - b)\n     * ```\n     */\n    sort(compareFn?: (a: number, b: number) => number): this;\n\n    /**\n     * Gets a new Float64Array view of the ArrayBuffer store for this array, referencing the elements\n     * at begin, inclusive, up to end, exclusive.\n     * @param begin The index of the beginning of the array.\n     * @param end The index of the end of the array.\n     */\n    subarray(begin?: number, end?: number): Float64Array;\n\n    /**\n     * Converts a number to a string by using the current locale.\n     */\n    toLocaleString(): string;\n\n    /**\n     * Returns a string representation of an array.\n     */\n    toString(): string;\n\n    /** Returns the primitive value of the specified object. */\n    valueOf(): Float64Array;\n\n    [index: number]: number;\n}\n\ninterface Float64ArrayConstructor {\n    readonly prototype: Float64Array;\n    new(length: number): Float64Array;\n    new(array: ArrayLike<number> | ArrayBufferLike): Float64Array;\n    new(buffer: ArrayBufferLike, byteOffset?: number, length?: number): Float64Array;\n\n    /**\n     * The size in bytes of each element in the array.\n     */\n    readonly BYTES_PER_ELEMENT: number;\n\n    /**\n     * Returns a new array from a set of elements.\n     * @param items A set of elements to include in the new array object.\n     */\n    of(...items: number[]): Float64Array;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like or iterable object to convert to an array.\n     */\n    from(arrayLike: ArrayLike<number>): Float64Array;\n\n    /**\n     * Creates an array from an array-like or iterable object.\n     * @param arrayLike An array-like or iterable object to convert to an array.\n     * @param mapfn A mapping function to call on every element of the array.\n     * @param thisArg Value of \'this\' used to invoke the mapfn.\n     */\n    from<T>(arrayLike: ArrayLike<T>, mapfn: (v: T, k: number) => number, thisArg?: any): Float64Array;\n\n}\ndeclare var Float64Array: Float64ArrayConstructor;\n\n/////////////////////////////\n/// ECMAScript Internationalization API\n/////////////////////////////\n\ndeclare namespace Intl {\n    interface CollatorOptions {\n        usage?: "sort" | "search" | undefined;\n        localeMatcher?: "lookup" | "best fit" | undefined;\n        numeric?: boolean | undefined;\n        caseFirst?: "upper" | "lower" | "false" | undefined;\n        sensitivity?: "base" | "accent" | "case" | "variant" | undefined;\n        collation?: "big5han" | "compat" | "dict" | "direct" | "ducet" | "emoji" | "eor" | "gb2312" | "phonebk" | "phonetic" | "pinyin" | "reformed" | "searchjl" | "stroke" | "trad" | "unihan" | "zhuyin" | undefined;\n        ignorePunctuation?: boolean | undefined;\n    }\n\n    interface ResolvedCollatorOptions {\n        locale: string;\n        usage: string;\n        sensitivity: string;\n        ignorePunctuation: boolean;\n        collation: string;\n        caseFirst: string;\n        numeric: boolean;\n    }\n\n    interface Collator {\n        compare(x: string, y: string): number;\n        resolvedOptions(): ResolvedCollatorOptions;\n    }\n    var Collator: {\n        new(locales?: string | string[], options?: CollatorOptions): Collator;\n        (locales?: string | string[], options?: CollatorOptions): Collator;\n        supportedLocalesOf(locales: string | string[], options?: CollatorOptions): string[];\n    };\n\n    interface NumberFormatOptions {\n        localeMatcher?: string | undefined;\n        style?: string | undefined;\n        currency?: string | undefined;\n        currencySign?: string | undefined;\n        useGrouping?: boolean | undefined;\n        minimumIntegerDigits?: number | undefined;\n        minimumFractionDigits?: number | undefined;\n        maximumFractionDigits?: number | undefined;\n        minimumSignificantDigits?: number | undefined;\n        maximumSignificantDigits?: number | undefined;\n    }\n\n    interface ResolvedNumberFormatOptions {\n        locale: string;\n        numberingSystem: string;\n        style: string;\n        currency?: string;\n        minimumIntegerDigits: number;\n        minimumFractionDigits: number;\n        maximumFractionDigits: number;\n        minimumSignificantDigits?: number;\n        maximumSignificantDigits?: number;\n        useGrouping: boolean;\n    }\n\n    interface NumberFormat {\n        format(value: number): string;\n        resolvedOptions(): ResolvedNumberFormatOptions;\n    }\n    var NumberFormat: {\n        new(locales?: string | string[], options?: NumberFormatOptions): NumberFormat;\n        (locales?: string | string[], options?: NumberFormatOptions): NumberFormat;\n        supportedLocalesOf(locales: string | string[], options?: NumberFormatOptions): string[];\n        readonly prototype: NumberFormat;\n    };\n\n    interface DateTimeFormatOptions {\n        localeMatcher?: "best fit" | "lookup" | undefined;\n        weekday?: "long" | "short" | "narrow" | undefined;\n        era?: "long" | "short" | "narrow" | undefined;\n        year?: "numeric" | "2-digit" | undefined;\n        month?: "numeric" | "2-digit" | "long" | "short" | "narrow" | undefined;\n        day?: "numeric" | "2-digit" | undefined;\n        hour?: "numeric" | "2-digit" | undefined;\n        minute?: "numeric" | "2-digit" | undefined;\n        second?: "numeric" | "2-digit" | undefined;\n        timeZoneName?: "short" | "long" | "shortOffset" | "longOffset" | "shortGeneric" | "longGeneric" | undefined;\n        formatMatcher?: "best fit" | "basic" | undefined;\n        hour12?: boolean | undefined;\n        timeZone?: string | undefined;\n    }\n\n    interface ResolvedDateTimeFormatOptions {\n        locale: string;\n        calendar: string;\n        numberingSystem: string;\n        timeZone: string;\n        hour12?: boolean;\n        weekday?: string;\n        era?: string;\n        year?: string;\n        month?: string;\n        day?: string;\n        hour?: string;\n        minute?: string;\n        second?: string;\n        timeZoneName?: string;\n    }\n\n    interface DateTimeFormat {\n        format(date?: Date | number): string;\n        resolvedOptions(): ResolvedDateTimeFormatOptions;\n    }\n    var DateTimeFormat: {\n        new(locales?: string | string[], options?: DateTimeFormatOptions): DateTimeFormat;\n        (locales?: string | string[], options?: DateTimeFormatOptions): DateTimeFormat;\n        supportedLocalesOf(locales: string | string[], options?: DateTimeFormatOptions): string[];\n        readonly prototype: DateTimeFormat;\n    };\n}\n\ninterface String {\n    /**\n     * Determines whether two strings are equivalent in the current or specified locale.\n     * @param that String to compare to target string\n     * @param locales A locale string or array of locale strings that contain one or more language or locale tags. If you include more than one locale string, list them in descending order of priority so that the first entry is the preferred locale. If you omit this parameter, the default locale of the JavaScript runtime is used. This parameter must conform to BCP 47 standards; see the Intl.Collator object for details.\n     * @param options An object that contains one or more properties that specify comparison options. see the Intl.Collator object for details.\n     */\n    localeCompare(that: string, locales?: string | string[], options?: Intl.CollatorOptions): number;\n}\n\ninterface Number {\n    /**\n     * Converts a number to a string by using the current or specified locale.\n     * @param locales A locale string or array of locale strings that contain one or more language or locale tags. If you include more than one locale string, list them in descending order of priority so that the first entry is the preferred locale. If you omit this parameter, the default locale of the JavaScript runtime is used.\n     * @param options An object that contains one or more properties that specify comparison options.\n     */\n    toLocaleString(locales?: string | string[], options?: Intl.NumberFormatOptions): string;\n}\n\ninterface Date {\n    /**\n     * Converts a date and time to a string by using the current or specified locale.\n     * @param locales A locale string or array of locale strings that contain one or more language or locale tags. If you include more than one locale string, list them in descending order of priority so that the first entry is the preferred locale. If you omit this parameter, the default locale of the JavaScript runtime is used.\n     * @param options An object that contains one or more properties that specify comparison options.\n     */\n    toLocaleString(locales?: string | string[], options?: Intl.DateTimeFormatOptions): string;\n    /**\n     * Converts a date to a string by using the current or specified locale.\n     * @param locales A locale string or array of locale strings that contain one or more language or locale tags. If you include more than one locale string, list them in descending order of priority so that the first entry is the preferred locale. If you omit this parameter, the default locale of the JavaScript runtime is used.\n     * @param options An object that contains one or more properties that specify comparison options.\n     */\n    toLocaleDateString(locales?: string | string[], options?: Intl.DateTimeFormatOptions): string;\n\n    /**\n     * Converts a time to a string by using the current or specified locale.\n     * @param locales A locale string or array of locale strings that contain one or more language or locale tags. If you include more than one locale string, list them in descending order of priority so that the first entry is the preferred locale. If you omit this parameter, the default locale of the JavaScript runtime is used.\n     * @param options An object that contains one or more properties that specify comparison options.\n     */\n    toLocaleTimeString(locales?: string | string[], options?: Intl.DateTimeFormatOptions): string;\n}\n']];(a=i||(i={})).compile=e=>{let n=new Map;for(let[e,t]of b){if(e.endsWith("packageJson.d.ts"))continue;let a=e.replace("file:///",""),r=h().createSourceFile(e,t,h().ScriptTarget.ES2015);n.set(a,r)}let t=h().createSourceFile("main.ts",e,h().ScriptTarget.ES2015);n.set("main.ts",t);let a={value:""},i=h().createProgram(["main.ts"],r,{fileExists:e=>n.has(e),writeFile:(e,n)=>a.value=n,readFile:e=>e.startsWith("node_modules/")&&e.endsWith("/package.json")?b.find(n=>n[0]==="file:///".concat(e))[1]:void 0,getSourceFile:e=>(console.log("getSourceFile",e,n.has(e)),n.get(e)),getDefaultLibFileName:()=>"node_modules/typescript/lib/lib.es5.d.ts",directoryExists:()=>!0,getCurrentDirectory:()=>"",getDirectories:()=>[],getNewLine:()=>"\n",getCanonicalFileName:e=>e,useCaseSensitiveFileNames:()=>!1});window.checker=i.getTypeChecker(),window.source=t;try{return i.emit(void 0,void 0,void 0,void 0,{before:[y()(i)]}),{type:"success",content:a.value}}catch(e){return{type:"error",error:e}}},r=a.OPTIONS={target:h().ScriptTarget.ES2015,module:h().ModuleKind.CommonJS,esModuleInterop:!0,forceConsistentCasingInFileNames:!0,strict:!0,skipLibCheck:!0,emitDecoratorMetadata:!0,experimentalDecorators:!0};let g='import typia from "typia";\n\ninterface IMember {\n    /** \n     * @format uuid \n     */ \n    id: string;\n\n    /** \n     * @format email \n     */ \n    email: string;\n\n    /**\n     * @type uint\n     * @minimum 20\n     * @exclusiveMaximum 100\n     */\n    age: number;\n    parent: IMember | null;\n    children: IMember[];\n}\n\n//----\n// IS\n//----\ntypia.createIs<IMember>();\n\n//----\n// EQUALS\n//----\ntypia.createEquals<IMember>();\n\n//----\n// RANDOM\n//----\ntypia.createRandom<IMember>();\n\n//----\n// ASSERT-STRINGIFY\n//----\ntypia.createAssertStringify<IMember>();\n\n//----\n// JSON SCHEMA\n//----\ntypia.application<[IMember], "ajv">();\n';var v=t(3764);function T(e){let[n,t]=(0,m.useState)(),a=(0,v.Ik)();return(0,m.useEffect)(()=>{a&&(async()=>{let n=await a.editor.colorize(e.content,e.language,{tabSize:4});t(n)})()},[a,e.content]),(0,o.jsx)("div",{style:{height:"100%"},children:n&&(0,o.jsx)("div",{dangerouslySetInnerHTML:{__html:'<div style="margin: 15px">'.concat(n,"</div>")},style:{backgroundColor:"#1e1e1e",overflowX:"auto",overflowY:"auto",paddingLeft:"15px",height:"100%",fontFamily:"monospace",fontSize:"12px",wordWrap:"normal"}})})}let x=e=>{let n=(n,t)=>{for(let[n,a]of(t.languages.typescript.typescriptDefaults.setCompilerOptions(e.options),e.imports))t.languages.typescript.typescriptDefaults.addExtraLib(a,n);let a=t.editor.createModel(e.script,"typescript",t.Uri.parse("file:///main.ts"));n.setModel(a)};return(0,o.jsx)(v.ZP,{height:"100%",theme:"vs-dark",options:{minimap:{enabled:!1},padding:{top:15,bottom:15}},onMount:n,onChange:e.setScript,defaultValue:e.script})},I=e=>{let[n,t]=(0,m.useState)(!1),[a,r]=(0,m.useState)(!1),[i,s]=(0,m.useState)(50),l=n=>{var t;if(!1===a)return;let r=n.clientX/window.innerWidth*100,i=null!==(t=e.minWidth)&&void 0!==t?t:10;s(Math.min(Math.max(r,i),100-i))},c={container:{borderTop:"2px solid skyblue",height:"calc(100vh - 80px)",display:"flex",width:"100%",position:"relative",flexDirection:"row",overflow:"hidden"},left:{height:"100%",width:"".concat(i,"%"),position:"relative",zIndex:1},right:{height:"100%",width:"".concat(100-i,"%"),position:"relative",zIndex:1},gutter:{height:"100%",position:"absolute",top:0,bottom:0,left:"".concat(i,"%"),width:"10px",cursor:"col-resize",zIndex:2,background:"gray",border:a||n?"2px solid skyblue":void 0,borderRadius:a||n?"4px":void 0}};return(0,o.jsxs)("div",{className:"splitter",style:c.container,onMouseMove:l,onMouseUp:()=>r(!1),children:[(0,o.jsx)("div",{style:c.left,children:e.children[0]}),(0,o.jsx)("div",{className:"gutter",style:c.gutter,onMouseDown:()=>r(!0),onMouseOver:()=>t(!0),onMouseOut:()=>t(!1)}),(0,o.jsx)("div",{style:c.right,children:e.children[1]})]})},A=()=>{let[e,n]=(0,m.useState)(null),[t,a]=(0,m.useState)(null);(0,m.useEffect)(()=>{let e=Object.fromEntries(new URLSearchParams(window.location.search).entries());if(e.script){let n=(0,d.decompressFromEncodedURIComponent)(e.script);r(null!=n?n:g)}else r(g)},[]);let r=t=>{n(null!=t?t:"");let r=i.compile(null!=t?t:"");null!==e&&"success"===r.type&&window.history.replaceState(null,"Typia Playground","".concat(location.origin).concat(location.pathname,"?script=").concat((0,d.compressToEncodedURIComponent)(e))),a(r)};return(0,o.jsxs)(I,{children:[null!==e&&(0,o.jsx)(x,{options:i.OPTIONS,imports:b,script:e,setScript:r}),(0,o.jsx)(T,{language:"javascript",content:null===t?"":"success"===t.type?t.content:t.error.message})]})};function w(e){return(0,o.jsx)(A,{})}let k={MDXContent:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,u.ah)(),e.components);return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(w,{...e})}):w(e)},pageOpts:{filePath:"pages/playground/index.mdx",route:"/playground",headings:[],pageMap:[{kind:"Folder",name:"docs",route:"/docs",children:[{kind:"MdxPage",name:"index",route:"/docs"},{kind:"Folder",name:"json",route:"/docs/json",children:[{kind:"MdxPage",name:"parse",route:"/docs/json/parse"},{kind:"MdxPage",name:"schema",route:"/docs/json/schema"},{kind:"MdxPage",name:"stringify",route:"/docs/json/stringify"},{kind:"Meta",data:{stringify:"stringify() functions",parse:"parse() functions",schema:"JSON Schema"}}]},{kind:"MdxPage",name:"miscellaneous",route:"/docs/miscellaneous"},{kind:"MdxPage",name:"pure",route:"/docs/pure"},{kind:"MdxPage",name:"random",route:"/docs/random"},{kind:"MdxPage",name:"setup",route:"/docs/setup"},{kind:"Folder",name:"utilization",route:"/docs/utilization",children:[{kind:"MdxPage",name:"nestjs",route:"/docs/utilization/nestjs"},{kind:"MdxPage",name:"prisma",route:"/docs/utilization/prisma"},{kind:"MdxPage",name:"trpc",route:"/docs/utilization/trpc"},{kind:"Meta",data:{nestjs:"NestJS",prisma:"Prisma",trpc:"tRPC"}}]},{kind:"Folder",name:"validators",route:"/docs/validators",children:[{kind:"MdxPage",name:"assert",route:"/docs/validators/assert"},{kind:"MdxPage",name:"comment-tags",route:"/docs/validators/comment-tags"},{kind:"MdxPage",name:"is",route:"/docs/validators/is"},{kind:"MdxPage",name:"validate",route:"/docs/validators/validate"},{kind:"Meta",data:{is:"is() function",assert:"assert() function",validate:"validate() function","comment-tags":"Comment Tags"}}]},{kind:"Meta",data:{index:"\uD83D\uDE4B\uD83C\uDFFB‍♂️ Introduction",setup:"\uD83D\uDCE6 Setup",pure:"⛲ Pure TypeScript","-- features":{type:"separator",title:"\uD83D\uDCD6 Features"},validators:"Runtime Validators",json:"Enhanced JSON",random:"Random Generator",miscellaneous:"Miscellaneous","-- appendix":{type:"separator",title:"\uD83D\uDD17 Appendix"},utilization:"Utilization Cases",benchmark:{title:"⇲ Benchmark Result",href:"https://github.com/samchon/typia/tree/master/benchmark/results/11th%20Gen%20Intel(R)%20Core(TM)%20i5-1135G7%20%40%202.40GHz",newWindow:!0},articles:{title:"⇲ dev.to Articles",href:"https://dev.to/samchon/series/22474",newWindow:!0}}}]},{kind:"MdxPage",name:"index",route:"/"},{kind:"Folder",name:"playground",route:"/playground",children:[{kind:"MdxPage",name:"index",route:"/playground"},{kind:"Meta",data:{index:{title:"Typia Playground",theme:{layout:"raw",footer:!1}}}}]},{kind:"Meta",data:{index:{title:"Introduction",type:"page",hidden:!0,display:"hidden"},docs:{title:"\uD83D\uDCD6 Guide Documents",type:"page"},playground:{title:"\uD83D\uDCBB Playground",type:"page"},contact:{title:"✉ Contact Me",type:"page",href:"mailto:samchon.github@gmail.com"}}}],flexsearch:{codeblocks:!0},title:"Index"},pageNextRoute:"/playground",nextraLayout:l.ZP,themeConfig:c.Z};var j=(0,s.j)(k)},3411:function(e){function n(e){var n=Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}n.keys=function(){return[]},n.resolve=n,n.id=3411,e.exports=n},2183:function(){},3024:function(){},2715:function(){},3611:function(){},8353:function(){},1210:function(){},3454:function(){}},function(e){e.O(0,[138,109,583,774,888,179],function(){return e(e.s=3589)}),_N_E=e.O()}]);